{"version":3,"file":"workflow.types-BgUyfmVM.js","sources":["../src/workflow.types.ts"],"sourcesContent":["// ============================================================================\r\n// Source Config Types (source.json)\r\n// ============================================================================\r\n\r\nexport interface SourceConfig {\r\n\tversion: string;\r\n\tsourceTypes: string[];\r\n\tglobals?: SourceGlobals;\r\n\t/** Top-level page selection: \"all\" or array of page numbers. */\r\n\tpages?: number[] | 'all';\r\n\tsections: SourceSection[];\r\n\t/** Legacy: rules keyed by section ID. Superseded by areaRules. */\r\n\tsectionRules?: Record<string, SectionRuleSet>;\r\n\t/** Rules for breaking area elements into individually-mappable sections, keyed by area name in kebab-case.\r\n\t * Supports both old flat format { rules: [...] } and new grouped format { groups: [...], rules: [...] }. */\r\n\tareaRules?: Record<string, AreaRules>;\r\n}\r\n\r\n// ============================================================================\r\n// Section Rules Types (stored in source.json under sectionRules)\r\n// ============================================================================\r\n\r\n/** Legacy flat rule set — kept for backward-compatible deserialization of sectionRules. */\r\nexport interface SectionRuleSet {\r\n\trules: SectionRule[];\r\n}\r\n\r\n// ============================================================================\r\n// v3 Area Rules Types (groups + ungrouped)\r\n// ============================================================================\r\n\r\n/** Which slot a rule fills within a group. Title triggers section boundaries. */\r\nexport type RulePart = 'title' | 'content' | 'description' | 'summary';\r\n\r\n/** Top-level container for an area's rules. Groups contain multi-part sections; ungrouped rules are single properties. */\r\nexport interface AreaRules {\r\n\tgroups: RuleGroup[];\r\n\trules: SectionRule[];  // Ungrouped\r\n}\r\n\r\n/** A named group of rules representing a multi-part section (e.g., \"Tour Detail\" with title + content). */\r\nexport interface RuleGroup {\r\n\tname: string;\r\n\trules: SectionRule[];\r\n}\r\n\r\n/** Legacy action names — kept for backward compat deserialization */\r\nexport type RuleAction = 'singleProperty' | 'sectionTitle' | 'sectionContent' | 'sectionDescription' | 'sectionSummary' | 'exclude';\r\nexport type LegacyRuleAction = 'createSection' | 'setAsHeading' | 'addAsContent' | 'addAsList';\r\n\r\n/**\r\n * Block-level Markdown format.\r\n * Determines what Markdown syntax the matched content produces.\r\n */\r\nexport type BlockFormat =\r\n\t| 'auto'\r\n\t| 'paragraph'\r\n\t| 'heading1' | 'heading2' | 'heading3'\r\n\t| 'heading4' | 'heading5' | 'heading6'\r\n\t| 'bulletListItem' | 'numberedListItem'\r\n\t| 'quote';\r\n\r\n/** Legacy alias — kept for backward compat */\r\nexport type RuleContentFormat = BlockFormat;\r\n\r\n/** Format entry types — Block (block-level Markdown) or Style (inline Markdown) */\r\nexport type FormatEntryType = 'block' | 'style';\r\n\r\n/** Block-level format values — each maps to a Markdown block element */\r\nexport type BlockFormatValue =\r\n\t| 'auto'\r\n\t| 'paragraph'\r\n\t| 'heading1' | 'heading2' | 'heading3'\r\n\t| 'heading4' | 'heading5' | 'heading6'\r\n\t| 'bulletListItem' | 'numberedListItem'\r\n\t| 'quote';\r\n\r\n/** Inline style format values — each wraps text in Markdown inline syntax */\r\nexport type StyleFormatValue = 'bold' | 'italic' | 'strikethrough' | 'code' | 'highlight';\r\n\r\n/** A single format entry — either a block format or an inline style */\r\nexport interface FormatEntry {\r\n\ttype: FormatEntryType;\r\n\tvalue: BlockFormatValue | StyleFormatValue;\r\n}\r\n\r\nexport interface SectionRule {\r\n\trole: string;\r\n\t/** v3: which slot this rule fills. */\r\n\tpart?: RulePart;\r\n\t/** Legacy: action name. When part is set, action is ignored. */\r\n\taction?: RuleAction | LegacyRuleAction;\r\n\t/** Block format: auto, paragraph, heading1-6, etc. */\r\n\tformat?: BlockFormat;\r\n\t/** Array of format entries (Block + Style rows). */\r\n\tformats?: FormatEntry[];\r\n\t/** When true, matched elements are skipped entirely. */\r\n\texclude?: boolean;\r\n\tconditions: RuleCondition[];\r\n\t/** UNLESS conditions — if any single exception matches, the rule does not apply. */\r\n\texceptions?: RuleCondition[];\r\n\t/** Transient: unique ID for drag-and-drop tracking. Not persisted. */\r\n\t_id?: string;\r\n}\r\n\r\n/** Get the effective part for a rule, normalizing from legacy action if needed. */\r\nexport function getEffectivePart(rule: SectionRule): RulePart | 'exclude' {\r\n\tif (rule.exclude) return 'exclude';\r\n\tif (rule.part) return rule.part;\r\n\r\n\t// Normalize from legacy action\r\n\tswitch (rule.action) {\r\n\t\tcase 'singleProperty':\r\n\t\tcase 'sectionProperty':\r\n\t\tcase 'sectionContent':\r\n\t\tcase 'addAsContent':\r\n\t\tcase 'addAsList':\r\n\t\t\treturn 'content';\r\n\t\tcase 'sectionTitle':\r\n\t\tcase 'createSection':\r\n\t\tcase 'setAsHeading':\r\n\t\t\treturn 'title';\r\n\t\tcase 'sectionDescription':\r\n\t\t\treturn 'description';\r\n\t\tcase 'sectionSummary':\r\n\t\t\treturn 'summary';\r\n\t\tcase 'exclude':\r\n\t\t\treturn 'exclude';\r\n\t\tdefault:\r\n\t\t\treturn 'content';\r\n\t}\r\n}\r\n\r\n/** Get the effective block format for a rule. */\r\nexport function getEffectiveFormat(rule: SectionRule): BlockFormat {\r\n\tif (rule.format) return rule.format;\r\n\tif (rule.action === 'addAsList') return 'bulletListItem';\r\n\treturn 'auto';\r\n}\r\n\r\n/** Legacy normalize helper — kept for backward compat. Prefer getEffectivePart/getEffectiveFormat. */\r\nexport function normalizeAction(action: string, format?: RuleContentFormat): [RuleAction, RuleContentFormat | undefined] {\r\n\tswitch (action) {\r\n\t\tcase 'createSection':\r\n\t\tcase 'setAsHeading':\r\n\t\t\treturn ['sectionTitle', undefined];\r\n\t\tcase 'addAsContent':\r\n\t\t\treturn ['sectionContent', format ?? 'paragraph'];\r\n\t\tcase 'addAsList':\r\n\t\t\treturn ['sectionContent', format ?? 'bulletListItem'];\r\n\t\tcase 'singleProperty':\r\n\t\tcase 'sectionProperty':\r\n\t\t\treturn ['singleProperty', format ?? 'paragraph'];\r\n\t\tcase 'sectionTitle':\r\n\t\t\treturn ['sectionTitle', undefined];\r\n\t\tcase 'sectionContent':\r\n\t\t\treturn ['sectionContent', format ?? 'paragraph'];\r\n\t\tcase 'exclude':\r\n\t\t\treturn ['exclude', undefined];\r\n\t\tdefault:\r\n\t\t\treturn ['sectionContent', format ?? 'paragraph'];\r\n\t}\r\n}\r\n\r\n/**\r\n * Convert a legacy SectionRuleSet (flat rules) to AreaRules.\r\n * All rules go into the ungrouped array; groups is empty.\r\n */\r\nexport function toAreaRules(ruleSet: SectionRuleSet | AreaRules): AreaRules {\r\n\t// Already an AreaRules (has groups property)\r\n\tif ('groups' in ruleSet && Array.isArray(ruleSet.groups)) {\r\n\t\treturn ruleSet as AreaRules;\r\n\t}\r\n\t// Legacy SectionRuleSet — wrap\r\n\treturn { groups: [], rules: (ruleSet as SectionRuleSet).rules };\r\n}\r\n\r\n/** Get all rules from an AreaRules in order: grouped first, then ungrouped. */\r\nexport function allRules(areaRules: AreaRules): SectionRule[] {\r\n\tconst result: SectionRule[] = [];\r\n\tfor (const group of areaRules.groups) {\r\n\t\tresult.push(...group.rules);\r\n\t}\r\n\tresult.push(...areaRules.rules);\r\n\treturn result;\r\n}\r\n\r\nexport interface RuleCondition {\r\n\ttype: RuleConditionType;\r\n\tvalue?: string | number;\r\n}\r\n\r\nexport type RuleConditionType =\r\n\t| 'textBeginsWith'\r\n\t| 'textEndsWith'\r\n\t| 'textContains'\r\n\t| 'textEquals'\r\n\t| 'textMatchesPattern'\r\n\t| 'fontSizeEquals'\r\n\t| 'fontSizeAbove'\r\n\t| 'fontSizeBelow'\r\n\t| 'fontNameContains'\r\n\t| 'fontNameEquals'\r\n\t| 'colorEquals'\r\n\t| 'positionFirst'\r\n\t| 'positionLast';\r\n\r\n/**\r\n * Pattern for identifying section heading elements within an area.\r\n * Null/undefined = auto-detect (bodySize * 1.15).\r\n * Empty conditions = flat section (no grouping).\r\n * Populated conditions = user-defined from teach-by-example.\r\n */\r\nexport interface SectionPattern {\r\n\tconditions: RuleCondition[];\r\n}\r\n\r\nexport interface SourceGlobals {\r\n\tcolumnDetection?: ColumnDetectionConfig;\r\n\tpageRange?: PageRangeConfig;\r\n}\r\n\r\nexport interface ColumnDetectionConfig {\r\n\tenabled: boolean;\r\n\tthresholdPercent: number;\r\n}\r\n\r\nexport interface PageRangeConfig {\r\n\tstart: number;\r\n\tend: number | 'last';\r\n}\r\n\r\nexport interface SourceSection {\r\n\tkey: string;\r\n\tlabel: string;\r\n\tdescription?: string;\r\n\tstrategy: ExtractionStrategy;\r\n\toutputFormat: 'text' | 'markdown' | 'html';\r\n\trequired?: boolean;\r\n\tpages?: number[] | 'all';\r\n\tcolumnFilter?: boolean;\r\n\toccurrence?: 'first' | 'last' | 'all';\r\n\tstrategyParams?: StrategyParams;\r\n}\r\n\r\nexport type ExtractionStrategy =\r\n\t| 'largestFont'\r\n\t| 'regex'\r\n\t| 'betweenPatterns'\r\n\t| 'region'\r\n\t| 'afterLabel'\r\n\t| 'firstHeading'\r\n\t| 'firstParagraph'\r\n\t| 'cssSelector'\r\n\t| 'xpath';\r\n\r\nexport interface StrategyParams {\r\n\t// largestFont\r\n\tfontSizeThreshold?: number;\r\n\r\n\t// regex\r\n\tpattern?: string;\r\n\tflags?: string;\r\n\tcaptureGroup?: number;\r\n\r\n\t// betweenPatterns\r\n\tstartPattern?: string;\r\n\tstopPatterns?: string[];\r\n\tincludeStartLine?: boolean;\r\n\theadingLevel?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\r\n\r\n\t// region\r\n\tregion?: RegionConfig;\r\n\r\n\t// firstHeading (markdown)\r\n\tlevel?: number;\r\n\r\n\t// afterLabel\r\n\tlabel?: string;\r\n\tlabelPattern?: string;\r\n\textractMode?: 'sameLine' | 'nextLine' | 'untilBlank';\r\n\r\n\t// cssSelector (web)\r\n\tselector?: string;\r\n\tattribute?: string;\r\n\r\n\t// xpath (web/Word)\r\n\txpath?: string;\r\n}\r\n\r\nexport interface RegionConfig {\r\n\tx?: { min?: number; max?: number };\r\n\ty?: { min?: number; max?: number };\r\n\tunit?: 'percent' | 'points';\r\n}\r\n\r\n// ============================================================================\r\n// Destination Config Types (destination.json)\r\n// ============================================================================\r\n\r\nexport interface DestinationConfig {\r\n\tversion: string;\r\n\tdocumentTypeAlias: string;\r\n\tdocumentTypeName?: string;\r\n\tblueprintId?: string;\r\n\tblueprintName?: string;\r\n\tfields: DestinationField[];\r\n\tblockGrids?: DestinationBlockGrid[];\r\n}\r\n\r\nexport interface DestinationField {\r\n\tkey: string;\r\n\talias: string;\r\n\tlabel: string;\r\n\tdescription?: string;\r\n\ttype: FieldType;\r\n\ttab?: string;\r\n\tmandatory?: boolean;\r\n\tacceptsFormats?: ContentFormat[];\r\n}\r\n\r\nexport type FieldType =\r\n\t| 'text'\r\n\t| 'textArea'\r\n\t| 'richText'\r\n\t| 'number'\r\n\t| 'date'\r\n\t| 'boolean'\r\n\t| 'mediaPicker'\r\n\t| 'contentPicker'\r\n\t| 'blockGrid'\r\n\t| 'blockList';\r\n\r\nexport type ContentFormat = 'text' | 'markdown' | 'html';\r\n\r\nexport interface DestinationBlockGrid {\r\n\tkey: string;\r\n\talias: string;\r\n\tlabel: string;\r\n\tdescription?: string;\r\n\tblocks: DestinationBlock[];\r\n}\r\n\r\nexport interface DestinationBlock {\r\n\tkey: string;\r\n\tcontentTypeAlias: string;\r\n\tcontentTypeKey?: string;\r\n\tlabel: string;\r\n\tdescription?: string;\r\n\tidentifyBy?: BlockIdentifier;\r\n\tproperties?: BlockProperty[];\r\n}\r\n\r\nexport interface BlockIdentifier {\r\n\tproperty: string;\r\n\tvalue: string;\r\n}\r\n\r\nexport interface BlockProperty {\r\n\tkey: string;\r\n\talias: string;\r\n\tlabel?: string;\r\n\ttype: FieldType;\r\n\tacceptsFormats?: ContentFormat[];\r\n}\r\n\r\n// ============================================================================\r\n// Map Config Types (map.json)\r\n// ============================================================================\r\n\r\nexport interface MapConfig {\r\n\tversion: string;\r\n\tname?: string;\r\n\tdescription?: string;\r\n\tmappings: SectionMapping[];\r\n}\r\n\r\nexport interface SectionMapping {\r\n\tsource: string;\r\n\tdestinations: MappingDestination[];\r\n\tenabled?: boolean;\r\n\tcomment?: string;\r\n}\r\n\r\nexport interface MappingDestination {\r\n\ttarget: string;\r\n\tblockKey?: string;\r\n\ttransforms?: MappingTransform[];\r\n}\r\n\r\nexport interface MappingTransform {\r\n\ttype: TransformType;\r\n\tparams?: TransformParams;\r\n}\r\n\r\nexport type TransformType =\r\n\t| 'convertMarkdownToHtml'\r\n\t| 'convertHtmlToMarkdown'\r\n\t| 'truncate'\r\n\t| 'template'\r\n\t| 'regex'\r\n\t| 'trim'\r\n\t| 'uppercase'\r\n\t| 'lowercase'\r\n\t| 'stripHtml';\r\n\r\nexport interface TransformParams {\r\n\tmaxLength?: number;\r\n\tsuffix?: string;\r\n\ttemplate?: string;\r\n\tpattern?: string;\r\n\treplacement?: string;\r\n}\r\n\r\n// ============================================================================\r\n// Combined Document Type Config\r\n// ============================================================================\r\n\r\nexport interface DocumentTypeConfig {\r\n\tfolderPath: string;\r\n\tdocumentTypeAlias: string;\r\n\tsources: Record<string, SourceConfig>;\r\n\tdestination: DestinationConfig;\r\n\tmap: MapConfig;\r\n}\r\n\r\n// ============================================================================\r\n// Rich Extraction Types (sample-extraction.json)\r\n// ============================================================================\r\n\r\nexport interface RichExtractionResult {\r\n\tversion: string;\r\n\tsourceType: string;\r\n\tsource: ExtractionSource;\r\n\telements: ExtractionElement[];\r\n}\r\n\r\nexport interface ExtractionSource {\r\n\tfileName: string;\r\n\tmediaKey: string;\r\n\textractedDate: string;\r\n\ttotalPages: number;\r\n\t/** Which pages were extracted. Null/undefined = all pages. */\r\n\textractedPages?: number[] | null;\r\n}\r\n\r\nexport interface ExtractionElement {\r\n\tid: string;\r\n\tpage: number;\r\n\ttext: string;\r\n\tmetadata: ElementMetadata;\r\n}\r\n\r\nexport interface ElementMetadata {\r\n\tfontSize: number;\r\n\tfontName: string;\r\n\tposition: { x: number; y: number };\r\n\tboundingBox: { left: number; top: number; width: number; height: number };\r\n\tcolor: string;\r\n}\r\n\r\n// ============================================================================\r\n// Visual Grouping Types (frontend-only, computed from extraction metadata)\r\n// ============================================================================\r\n\r\nexport interface VisualGroup {\r\n\theading: ExtractionElement | null;\r\n\tchildren: ExtractionElement[];\r\n}\r\n\r\n// ============================================================================\r\n// Area Detection Types (area-detection.json — area-based hierarchical extraction)\r\n// ============================================================================\r\n\r\nexport interface AreaDetectionResult {\r\n\ttotalPages: number;\r\n\tpages: PageAreas[];\r\n\tdiagnostics: AreaDiagnosticInfo;\r\n}\r\n\r\nexport interface PageAreas {\r\n\tpage: number;\r\n\tareas: DetectedArea[];\r\n}\r\n\r\nexport interface DetectedArea {\r\n\tname?: string;\r\n\tcolor: string;\r\n\tboundingBox: { left: number; top: number; width: number; height: number };\r\n\tpage: number;\r\n\tsections: DetectedSection[];\r\n\ttotalElements: number;\r\n\tsectionPattern?: SectionPattern;\r\n}\r\n\r\nexport interface DetectedSection {\r\n\theading: AreaElement | null;\r\n\tchildren: AreaElement[];\r\n}\r\n\r\nexport interface AreaElement {\r\n\tid: string;\r\n\ttext: string;\r\n\tfontSize: number;\r\n\tfontName: string;\r\n\tcolor: string;\r\n\tboundingBox: { left: number; top: number; width: number; height: number };\r\n}\r\n\r\nexport interface AreaDiagnosticInfo {\r\n\ttotalPathsFound: number;\r\n\tpathsAfterFiltering: number;\r\n\tareasDetected: number;\r\n\telementsInAreas: number;\r\n}\r\n\r\n// ============================================================================\r\n// Transform Result Types (transform.json — assembled Markdown per section)\r\n// ============================================================================\r\n\r\nexport interface TransformResult {\r\n\tversion: string;\r\n\tareas: TransformArea[];\r\n\tdiagnostics: TransformDiagnostics;\r\n}\r\n\r\n/** An area from the PDF page containing groups and ungrouped sections. */\r\nexport interface TransformArea {\r\n\tname: string;\r\n\tcolor: string | null;\r\n\tpage: number;\r\n\tgroups: TransformGroup[];\r\n\tsections: TransformedSection[];\r\n}\r\n\r\n/** A named group of multi-part sections from grouped rules. */\r\nexport interface TransformGroup {\r\n\tname: string;\r\n\tsections: TransformedSection[];\r\n}\r\n\r\n/** Helper: get all sections from a TransformResult as a flat array. */\r\nexport function allTransformSections(result: TransformResult): TransformedSection[] {\r\n\tconst sections: TransformedSection[] = [];\r\n\tfor (const area of result.areas) {\r\n\t\tfor (const group of area.groups) {\r\n\t\t\tsections.push(...group.sections);\r\n\t\t}\r\n\t\tsections.push(...area.sections);\r\n\t}\r\n\treturn sections;\r\n}\r\n\r\nexport interface TransformedSection {\r\n\tid: string;\r\n\toriginalHeading: string | null;\r\n\theading: string | null;\r\n\tcontent: string;\r\n\t/** Assembled Markdown from sectionDescription elements. Null if none. */\r\n\tdescription?: string | null;\r\n\t/** Assembled Markdown from sectionSummary elements. Null if none. */\r\n\tsummary?: string | null;\r\n\tpattern: 'bulletList' | 'paragraph' | 'subHeaded' | 'preamble' | 'mixed' | 'role';\r\n\tpage: number;\r\n\tareaColor: string | null;\r\n\tareaName: string | null;\r\n\t/** Rule group name for grouped sections (e.g., \"Tour Details - Section\"). Null for ungrouped. */\r\n\tgroupName?: string | null;\r\n\t/** Individual rule name (from SectionRule.Role). For ungrouped: the rule name. For grouped: the title rule's name. Null for non-rule sections. */\r\n\truleName?: string | null;\r\n\tchildCount: number;\r\n\tincluded: boolean;\r\n}\r\n\r\nexport interface TransformDiagnostics {\r\n\ttotalSections: number;\r\n\tbulletListSections: number;\r\n\tparagraphSections: number;\r\n\tsubHeadedSections: number;\r\n\tpreambleSections: number;\r\n\troleSections: number;\r\n}\r\n\r\n// ============================================================================\r\n// Area Template Types (area-template.json — user-defined extraction areas)\r\n// ============================================================================\r\n\r\nexport interface AreaTemplate {\r\n\ttemplateName: string;\r\n\tsourceFile: string;\r\n\tpageSize: { width: number; height: number };\r\n\tcreatedAt: string;\r\n\tareas: AreaDefinition[];\r\n}\r\n\r\nexport interface AreaDefinition {\r\n\tname: string;\r\n\tproperty: string;\r\n\tpage: number;\r\n\ttype: string;\r\n\tbounds: AreaBounds;\r\n\tcolor: string;\r\n\tsectionPattern?: SectionPattern;\r\n\texpectedSections: string[];\r\n\tnotes: string;\r\n}\r\n\r\nexport interface AreaBounds {\r\n\tx: number;\r\n\ty: number;\r\n\twidth: number;\r\n\theight: number;\r\n}\r\n\r\n// ============================================================================\r\n// API Response Types\r\n// ============================================================================\r\n\r\nexport interface ExtractSectionsResponse {\r\n\tsections: Record<string, string>;\r\n\tconfig: DocumentTypeConfig;\r\n}\r\n\r\nexport interface InferSectionPatternResponse {\r\n\tpattern: SectionPattern;\r\n\tmatchingElementIds: string[];\r\n\tclickedElementId: string;\r\n\ttotalElements: number;\r\n}\r\n"],"names":["getEffectivePart","rule","getEffectiveFormat","allTransformSections","result","sections","area","group"],"mappings":"AA0GO,SAASA,EAAiBC,GAAyC;AACzE,MAAIA,EAAK,QAAS,QAAO;AACzB,MAAIA,EAAK,KAAM,QAAOA,EAAK;AAG3B,UAAQA,EAAK,QAAA;AAAA,IACZ,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AAAA,IACL,KAAK;AAAA,IACL,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR,KAAK;AACJ,aAAO;AAAA,IACR;AACC,aAAO;AAAA,EAAA;AAEV;AAGO,SAASC,EAAmBD,GAAgC;AAClE,SAAIA,EAAK,SAAeA,EAAK,SACzBA,EAAK,WAAW,cAAoB,mBACjC;AACR;AAoZO,SAASE,EAAqBC,GAA+C;AACnF,QAAMC,IAAiC,CAAA;AACvC,aAAWC,KAAQF,EAAO,OAAO;AAChC,eAAWG,KAASD,EAAK;AACxB,MAAAD,EAAS,KAAK,GAAGE,EAAM,QAAQ;AAEhC,IAAAF,EAAS,KAAK,GAAGC,EAAK,QAAQ;AAAA,EAC/B;AACA,SAAOD;AACR;"}