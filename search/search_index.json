{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"UpDoc - Umbraco Extension","text":""},{"location":"#intro","title":"Intro","text":"<ul> <li>What it does: Allows editors to create Umbraco content documents by extracting content from source files (PDF, Web Page, Word Document)</li> <li>The problem it solves: Manual copy/paste from source documents into Umbraco is tedious and error-prone</li> <li>How it works: Adds a \"Create Document from Source\" option to the content tree context menu, opens a blueprint picker dialog, then a sidebar panel where the user selects a source, processes the content, and creates a new document</li> <li>Target users: Umbraco content editors</li> <li>Tech stack: Umbraco 17+, Lit components, backend API for content extraction</li> <li>Package type: Razor Class Library (RCL) \u2014 installable via NuGet in any Umbraco project</li> </ul>"},{"location":"#project-structure","title":"Project Structure","text":"<ul> <li><code>src/UpDoc/</code> \u2014 The Razor Class Library (the installable package)</li> <li><code>src/UpDoc.TestSite/</code> \u2014 Development/testing host site</li> </ul>"},{"location":"common-errors/","title":"Common Errors","text":""},{"location":"common-errors/#distributed-cache-error-on-startup","title":"Distributed cache error on startup","text":"<p>If you see <code>DISTRIBUTED CACHE IS NOT UPDATED. Failed to execute instructions</code> in the Umbraco log on startup, clear the stale cache instructions from the SQLite database:</p> <pre><code>DELETE FROM umbracoCacheInstruction;\n</code></pre> <p>Open <code>umbraco/Data/Umbraco.sqlite.db</code> in DB Browser for SQLite, run the query under Execute SQL, then click Write Changes. Restart the site.</p> <p>This happens when the site is stopped while cache instructions are still being processed (common during development). It's harmless on a single-instance dev setup but will log errors on every startup until cleared.</p>"},{"location":"mapping-directions/","title":"Mapping Directions","text":"<p>How UpDoc handles mapping between source content and destination fields, and why the two directions work differently.</p>"},{"location":"mapping-directions/#overview","title":"Overview","text":"<p>UpDoc's workflow editor provides two ways to create mappings:</p> <ul> <li>Source-to-destination: Start with extracted content, pick where it goes</li> <li>Destination-to-source: Start with a blueprint field, pick what fills it</li> </ul> <p>Both directions write to the same <code>map.json</code> file and produce identical mappings. The difference is in how they handle block property disambiguation \u2014 the process of identifying which specific block instance a property belongs to when multiple blocks share the same property names.</p>"},{"location":"mapping-directions/#why-disambiguation-matters","title":"Why Disambiguation Matters","text":"<p>Umbraco document types often use compositions to share property sets across block types. For example, a Group Tour page might have three blocks in its content grid:</p> <ul> <li>Suggested Itinerary \u2014 with Title, Description, Rich Text, Summary</li> <li>Features \u2014 with Title, Description, Rich Text, Summary</li> <li>Accommodation \u2014 with Title, Description, Rich Text, Summary</li> </ul> <p>All three blocks have a \"Rich Text\" property (alias: <code>richTextContent</code>), a \"Title\" property, and so on. When creating a mapping, UpDoc needs to know which block's Rich Text field you mean.</p>"},{"location":"mapping-directions/#source-to-destination-mapping","title":"Source-to-Destination Mapping","text":"<p>Starting point: You select one or more extracted content elements on the Source tab, then click \"Map to...\".</p> <p>How it works: The destination picker opens, showing all available fields organised by tab. Block properties are listed under their block's label \u2014 so you see \"Rich Text\" under \"Suggested Itinerary\", separately from \"Rich Text\" under \"Features\".</p> <p>Disambiguation: You explicitly choose which block's property to target by selecting it within its block group. UpDoc stores a <code>blockKey</code> in the mapping that permanently identifies which block instance you selected. This means:</p> <ul> <li>Checking \"Rich Text\" under \"Suggested Itinerary\" does not also check \"Rich Text\" under \"Features\" or \"Accommodation\"</li> <li>The mapping remembers your specific choice</li> <li>At content creation time, the correct block instance receives the content</li> </ul> <p>Best for: When you have extracted content and want to decide where each piece goes.</p>"},{"location":"mapping-directions/#destination-to-source-mapping","title":"Destination-to-Source Mapping","text":"<p>Starting point: You click on a specific field within a specific block on the Destination tab, then pick which source content fills it.</p> <p>How it works: Because you're already looking at a particular block's property (e.g., \"Rich Text\" within the \"Suggested Itinerary\" block), the block context is inherent in your interaction. There's no ambiguity \u2014 you've already identified exactly which field you want to populate.</p> <p>Disambiguation: Not needed as an explicit step. The block context comes directly from where you clicked.</p> <p>Best for: When you're working through the blueprint structure and want to fill each field in order.</p>"},{"location":"mapping-directions/#choosing-a-direction","title":"Choosing a Direction","text":"<p>Both directions produce the same result. Choose whichever feels most natural for your task:</p> Scenario Recommended direction You have a PDF with clear sections and want to assign each one Source-to-destination You want to work through the blueprint field by field Destination-to-source You're mapping a few specific fields Either works Multiple blocks share the same property names Either \u2014 both handle disambiguation correctly <p>The Map tab always shows all mappings regardless of how they were created, and you can edit or delete any mapping from there.</p>"},{"location":"user-journeys/","title":"User Journeys","text":"<p>Step-by-step paths through the UpDoc interface for creating documents from external sources.</p>"},{"location":"user-journeys/#journey-1-create-from-source-via-the-content-tree","title":"Journey 1: Create from Source via the Content Tree","text":"<p>The primary entry point \u2014 available from the \"...\" actions menu on any content node that has child types with configured workflows.</p> <ol> <li>Navigate to the Content section in Umbraco backoffice</li> <li>In the content tree (left panel), find the parent node where you want to create a child document (e.g., \"Group Tours\")</li> <li>Click the \"...\" actions button on that node</li> <li>Click \"Create Document from Source\"</li> <li>The blueprint picker dialog appears:<ul> <li>If multiple document types are allowed, select the document type first</li> <li>Then select a blueprint (only blueprints with configured workflows are shown)</li> </ul> </li> <li>The source sidebar slides open from the right:<ul> <li>Choose a source type from the dropdown (e.g., PDF, Markdown)</li> <li>Select a source file using the media picker</li> <li>The extracted content appears in the preview area</li> <li>Edit the document name if needed</li> <li>Review the extracted sections</li> </ul> </li> <li>Click \"Create\"</li> <li>The document is created and you are navigated to the new document editor</li> </ol> <p>When is this available? The \"Create Document from Source\" action only appears on nodes where at least one allowed child document type has a blueprint with a complete workflow (destination + map + at least one source type configured).</p>"},{"location":"user-journeys/#journey-2-create-from-source-via-the-collection-view","title":"Journey 2: Create from Source via the Collection View","text":"<p>A secondary entry point \u2014 available as a toolbar button when viewing a document collection (list view).</p> <ol> <li>Navigate to a content node that uses a list view (e.g., click \"Group Tours\" to see the collection of tours)</li> <li>In the collection toolbar, next to the existing \"Create Group Tour\" button, click \"Create from Source\"</li> <li>The blueprint picker dialog appears (same as Journey 1, step 5)</li> <li>The source sidebar slides open (same as Journey 1, step 6)</li> <li>Click \"Create\"</li> <li>The document is created and you are navigated to the new document editor</li> </ol> <p>When is this available? The \"Create from Source\" button only appears on document collections where at least one allowed child document type has a blueprint with a complete workflow. If no workflows are configured, the button is hidden.</p>"},{"location":"user-journeys/#entry-point-comparison","title":"Entry Point Comparison","text":"Feature Content Tree (Journey 1) Collection View (Journey 2) Location \"...\" actions menu on tree nodes Toolbar button in collection view Visibility Controlled by <code>HasAvailableWorkflows</code> condition Self-hiding element checks workflows internally Context <code>UMB_ENTITY_CONTEXT</code> provides parent node <code>UMB_DOCUMENT_WORKSPACE_CONTEXT</code> provides parent node Flow after click Identical Identical Result New document created under parent New document created under parent <p>Both journeys lead to the same blueprint picker \u2192 source sidebar \u2192 document creation flow. The only difference is where the user starts.</p>"},{"location":"user-journeys/#how-source-content-is-extracted","title":"How Source Content is Extracted","text":"<p>When a source document is imported, UpDoc analyses its structure and organises the extracted content into a four-level hierarchy:</p> <pre><code>Page\n\u2514\u2500\u2500 Area\n    \u2514\u2500\u2500 Section\n        \u2514\u2500\u2500 Text\n</code></pre>"},{"location":"user-journeys/#page","title":"Page","text":"<p>Each page of the source document is processed independently. Content is extracted page by page, preserving the original document order. For single-page sources (such as a web page), all content belongs to one page.</p>"},{"location":"user-journeys/#area","title":"Area","text":"<p>Within each page, UpDoc detects visually distinct areas that group content together. In a PDF, these are colored filled rectangles \u2014 background colors used to separate content into columns, sidebars, or feature panels. Each colored region becomes an area.</p> <p>Content that falls outside any detected area is grouped as \"undefined\" content.</p>"},{"location":"user-journeys/#section","title":"Section","text":"<p>Within each area, UpDoc identifies sections by detecting headings. A section consists of a heading and all the content that follows it, up to the next heading or the end of the area.</p> <p>Headings are identified by font size \u2014 text that is significantly larger than the surrounding body text is treated as a section heading.</p> <p>Sections are the primary unit of mapping. When creating mappings from source to destination, the workflow author works with sections.</p>"},{"location":"user-journeys/#text","title":"Text","text":"<p>Within each section, individual text items are classified by their content pattern:</p> <ul> <li>Headings \u2014 The section's title text, identified by a larger font size relative to the body text within the section.</li> <li>Lists \u2014 Ordered items (1, 2, 3) or unordered items (bullet points). Identified by leading bullet characters or numeric patterns.</li> <li>Paragraphs \u2014 Free-form body text that does not match a heading or list pattern.</li> </ul>"},{"location":"user-journeys/#summary-counts","title":"Summary Counts","text":"<p>At each level of the hierarchy, UpDoc provides summary counts so the workflow author can quickly assess the structure of the extracted content:</p> Level Shows Page Number of areas detected Area Number of sections identified Section Number of text items within the section <p>These counts help the workflow author identify whether the extraction has correctly understood the document's structure before proceeding to map content to destination fields.</p>"},{"location":"user-journeys/#known-behaviours","title":"Known Behaviours","text":""},{"location":"user-journeys/#duplicate-document-names-and-the-recycle-bin","title":"Duplicate document names and the Recycle Bin","text":"<p>When creating a document, Umbraco checks for name conflicts among live sibling documents (documents under the same parent). If a document with the same name already exists and is live, Umbraco appends a number in brackets \u2014 e.g., \"The Art and History of Dresden (1)\".</p> <p>However, documents in the Recycle Bin are not considered name conflicts. If a document called \"The Art and History of Dresden\" has been moved to the Recycle Bin and a new document with the same name is created under the same parent, the new document keeps the original name without any numbering suffix.</p> <p>This means:</p> <ul> <li>Repeatedly creating and deleting documents from the same source will not cause name inflation (\"(1)\", \"(2)\", etc.) as long as previous copies are moved to the Recycle Bin before the next is created.</li> <li>If a previous document is still live under the same parent when a new one is created from the same source, the new document will receive a numbered suffix.</li> </ul>"},{"location":"backend/","title":"Backend (C#)","text":"<p>The UpDoc server-side code handles PDF/Markdown extraction, workflow configuration, and the Management API endpoints.</p> <p>All source files are in <code>src/UpDoc/</code>.</p> File Description PdfExtractionService.cs Orchestrates PDF extraction \u2014 loads media, delegates to page properties service PdfPagePropertiesService.cs Strategy-driven section extraction from PDF pages using PdfPig MarkdownExtractionService.cs Extracts sections from Markdown files using heading-based splitting PdfExtractionController.cs Management API controller \u2014 endpoints for extraction, config, and workflow management UpDocComposer.cs Umbraco composer that registers all UpDoc services with dependency injection WorkflowModels.cs C# models for workflow JSON files (source, destination, map configs) WorkflowService.cs Reads and manages workflow folders \u2014 scans <code>updoc/workflows/</code>, loads configs, lists active workflows"},{"location":"deployment/","title":"Deployment","text":"<p>Guides for deploying UpDoc and migrating content between Umbraco sites.</p> <ul> <li>uSync Content Migration \u2014 Moving document types, content, and blueprints between sites using uSync</li> </ul>"},{"location":"deployment/usync-migration/","title":"uSync Content Migration","text":""},{"location":"deployment/usync-migration/#overview","title":"Overview","text":"<p>UpDoc's test site serves as the development environment for both the package and client-specific content. Document types, templates, block grids, blueprints, and content are all built here and deployed to production sites via uSync.</p> <p>This guide covers how to export content from the UpDoc test site and import it into a target site.</p>"},{"location":"deployment/usync-migration/#full-import-into-a-new-site","title":"Full Import into a New Site","text":"<p>Use this when setting up a new site from scratch.</p>"},{"location":"deployment/usync-migration/#prerequisites","title":"Prerequisites","text":"<ul> <li>Target site running Umbraco v17+ with uSync installed</li> <li>Target site should have a clean database (no existing content)</li> </ul>"},{"location":"deployment/usync-migration/#step-1-copy-physical-files","title":"Step 1: Copy Physical Files","text":"<p>uSync exports database records but not physical files. Copy these manually before importing:</p> Source Target Notes <code>Views/*.cshtml</code> <code>Views/</code> Templates <code>Views/Partials/</code> <code>Views/Partials/</code> Partial views (block grid components, layouts) <code>wwwroot/media/</code> <code>wwwroot/media/</code> Media files (images, PDFs) Custom stylesheets/scripts Same paths Any frontend assets <p>Templates must be copied first</p> <p>If template <code>.cshtml</code> files are not in place before import, template definitions will fail to import. This cascades to dependent content types, which also fail.</p>"},{"location":"deployment/usync-migration/#step-2-export-from-source-site","title":"Step 2: Export from Source Site","text":"<ol> <li>Open the source site's backoffice</li> <li>Go to Settings &gt; uSync</li> <li>Click Export &gt; Export to File under Everything</li> <li>Download the <code>usync-export.zip</code></li> </ol>"},{"location":"deployment/usync-migration/#step-3-import-into-target-site","title":"Step 3: Import into Target Site","text":"<ol> <li>Complete the Umbraco install wizard on the target site</li> <li>Go to Settings &gt; uSync</li> <li>Click Import &gt; Import from File under Everything</li> <li>Upload the export zip</li> <li>Click Import</li> </ol> <p>Single-pass import required</p> <p>Always import everything in one shot into a clean database. Partial or repeated imports cause <code>UNIQUE constraint failed: umbracoNode.uniqueId</code> errors, particularly with Document Blueprints. Blueprint GUIDs clash with orphaned records from failed imports.</p>"},{"location":"deployment/usync-migration/#step-4-verify","title":"Step 4: Verify","text":"<p>Check these sections in the backoffice:</p> <ul> <li>Content \u2014 all content nodes present</li> <li>Settings &gt; Document Types \u2014 all custom types present</li> <li>Settings &gt; Document Blueprints \u2014 all blueprints present</li> <li>Media \u2014 all media items present</li> <li>Settings &gt; Templates \u2014 all templates present, no warnings</li> </ul>"},{"location":"deployment/usync-migration/#incremental-updates","title":"Incremental Updates","text":"<p>For day-to-day changes after the initial import.</p> <ol> <li>Copy new/changed <code>.config</code> files from <code>uSync/v17/</code> subfolders</li> <li>Copy any new <code>.cshtml</code> template files</li> <li>Import via Settings &gt; uSync &gt; Import or restart the site</li> </ol> <p>Incremental updates are additive and should not cause GUID clashes.</p>"},{"location":"deployment/usync-migration/#updoc-workflow-files","title":"UpDoc Workflow Files","text":"<p>UpDoc workflow configurations (<code>updoc/workflows/</code>) are custom JSON files outside Umbraco's content system. They are not exported by uSync and must be copied manually or managed via version control.</p> <p>Blueprint GUIDs</p> <p>Workflow <code>destination.json</code> files reference blueprints by GUID. As long as the uSync import preserves blueprint GUIDs (which it does in a clean single-pass import), workflows will work correctly on the target site.</p>"},{"location":"deployment/usync-migration/#running-multiple-sites","title":"Running Multiple Sites","text":"<p>When running two Umbraco sites on localhost (different ports), authentication cookies conflict because they share the name <code>UMB_UCONTEXT</code>.</p> <p>Fix: Set unique cookie names in each site's <code>appsettings.json</code>:</p> <pre><code>{\n  \"Umbraco\": {\n    \"CMS\": {\n      \"Security\": {\n        \"AuthCookieName\": \"UMB_UCONTEXT_MYSITE\"\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"deployment/usync-migration/#starting-over","title":"Starting Over","text":"<p>If an import fails:</p> <ol> <li>Stop the site</li> <li>Delete the SQLite database from <code>umbraco/Data/</code></li> <li>Remove the connection string from <code>appsettings.json</code></li> <li>Restart \u2014 Umbraco returns to Install mode</li> <li>Re-run the wizard and reimport</li> </ol>"},{"location":"errors/","title":"Common Errors","text":"<p>Solutions for errors you may encounter when developing with or using UpDoc.</p> Error Description Distributed cache error \"Failed to execute an pointless distributed cache...\" error on document creation Blueprint block grid preview Block grid blocks using <code>AssignedContentItem</code> show content from existing pages instead of blueprint values Block property conversion skipped Block properties show raw markdown when source content differs from blueprint label"},{"location":"errors/blueprint-block-grid-preview/","title":"Blueprint block grid preview shows wrong content","text":""},{"location":"errors/blueprint-block-grid-preview/#symptom","title":"Symptom","text":"<p>When editing a Document Blueprint in Settings &gt; Document Blueprints, block grid blocks that read from the parent document's properties via <code>Umbraco.AssignedContentItem</code> display content from an existing published page instead of the blueprint's own property values.</p> <p>For example, a \"Feature - Page - Title and Description\" block that renders <code>@currentPage.PageTitle</code> shows \"The Moorish Treasures of Andalucia\" (from an existing Tailored Tour page) instead of <code>[Page Title]</code> (the blueprint's placeholder value).</p> <p>Blocks with their own stored values (e.g. Rich Text Editor blocks with inline content) are not affected - they display and save correctly in the blueprint editor.</p>"},{"location":"errors/blueprint-block-grid-preview/#cause","title":"Cause","text":"<p>This is an Umbraco core issue with how <code>Umbraco.AssignedContentItem</code> is resolved during block grid server-side rendering (SSR) previews.</p> <p>When a block's Razor partial reads from <code>Umbraco.AssignedContentItem</code>, the resolution chain in <code>UmbracoViewPage.cs</code> is:</p> <ol> <li>Check if the view model is <code>IPublishedContent</code> - it's a <code>BlockGridItem</code>, so no</li> <li>Check if the view model is <code>IContentModel</code> - it's not</li> <li>Fallback: use <code>UmbracoContext.PublishedRequest.PublishedContent</code></li> </ol> <p>The fallback is the problem. Blueprints are not in the published content cache (<code>IsBlueprint = true</code>, draft-only items). So <code>PublishedRequest.PublishedContent</code> resolves to whatever published content was last in context - typically an existing page of the same document type.</p> <p>Key source files in Umbraco CMS:</p> <ul> <li><code>src/Umbraco.Web.Common/Views/UmbracoViewPage.cs</code> - where <code>AssignedContentItem</code> is set</li> <li><code>src/Umbraco.Web.Common/Templates/TemplateRenderer.cs</code> - where <code>PublishedRequest.PublishedContent</code> is determined</li> </ul>"},{"location":"errors/blueprint-block-grid-preview/#impact-on-updoc","title":"Impact on UpDoc","text":"<p>This is a cosmetic issue in the blueprint editor only. It does not affect UpDoc's content creation pipeline:</p> <ul> <li>The blueprint's stored data is correct (confirmed via uSync XML export)</li> <li>When UpDoc creates a real document from the blueprint, <code>AssignedContentItem</code> resolves to the new document with the correct page properties</li> <li>The editor will see the correct values on the created page</li> </ul>"},{"location":"errors/blueprint-block-grid-preview/#workaround","title":"Workaround","text":"<p>There is no workaround within the blueprint editor. The preview will show stale content from an existing page regardless of what the blueprint's page properties contain.</p> <p>Options:</p> <ol> <li>Accept the cosmetic issue - the blueprint data is correct even though the preview is misleading</li> <li>Use a real content page as a reference - create and maintain a <code>[Tailored Tours Blueprint]</code> content node alongside the actual blueprint, so you can verify the block grid layout on a real page</li> <li>Edit via uSync XML - modify the blueprint's <code>uSync/v17/Blueprints/*.config</code> file directly and import via uSync. The blueprint GUID is preserved, so workflow configurations remain valid.</li> </ol>"},{"location":"errors/blueprint-block-grid-preview/#umbraco-issue","title":"Umbraco issue","text":"<p>Reported to Umbraco CMS: umbraco/Umbraco-CMS#21919</p>"},{"location":"errors/blueprint-block-grid-preview/#affected-versions","title":"Affected versions","text":"<ul> <li>Umbraco CMS v17 (confirmed)</li> <li>Likely affects all versions using block grid SSR preview in blueprint editor</li> </ul>"},{"location":"errors/convert-block-matching/","title":"Block property conversion skipped when source content differs from blueprint label","text":""},{"location":"errors/convert-block-matching/#symptom","title":"Symptom","text":"<p>After creating a document from source (PDF, Markdown, or Web), block properties contain raw markdown instead of properly converted content:</p> <ul> <li>Title fields show markdown heading markup (e.g. <code>## What We Will See</code> instead of <code>What We Will See</code>)</li> <li>Rich text fields show markdown bullet syntax on a single line (e.g. <code>- Item 1 - Item 2 - Item 3</code>) instead of rendered HTML bullet lists</li> <li>TextArea fields retain markdown formatting characters</li> </ul> <p>Other blocks in the same document may work correctly.</p>"},{"location":"errors/convert-block-matching/#cause","title":"Cause","text":"<p>The content creation pipeline has two passes:</p> <ol> <li>Apply pass \u2014 writes mapped source values into block properties (matches blocks by <code>contentTypeKey</code>)</li> <li>Convert pass \u2014 transforms values based on field type: <code>stripMarkdown()</code> for text/textArea, <code>markdownToHtml()</code> for richText</li> </ol> <p>The bug was in the convert pass. It matched blocks using <code>identifyBy</code> \u2014 a text search that looks for the blueprint's original label value inside the block's title property. For example, a block labelled \"Sights\" in the blueprint would be matched by searching for the string <code>\"Sights\"</code> in <code>featurePropertyFeatureTitle</code>.</p> <p>The problem: by the time the convert pass runs, the apply pass has already overwritten the title with the source content (e.g. <code>\"## What We Will See\"</code>). Since <code>\"## What We Will See\"</code> does not contain <code>\"Sights\"</code>, the block is not matched and the conversion is skipped entirely.</p>"},{"location":"errors/convert-block-matching/#why-it-was-latent","title":"Why it was latent","text":"<p>Existing blocks worked by coincidence \u2014 their source PDF section headings happened to match the blueprint labels:</p> Blueprint label Source section heading Contains label? Result Features Features Yes Worked Accommodation Accommodation Yes Worked Itinerary Itinerary Yes Worked Sights What We Will See No Broken <p>Any block where the source heading differs from the blueprint label would trigger this bug.</p>"},{"location":"errors/convert-block-matching/#fix","title":"Fix","text":"<p>Changed the convert pass to match blocks by <code>contentTypeKey</code> (element type GUID) instead of <code>identifyBy</code> text search. This is the same stable matching strategy already used by the apply pass.</p> <p><code>contentTypeKey</code> is the GUID of the element type (e.g. <code>featureRichTextEditorSights</code>), which is the same in the blueprint, the destination config, and any created document. It does not depend on the content of any property.</p>"},{"location":"errors/convert-block-matching/#files-changed","title":"Files changed","text":"<ul> <li><code>src/UpDoc/wwwroot/App_Plugins/UpDoc/src/up-doc-action.ts</code> \u2014 entity action bridge (tree context menu)</li> <li><code>src/UpDoc/wwwroot/App_Plugins/UpDoc/src/up-doc-collection-action.element.ts</code> \u2014 collection action bridge (primary code path)</li> </ul>"},{"location":"errors/convert-block-matching/#before","title":"Before","text":"<pre><code>const matched = destBlock.identifyBy\n    ? (() =&gt; {\n        const searchVal = block.values?.find((v) =&gt; v.alias === destBlock.identifyBy!.property);\n        return searchVal &amp;&amp;\n            typeof searchVal.value === 'string' &amp;&amp;\n            searchVal.value.toLowerCase().includes(destBlock.identifyBy!.value.toLowerCase());\n    })()\n    : block.key === destBlock.key;\n</code></pre>"},{"location":"errors/convert-block-matching/#after","title":"After","text":"<pre><code>const matched = destBlock.contentTypeKey\n    ? block.contentTypeKey === destBlock.contentTypeKey\n    : block.key === destBlock.key;\n</code></pre>"},{"location":"errors/convert-block-matching/#lesson-learned","title":"Lesson learned","text":"<p>The apply pass and convert pass must use the same matching strategy. When values are modified between passes, any matching strategy that depends on property values will be unreliable. Use stable identifiers (<code>contentTypeKey</code>) that don't change based on content.</p> <p>This reinforces the existing project rule: match blocks by <code>contentTypeKey</code>, NOT instance <code>key</code> or property values.</p>"},{"location":"frontend/","title":"Frontend (TypeScript)","text":"<p>The UpDoc backoffice extension is built with Lit web components and TypeScript, following Umbraco's extension patterns.</p> <p>All source files are in <code>src/UpDoc/wwwroot/App_Plugins/UpDoc/src/</code>.</p> File Description index.ts Entry point that registers all extension manifests with Umbraco manifest.ts Extension manifest definitions \u2014 entity actions, modals, conditions, settings, and collection actions up-doc-action.ts Entity action that handles \"Create Document from Source\" from the content tree up-doc-collection-action.element.ts Collection toolbar button for \"Create from Source\" in list views up-doc-has-workflows.condition.ts Condition that hides the entity action when no workflows are configured up-doc-modal.element.ts Source sidebar modal \u2014 source type selection, media picker, extraction preview up-doc-modal.token.ts Modal token defining the data/value contract for the source sidebar blueprint-picker-modal.element.ts Blueprint picker dialog \u2014 document type and blueprint selection blueprint-picker-modal.token.ts Modal token for the blueprint picker workflow.types.ts TypeScript type definitions for workflow configs workflow.service.ts API service for fetching workflows, configs, and extraction results up-doc-workflows-view.element.ts Settings workspace view listing configured workflows transforms.ts Markdown-to-HTML conversion and RTE value building"},{"location":"source-files/","title":"index.ts","text":"<p>The entry point for the plugin bundle. This file is loaded by Umbraco when the backoffice starts.</p>"},{"location":"source-files/#what-it-does","title":"What it does","text":"<p>Exports the <code>manifests</code> array which registers all the extension components (entity actions, modals, etc.) with Umbraco's extension registry.</p>"},{"location":"source-files/#key-points","title":"Key points","text":"<ul> <li>Must export <code>manifests</code> - Umbraco's bundle loader looks for this export</li> <li>Does NOT use <code>onInit</code> function - bundles automatically register exported manifests</li> <li>Keep this file simple - just re-export from manifest.ts</li> </ul>"},{"location":"source-files/#code","title":"Code","text":"<pre><code>export { manifests } from './manifest.js';\n</code></pre>"},{"location":"source-files/#common-mistake","title":"Common mistake","text":"<p>We initially tried using an <code>onInit</code> function pattern:</p> <pre><code>// WRONG - this doesn't work for bundles\nexport const onInit = (host, extensionRegistry) =&gt; {\n  extensionRegistry.registerMany(manifests);\n};\n</code></pre> <p>Bundles don't call <code>onInit</code> - they just look for the <code>manifests</code> export. Use <code>backofficeEntryPoint</code> type instead if you need <code>onInit</code> behavior.</p>"},{"location":"source-files/blueprint-picker-modal-element/","title":"blueprint-picker-modal.element.ts","text":"<p>The UI component for the blueprint picker dialog.</p>"},{"location":"source-files/blueprint-picker-modal-element/#what-it-does","title":"What it does","text":"<p>Renders a centered dialog that implements a two-step selection flow mirroring Umbraco's native Create dialog:</p> <ol> <li>Document Type view \u2014 Lists allowed child document types that have blueprints</li> <li>Blueprint view \u2014 Lists blueprints for the selected document type</li> </ol> <p>If no document types have blueprints, shows an informational message telling the user to create a blueprint first.</p> <p>This dialog opens as an interstitial step before the source sidebar modal.</p>"},{"location":"source-files/blueprint-picker-modal-element/#class-structure","title":"Class structure","text":"<pre><code>@customElement('blueprint-picker-modal')\nexport class BlueprintPickerModalElement extends UmbModalBaseElement&lt;\n    BlueprintPickerModalData,\n    BlueprintPickerModalValue\n&gt; {\n    @state() _selectedDocType: DocumentTypeOption | null = null;\n\n    #handleDocTypeSelect(docType) { ... }\n    #handleBlueprintSelect(blueprintUnique) { ... }\n    #handleBack() { ... }\n    #handleClose() { ... }\n    #renderNoDocumentTypes() { ... }\n    #renderDocumentTypeList() { ... }\n    #renderBlueprintList() { ... }\n    render() { ... }\n}\n</code></pre>"},{"location":"source-files/blueprint-picker-modal-element/#two-step-view-switching","title":"Two-step view switching","text":"<p>The dialog uses a single <code>@state()</code> property (<code>_selectedDocType</code>) to determine which view to render:</p> <ul> <li><code>null</code> \u2192 show document type list</li> <li>set \u2192 show blueprint list for that doc type</li> </ul> <p>View switching uses Lit's <code>when()</code> directive, matching the pattern used by Umbraco's own <code>document-create-options-modal.element.js</code>:</p> <pre><code>${when(\n    !hasDocumentTypes,\n    () =&gt; this.#renderNoDocumentTypes(),\n    () =&gt; when(\n        showBlueprints,\n        () =&gt; this.#renderBlueprintList(),\n        () =&gt; this.#renderDocumentTypeList(),\n    ),\n)}\n</code></pre> <p>The headline updates dynamically based on the current view: - Document type view: \"Choose a Document Type\" - Blueprint view: Uses Umbraco's <code>blueprints_selectBlueprint</code> localization term</p>"},{"location":"source-files/blueprint-picker-modal-element/#rendering-states","title":"Rendering states","text":""},{"location":"source-files/blueprint-picker-modal-element/#document-types-available","title":"Document types available","text":"<p>Each document type is rendered as a <code>uui-menu-item</code> with its icon from the document type definition:</p> <pre><code>&lt;uui-menu-item label=\"Web Page\"&gt;\n    &lt;umb-icon slot=\"icon\" name=\"icon-document\"&gt;&lt;/umb-icon&gt;\n&lt;/uui-menu-item&gt;\n</code></pre> <p>Only document types that have at least one blueprint appear in the list.</p>"},{"location":"source-files/blueprint-picker-modal-element/#blueprints-available","title":"Blueprints available","text":"<p>After selecting a document type, blueprints for that type are rendered:</p> <pre><code>&lt;uui-menu-item label=\"Tour Page Blueprint\"&gt;\n    &lt;umb-icon slot=\"icon\" name=\"icon-blueprint\"&gt;&lt;/umb-icon&gt;\n&lt;/uui-menu-item&gt;\n</code></pre> <p>A \"Back\" button appears in the actions area to return to the document type list.</p>"},{"location":"source-files/blueprint-picker-modal-element/#no-document-types-with-blueprints","title":"No document types with blueprints","text":"<p>Shows a warning icon and message: - Main message: \"To create a document from a source, you first need to create a Document Blueprint.\" - Hint: \"Use the Create Document Blueprint option from the document actions menu.\"</p> <p>The user can only close the dialog in this state; there is no submit action.</p>"},{"location":"source-files/blueprint-picker-modal-element/#key-patterns","title":"Key patterns","text":""},{"location":"source-files/blueprint-picker-modal-element/#modal-submission","title":"Modal submission","text":"<p>When a blueprint is selected, the value is set and the modal is submitted immediately (no separate confirmation button):</p> <pre><code>#handleBlueprintSelect(blueprintUnique: string) {\n    if (!this._selectedDocType) return;\n    this.value = {\n        blueprintUnique,\n        documentTypeUnique: this._selectedDocType.documentTypeUnique,\n    };\n    this._submitModal();\n}\n</code></pre>"},{"location":"source-files/blueprint-picker-modal-element/#back-navigation","title":"Back navigation","text":"<p>The Back button resets the selected document type, returning to the document type list:</p> <pre><code>#handleBack() {\n    this._selectedDocType = null;\n}\n</code></pre>"},{"location":"source-files/blueprint-picker-modal-element/#modal-cancellation","title":"Modal cancellation","text":"<p>Closing the dialog rejects the modal, which the entity action catches to abort the workflow:</p> <pre><code>#handleClose() {\n    this._rejectModal();\n}\n</code></pre>"},{"location":"source-files/blueprint-picker-modal-element/#list-rendering","title":"List rendering","text":"<p>Uses Lit's <code>repeat()</code> directive with unique keys for efficient DOM recycling:</p> <pre><code>${repeat(\n    documentTypes,\n    (dt) =&gt; dt.documentTypeUnique,\n    (dt) =&gt; html`&lt;uui-menu-item ...&gt;`,\n)}\n</code></pre>"},{"location":"source-files/blueprint-picker-modal-element/#styles","title":"Styles","text":"<ul> <li>Uses <code>UmbTextStyles</code> for Umbraco base styles</li> <li><code>.no-blueprints</code> - Centered column layout with warning icon, message, and hint text</li> </ul>"},{"location":"source-files/blueprint-picker-modal-element/#design-decisions","title":"Design decisions","text":"<ul> <li>Always shown, even with one document type or one blueprint \u2014 For consistency and discoverability. Users learn that document type and blueprint selection are part of the workflow.</li> <li>Dialog type, not sidebar \u2014 This is a quick selection step, not a workspace. Centered dialogs are appropriate for simple choices.</li> <li>No \"Blank\" option \u2014 Unlike Umbraco's native Create flow, there is no \"blank\" option because the Create from Source feature requires a blueprint to define the target field structure.</li> <li>Only doc types with blueprints \u2014 Document types that have no blueprints are filtered out since they cannot be used in the Create from Source workflow.</li> <li>Back button included \u2014 Unlike Umbraco's native Create dialog which has no back button, this dialog includes one for better UX since cancelling and restarting the workflow is more disruptive.</li> </ul>"},{"location":"source-files/blueprint-picker-modal-token/","title":"blueprint-picker-modal.token.ts","text":"<p>Defines the modal token, data interface, and value interface for the blueprint picker dialog.</p>"},{"location":"source-files/blueprint-picker-modal-token/#what-it-does","title":"What it does","text":"<p>Provides type-safe contracts for the blueprint picker dialog that opens as an interstitial step before the source sidebar modal. The dialog presents a two-step selection flow mirroring Umbraco's native Create dialog: first the user selects a document type, then a blueprint for that type.</p>"},{"location":"source-files/blueprint-picker-modal-token/#interfaces","title":"Interfaces","text":""},{"location":"source-files/blueprint-picker-modal-token/#blueprintoption","title":"BlueprintOption","text":"<p>Represents a single blueprint available for selection:</p> <pre><code>export interface BlueprintOption {\n    blueprintUnique: string;\n    blueprintName: string;\n}\n</code></pre>"},{"location":"source-files/blueprint-picker-modal-token/#documenttypeoption","title":"DocumentTypeOption","text":"<p>Represents a document type that has one or more blueprints, grouping the type's metadata with its available blueprints:</p> <pre><code>export interface DocumentTypeOption {\n    documentTypeUnique: string;\n    documentTypeName: string;\n    documentTypeIcon: string | null;\n    blueprints: BlueprintOption[];\n}\n</code></pre> <p>Only document types that have at least one blueprint are included. The <code>documentTypeIcon</code> is the icon alias from the document type definition (e.g. <code>icon-document</code>, <code>icon-home</code>), used to render the correct icon in the picker list.</p>"},{"location":"source-files/blueprint-picker-modal-token/#blueprintpickermodaldata","title":"BlueprintPickerModalData","text":"<p>Data passed into the modal when opening it:</p> <pre><code>export interface BlueprintPickerModalData {\n    documentTypes: DocumentTypeOption[];\n}\n</code></pre> <p>The <code>documentTypes</code> array contains allowed child document types that have blueprints. If no document types have blueprints, the array is empty and the dialog shows a \"create a blueprint first\" message.</p>"},{"location":"source-files/blueprint-picker-modal-token/#blueprintpickermodalvalue","title":"BlueprintPickerModalValue","text":"<p>Data returned when the user selects a blueprint:</p> <pre><code>export interface BlueprintPickerModalValue {\n    blueprintUnique: string;\n    documentTypeUnique: string;\n}\n</code></pre>"},{"location":"source-files/blueprint-picker-modal-token/#modal-token","title":"Modal token","text":"<pre><code>export const UMB_BLUEPRINT_PICKER_MODAL = new UmbModalToken&lt;BlueprintPickerModalData, BlueprintPickerModalValue&gt;(\n    'UpDoc.BlueprintPickerModal',\n    {\n        modal: {\n            type: 'dialog',\n            size: 'small',\n        },\n    },\n);\n</code></pre> <ul> <li><code>type: 'dialog'</code> - Centered dialog (not a sidebar), matching Umbraco's native Create flow pattern</li> <li><code>size: 'small'</code> - Compact dialog appropriate for a simple selection list</li> <li>The alias <code>UpDoc.BlueprintPickerModal</code> must match the manifest registration</li> </ul>"},{"location":"source-files/blueprint-picker-modal-token/#usage","title":"Usage","text":"<pre><code>import { UMB_BLUEPRINT_PICKER_MODAL } from './blueprint-picker-modal.token.js';\nimport { umbOpenModal } from '@umbraco-cms/backoffice/modal';\n\nconst result = await umbOpenModal(this, UMB_BLUEPRINT_PICKER_MODAL, {\n    data: { documentTypes: documentTypeOptions },\n});\n// result.blueprintUnique - selected blueprint ID\n// result.documentTypeUnique - selected document type ID\n</code></pre>"},{"location":"source-files/create-workflow-sidebar-element/","title":"create-workflow-sidebar.element.ts","text":"<p>Sidebar modal for creating a new UpDoc workflow. Part of a stepped flow: blueprint picker dialog (step 1) then this sidebar (step 2).</p>"},{"location":"source-files/create-workflow-sidebar-element/#what-it-does","title":"What it does","text":"<p>Provides a sidebar with two tabs for configuring a new workflow:</p> <ol> <li>Source tab (default) \u2014 Workflow name, source format dropdown, conditional sample document picker, PDF page selection</li> <li>Destination tab \u2014 Read-only display of the selected document type and blueprint</li> </ol>"},{"location":"source-files/create-workflow-sidebar-element/#how-it-works","title":"How it works","text":"<ol> <li>Receives document type and blueprint details as modal data (passed from the blueprint picker dialog)</li> <li>User selects a source format from the dropdown (PDF, Markdown, Web Page, Word Document)</li> <li>Workflow name auto-generates as <code>{kebab-case-blueprint-name}-{sourceType}</code> (user can override)</li> <li>A format-specific sample document box appears:</li> <li>PDF \u2014 <code>up-doc-pdf-picker</code> with PDF.js thumbnail preview. After selection, runs <code>extractRich()</code> to get page count and element count. Extraction stats (filename, pages, elements) shown below the thumbnail.</li> <li>Markdown \u2014 <code>umb-input-media</code> picker for a sample file</li> <li>Web \u2014 URL text input</li> <li>Word Document \u2014 <code>umb-input-media</code> picker</li> <li>For PDF: a Pages box appears after extraction with page count summary and full-width \"Choose Pages\" button that opens the page picker modal</li> <li>On submit, returns <code>CreateWorkflowSidebarValue</code> with name, sourceType, mediaUnique, sourceUrl, documentTypeAlias, blueprintId, blueprintName, and selectedPages</li> </ol>"},{"location":"source-files/create-workflow-sidebar-element/#source-tab-layout-separate-boxes","title":"Source tab layout (separate boxes)","text":"<p>Each section is its own <code>uui-box</code>:</p> Box Headline Content Workflow Name Workflow Name <code>uui-input</code> with auto-generated kebab-case name Format Format <code>uui-select</code> dropdown (PDF/Markdown/Web/Word) Sample Document Sample Document / Sample File / Sample URL Format-specific picker + extraction stats for PDF Pages Pages Page count label + full-width \"Choose Pages\" button (PDF only, after extraction)"},{"location":"source-files/create-workflow-sidebar-element/#pdf-extraction-stats","title":"PDF extraction stats","text":"<p>After selecting a PDF, <code>extractRich()</code> runs automatically. On success, a stats panel appears below the thumbnail:</p> <ul> <li>Filename (bold, with <code>word-break: break-all</code> to show full names that <code>uui-card-media</code> would truncate)</li> <li>Page count with <code>icon-thumbnails-small</code> icon</li> <li>Element count with <code>icon-list</code> icon</li> </ul>"},{"location":"source-files/create-workflow-sidebar-element/#key-behaviours","title":"Key behaviours","text":"<ul> <li>Workflow name auto-generation uses <code>toKebabCase()</code> on the blueprint name plus the source type suffix</li> <li>Once the user manually edits the name, auto-generation stops (tracked by <code>_nameManuallyEdited</code> flag)</li> <li>Changing source type clears the media selection and URL (prevents stale references)</li> <li>Create button requires both name and source type; media/URL selection is optional</li> <li>Page picker opens as a nested sidebar modal via <code>UMB_PAGE_PICKER_MODAL</code></li> <li>Selected pages stored as <code>number[] | null</code> (null = all pages)</li> </ul>"},{"location":"source-files/create-workflow-sidebar-element/#tabs","title":"Tabs","text":"<p>Uses <code>uui-tab-group</code> in the <code>navigation</code> slot of <code>umb-body-layout</code>:</p> <ul> <li>Source \u2014 <code>icon-page-add</code> icon</li> <li>Destination \u2014 <code>icon-document</code> icon</li> </ul> <p>Text content must be placed inside the <code>&lt;uui-tab&gt;</code> element (not just the <code>label</code> attribute) for visible rendering inside <code>umb-body-layout</code>.</p>"},{"location":"source-files/create-workflow-sidebar-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 registered as a <code>modal</code> with alias <code>UpDoc.CreateWorkflowSidebar</code></li> </ul>"},{"location":"source-files/create-workflow-sidebar-element/#used-by","title":"Used by","text":"<ul> <li>Opened from <code>up-doc-workflows-view.element.ts</code> as step 2 of the \"Create Workflow\" flow (after the blueprint picker dialog)</li> </ul>"},{"location":"source-files/create-workflow-sidebar-token/","title":"create-workflow-sidebar.token.ts","text":"<p>Modal token definition for the Create Workflow sidebar.</p>"},{"location":"source-files/create-workflow-sidebar-token/#what-it-does","title":"What it does","text":"<p>Defines the data and return value types for the Create Workflow sidebar modal, and exports the modal token used to open it.</p>"},{"location":"source-files/create-workflow-sidebar-token/#interfaces","title":"Interfaces","text":""},{"location":"source-files/create-workflow-sidebar-token/#createworkflowsidebardata","title":"CreateWorkflowSidebarData","text":"<pre><code>interface CreateWorkflowSidebarData {\n    documentTypeUnique: string;  // Document type GUID\n    documentTypeName: string;    // Display name\n    documentTypeAlias: string;   // Umbraco alias (needed for backend)\n    blueprintUnique: string;     // Blueprint GUID\n    blueprintName: string;       // Blueprint display name\n}\n</code></pre> <p>Populated by the blueprint picker dialog (step 1) before opening the sidebar (step 2).</p>"},{"location":"source-files/create-workflow-sidebar-token/#createworkflowsidebarvalue","title":"CreateWorkflowSidebarValue","text":"<pre><code>interface CreateWorkflowSidebarValue {\n    name: string;              // Workflow folder name (kebab-case)\n    sourceType: string;        // 'pdf' | 'markdown' | 'web' | 'doc'\n    mediaUnique: string | null; // Selected sample media GUID (for PDF/Markdown/Word)\n    sourceUrl: string | null;   // Sample URL (for Web source type)\n    documentTypeAlias: string;  // Passed through from data\n    blueprintId: string;        // Passed through from data\n    blueprintName: string;      // Passed through from data\n}\n</code></pre>"},{"location":"source-files/create-workflow-sidebar-token/#token","title":"Token","text":"<pre><code>export const UMB_CREATE_WORKFLOW_SIDEBAR = new UmbModalToken&lt;CreateWorkflowSidebarData, CreateWorkflowSidebarValue&gt;(\n    'UpDoc.CreateWorkflowSidebar',\n    { modal: { type: 'sidebar', size: 'small' } },\n);\n</code></pre>"},{"location":"source-files/create-workflow-sidebar-token/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-workflows-view.element.ts</code> \u2014 opens the modal (step 2 of Create Workflow flow) and handles the return value</li> <li><code>create-workflow-sidebar.element.ts</code> \u2014 implements the modal UI</li> </ul>"},{"location":"source-files/destination-picker-modal-element/","title":"destination-picker-modal.element.ts","text":"<p>Sidebar modal for picking destination fields when creating a source-to-destination mapping.</p>"},{"location":"source-files/destination-picker-modal-element/#what-it-does","title":"What it does","text":"<p>Presents the destination structure (fields and block grid properties) from <code>destination.json</code> in a tabbed interface. The user selects one or more target fields, then confirms to create the mapping.</p>"},{"location":"source-files/destination-picker-modal-element/#how-it-works","title":"How it works","text":""},{"location":"source-files/destination-picker-modal-element/#tab-structure","title":"Tab structure","text":"<p>Tabs are generated dynamically from the destination config:</p> <ul> <li>One tab per unique <code>tab</code> value in <code>destination.fields</code> (e.g., \"Page Properties\")</li> <li>A \"Page Content\" tab if <code>destination.blockGrids</code> has entries</li> <li>First tab is auto-selected on open</li> </ul>"},{"location":"source-files/destination-picker-modal-element/#field-rendering","title":"Field rendering","text":"<p>Each field/property renders as a clickable row with:</p> <ul> <li>Checkbox with accessibility label (<code>label=\"Select ${field.label}\"</code>)</li> <li>Field label (bold)</li> <li>Type badge showing the property editor type</li> </ul> <p>Clicking the row or the checkbox toggles selection. Selected items get a highlighted background.</p>"},{"location":"source-files/destination-picker-modal-element/#block-grid-rendering","title":"Block grid rendering","text":"<p>Block grids show a header with the grid label, then nested blocks. Each block shows:</p> <ul> <li>Block icon and label</li> <li>Indented properties with checkboxes (same selection pattern as fields)</li> </ul>"},{"location":"source-files/destination-picker-modal-element/#block-property-disambiguation","title":"Block property disambiguation","text":"<p>Multiple block instances can share the same property alias (e.g., three blocks all have <code>richTextContent</code>). The modal uses compound keys internally (<code>blockKey:alias</code>) so that selecting a property in one block does not affect the same property in other blocks. Each block property is independently selectable.</p>"},{"location":"source-files/destination-picker-modal-element/#confirm-action","title":"Confirm action","text":"<p>The confirm button shows \"Map to N field(s)\" with a count. It's disabled when nothing is selected. On confirm, returns <code>{ selectedTargets: Array&lt;{ target, blockKey? }&gt; }</code> \u2014 structured objects with the property alias and optional block instance key for disambiguation.</p>"},{"location":"source-files/destination-picker-modal-element/#data-flow","title":"Data flow","text":"<pre><code>Source tab selects elements \u2192 opens this modal with destination config\n                           \u2192 user picks target fields (block context preserved)\n                           \u2192 modal returns structured targets with blockKey\n                           \u2192 Source tab creates mapping entries in map.json\n</code></pre>"},{"location":"source-files/destination-picker-modal-element/#imports","title":"Imports","text":"<pre><code>import type { DestinationConfig, DestinationField, DestinationBlockGrid } from './workflow.types.js';\nimport type { DestinationPickerModalData, DestinationPickerModalValue } from './destination-picker-modal.token.js';\nimport { UmbModalBaseElement } from '@umbraco-cms/backoffice/modal';\n</code></pre>"},{"location":"source-files/destination-picker-modal-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 modal registration with alias <code>UpDoc.DestinationPickerModal</code></li> </ul>"},{"location":"source-files/destination-picker-modal-element/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-workflow-source-view.element.ts</code> \u2014 opened via <code>UMB_MODAL_MANAGER_CONTEXT</code> when \"Map to...\" is clicked</li> </ul>"},{"location":"source-files/destination-picker-modal-token/","title":"destination-picker-modal.token.ts","text":"<p>Modal token for the destination field picker sidebar.</p>"},{"location":"source-files/destination-picker-modal-token/#what-it-does","title":"What it does","text":"<p>Defines the <code>UmbModalToken</code> that configures the destination picker modal \u2014 a sidebar modal used when mapping source elements to destination fields.</p>"},{"location":"source-files/destination-picker-modal-token/#token","title":"Token","text":"<pre><code>export const UMB_DESTINATION_PICKER_MODAL = new UmbModalToken&lt;\n    DestinationPickerModalData,\n    DestinationPickerModalValue\n&gt;('UpDoc.DestinationPickerModal', {\n    modal: {\n        type: 'sidebar',\n        size: 'small',\n    },\n});\n</code></pre>"},{"location":"source-files/destination-picker-modal-token/#data-interface-input","title":"Data interface (input)","text":"<pre><code>export interface DestinationPickerModalData {\n    destination: DestinationConfig;\n}\n</code></pre> <ul> <li><code>destination</code> \u2014 the full destination config from the workflow, containing fields and block grids</li> </ul>"},{"location":"source-files/destination-picker-modal-token/#value-interface-output","title":"Value interface (output)","text":"<pre><code>export interface DestinationPickerModalValue {\n    selectedTargets: Array&lt;{ target: string; blockKey?: string }&gt;;\n}\n</code></pre> <ul> <li><code>selectedTargets</code> \u2014 array of structured target objects selected by the user<ul> <li><code>target</code> \u2014 the property alias (e.g., <code>\"pageTitle\"</code> or <code>\"richTextContent\"</code>)</li> <li><code>blockKey</code> \u2014 optional block instance key from <code>destination.json</code>, present when the target is a block property. Used to disambiguate when multiple blocks share the same property alias.</li> </ul> </li> </ul>"},{"location":"source-files/destination-picker-modal-token/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-workflow-source-view.element.ts</code> \u2014 imports the token to open the modal</li> <li><code>destination-picker-modal.element.ts</code> \u2014 implements the modal UI</li> <li><code>manifest.ts</code> \u2014 registers the modal with alias <code>UpDoc.DestinationPickerModal</code></li> </ul>"},{"location":"source-files/destination-utils/","title":"destination-utils.ts","text":"<p>Shared utility functions for resolving destination tab structure. Used by the Destination view, Map view, and Create from Source modal to ensure consistent grouping and ordering of destination fields.</p>"},{"location":"source-files/destination-utils/#what-it-does","title":"What it does","text":"<p>Provides three pure functions (no Lit or Umbraco dependencies) that operate on <code>DestinationConfig</code> from <code>workflow.types.ts</code>:</p>"},{"location":"source-files/destination-utils/#getdestinationtabsdestination","title":"<code>getDestinationTabs(destination)</code>","text":"<p>Extracts the tab structure from a destination config. Returns tabs in document order with kebab-case IDs, appending \"Page Content\" if blockGrids exist but no explicit \"Page Content\" tab is present.</p>"},{"location":"source-files/destination-utils/#resolvedestinationtabdest-destination","title":"<code>resolveDestinationTab(dest, destination)</code>","text":"<p>Maps a <code>MappingDestination</code> to its destination tab ID. Block properties (those with <code>blockKey</code>) always resolve to <code>'page-content'</code>. Top-level fields resolve to their field's tab. Returns <code>null</code> for orphaned mappings.</p>"},{"location":"source-files/destination-utils/#resolveblocklabelblockkey-destination","title":"<code>resolveBlockLabel(blockKey, destination)</code>","text":"<p>Finds a block's display label given its key. Used for sub-grouping block properties within the Page Content tab.</p>"},{"location":"source-files/destination-utils/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-workflow-destination-view.element.ts</code> -- uses <code>getDestinationTabs()</code> for inner tab rendering</li> <li><code>up-doc-modal.element.ts</code> -- uses all three functions for Content tab grouped preview</li> <li><code>up-doc-workflow-map-view.element.ts</code> -- uses all three functions for grouped mapping sections</li> </ul>"},{"location":"source-files/destination-utils/#imports","title":"Imports","text":"<pre><code>import type { DestinationConfig, MappingDestination } from './workflow.types.js';\n</code></pre>"},{"location":"source-files/manifest/","title":"manifest.ts","text":"<p>Defines all extension manifests that get registered with Umbraco's extension registry.</p>"},{"location":"source-files/manifest/#what-it-does","title":"What it does","text":"<p>Exports an array of <code>UmbExtensionManifest</code> objects that tell Umbraco about our custom extensions:</p> <ol> <li>An entity action that adds \"Create Document from Source\" to document context menus</li> <li>A condition that controls when the entity action is visible</li> <li>Modals for the source selection sidebar, blueprint picker, workflow creation sidebar, and workflow detail</li> <li>A settings sidebar with tree and workspace for the UpDoc dashboard</li> </ol>"},{"location":"source-files/manifest/#entity-action","title":"Entity Action","text":"<pre><code>{\n    type: 'entityAction',\n    kind: 'default',\n    alias: 'UpDoc.EntityAction',\n    name: 'UpDoc Entity Action',\n    weight: 1100,\n    api: () =&gt; import('./up-doc-action.js'),\n    forEntityTypes: ['document'],\n    meta: {\n        icon: 'icon-document',\n        label: 'Create Document from Source',\n    },\n    conditions: [\n        {\n            alias: 'Umb.Condition.EntityIsNotTrashed',\n        },\n        {\n            alias: 'UpDoc.Condition.HasAvailableWorkflows',\n        },\n    ],\n}\n</code></pre> <p>Key properties: - <code>type: 'entityAction'</code> - Adds an action to entity context menus - <code>forEntityTypes: ['document']</code> - Only shows on document nodes - <code>weight: 1100</code> - Controls menu item position (higher = higher in list) - <code>api</code> - Lazy loads the action class when needed - <code>conditions</code> - Two conditions must both pass (AND logic):     - <code>Umb.Condition.EntityIsNotTrashed</code> - hides the action for documents in the recycle bin     - <code>UpDoc.Condition.HasAvailableWorkflows</code> - per-node check: hides the action unless the node's allowed child types have blueprints with complete workflows</p>"},{"location":"source-files/manifest/#condition-hasavailableworkflows","title":"Condition: HasAvailableWorkflows","text":"<pre><code>{\n    type: 'condition',\n    alias: 'UpDoc.Condition.HasAvailableWorkflows',\n    name: 'Has Available Workflows',\n    api: () =&gt; import('./up-doc-has-workflows.condition.js'),\n}\n</code></pre> <p>Registers the custom condition class. This is a per-node check -- it uses <code>UMB_ENTITY_CONTEXT</code> to get the current node, looks up its allowed child types, and checks whether any of them have blueprints with complete workflows. The entity action only appears on nodes where \"Create Document from Source\" would actually work.</p> <p>See up-doc-has-workflows.condition.ts for implementation details.</p>"},{"location":"source-files/manifest/#modals","title":"Modals","text":"<pre><code>{\n    type: 'modal',\n    alias: 'UpDoc.Modal',\n    name: 'UpDoc Modal',\n    element: () =&gt; import('./up-doc-modal.element.js'),\n}\n</code></pre> <pre><code>{\n    type: 'modal',\n    alias: 'UpDoc.BlueprintPickerModal',\n    name: 'Blueprint Picker Modal',\n    element: () =&gt; import('./blueprint-picker-modal.element.js'),\n}\n</code></pre> <pre><code>{\n    type: 'modal',\n    alias: 'UpDoc.CreateWorkflowSidebar',\n    name: 'Create Workflow Sidebar',\n    element: () =&gt; import('./create-workflow-sidebar.element.js'),\n}\n</code></pre> <p>Key properties: - <code>type: 'modal'</code> - Registers a modal dialog - <code>alias</code> - Must match the token alias in the corresponding <code>.token.ts</code> file - <code>element</code> - Lazy loads the Lit component</p>"},{"location":"source-files/manifest/#collection-action-create-from-source","title":"Collection Action: Create from Source","text":"<pre><code>{\n    type: 'collectionAction',\n    kind: 'button',\n    alias: 'UpDoc.CollectionAction',\n    name: 'UpDoc Collection Action',\n    element: () =&gt; import('./up-doc-collection-action.element.js'),\n    weight: 50,\n    meta: {\n        label: 'Create from Source',\n    },\n    conditions: [\n        {\n            alias: 'Umb.Condition.CollectionAlias',\n            match: 'Umb.Collection.Document',\n        },\n    ],\n}\n</code></pre> <p>Key properties: - <code>type: 'collectionAction'</code> \u2014 adds a button to the collection toolbar - <code>kind: 'button'</code> \u2014 renders as a toolbar button - <code>element</code> \u2014 uses a custom Lit element (not <code>api</code>) for conditional rendering and workspace context access - <code>weight: 50</code> \u2014 appears after Umbraco's own create button (weight 100) - <code>Umb.Condition.CollectionAlias</code> \u2014 only appears on document collections</p> <p>The element handles its own visibility internally by checking for active workflows. See up-doc-collection-action.element.ts for details.</p>"},{"location":"source-files/manifest/#workflow-workspace-individual-workflow-pages","title":"Workflow Workspace \u2014 Individual Workflow Pages","text":"<p>These manifests register a routable workspace for viewing individual workflows as full pages:</p> <pre><code>{\n    type: 'workspace',\n    kind: 'routable',\n    alias: 'UpDoc.WorkflowWorkspace',\n    name: 'UpDoc Workflow Workspace',\n    api: () =&gt; import('./up-doc-workflow-workspace.context.js'),\n    meta: {\n        entityType: 'updoc-workflow',\n    },\n}\n</code></pre> <p>Key properties: - <code>kind: 'routable'</code> \u2014 supports URL routing with <code>edit/:unique</code> path segments - <code>entityType: 'updoc-workflow'</code> \u2014 connects the workspace to workflow navigation - <code>api</code> \u2014 lazy loads the workspace context class</p>"},{"location":"source-files/manifest/#workflow-workspace-views","title":"Workflow Workspace Views","text":"<p>Three workspace views provide tabs within the workflow workspace:</p> Alias Label Weight Element Description <code>UpDoc.WorkflowWorkspaceView.Destination</code> Destination 300 <code>up-doc-workflow-destination-view.element.js</code> Blueprint fields and block grids <code>UpDoc.WorkflowWorkspaceView.Source</code> Source 200 <code>up-doc-workflow-source-view.element.js</code> Sample extraction display + source-to-destination mapping <code>UpDoc.WorkflowWorkspaceView.Map</code> Map 100 <code>up-doc-workflow-map-view.element.js</code> All mappings overview with delete <p>All are conditioned on <code>Umb.Condition.WorkspaceAlias</code> matching <code>UpDoc.WorkflowWorkspace</code>.</p>"},{"location":"source-files/manifest/#destination-picker-modal","title":"Destination Picker Modal","text":"<pre><code>{\n    type: 'modal',\n    alias: 'UpDoc.DestinationPickerModal',\n    name: 'Destination Picker Modal',\n    element: () =&gt; import('./destination-picker-modal.element.js'),\n}\n</code></pre> <p>A sidebar modal for selecting destination fields when creating mappings from the Source tab.</p>"},{"location":"source-files/manifest/#area-editor-modal","title":"Area Editor Modal","text":"<pre><code>{\n    type: 'modal',\n    alias: 'UpDoc.AreaEditorModal',\n    name: 'Area Editor Modal',\n    element: () =&gt; import('./pdf-area-editor-modal.element.js'),\n}\n</code></pre> <p>Full-screen modal for drawing and naming rectangular areas on a PDF. Uses PDF.js for rendering and canvas overlay for area drawing. Areas define extraction regions \u2014 only content within defined areas is extracted.</p>"},{"location":"source-files/manifest/#settings-sidebar-tree-and-workspace","title":"Settings Sidebar, Tree, and Workspace","text":"<p>The remaining manifests register the UpDoc dashboard in the Settings section.</p>"},{"location":"source-files/manifest/#sidebar-integration-usync-aware","title":"Sidebar integration (uSync-aware)","text":"<p>UpDoc appears under the \"Synchronisation\" group in the Settings sidebar. When uSync is installed, UpDoc registers as a <code>menuItem</code> inside uSync's existing <code>usync.menu</code>. When uSync is NOT installed, a fallback <code>sectionSidebarApp</code> creates its own \"Synchronisation\" group.</p> <ul> <li><code>condition</code> (<code>UpDoc.Condition.UsyncNotInstalled</code>) \u2014 checks if <code>usync.menu</code> is NOT in the extension registry. Permits when uSync is absent.</li> <li><code>menuItem</code> \u2014 targets both <code>usync.menu</code> and <code>UpDoc.Menu</code> (whichever is rendered). Uses <code>hideTreeRoot: true</code> for flat display.</li> <li><code>sectionSidebarApp</code> (fallback) \u2014 creates \"Synchronisation\" group, conditioned on uSync NOT being installed.</li> <li><code>menu</code> (<code>UpDoc.Menu</code>) \u2014 fallback menu container, only rendered by the fallback sectionSidebarApp.</li> </ul>"},{"location":"source-files/manifest/#other-settings-manifests","title":"Other Settings manifests","text":"<ul> <li><code>repository</code> + <code>tree</code> + <code>treeItem</code> - Data source for workflow tree items</li> <li><code>workspace</code> (<code>kind: 'routable'</code>) - Right panel with tabs for editing workflows</li> <li><code>workspaceView</code> (x3) - Tabs: Workflows, Configuration, About</li> </ul>"},{"location":"source-files/manifest/#important-notes","title":"Important notes","text":"<ul> <li>All imports use <code>.js</code> extension (TypeScript compiles to JS)</li> <li>Lazy loading (<code>() =&gt; import()</code>) improves initial load performance</li> <li>The <code>alias</code> values must be unique and match corresponding tokens</li> <li>Conditions use AND logic \u2014 all must pass for the extension to appear</li> </ul>"},{"location":"source-files/markdown-extraction-service/","title":"MarkdownExtractionService.cs","text":"<p>Service that extracts structured sections from Markdown files using strategy-based extraction.</p>"},{"location":"source-files/markdown-extraction-service/#what-it-does","title":"What it does","text":"<p>Reads a Markdown file from disk, splits it into lines, and applies extraction strategies defined in a <code>SourceConfig</code> to produce named sections. Returns the same <code>ExtractionResult</code> as the PDF extraction service, making source types interchangeable.</p>"},{"location":"source-files/markdown-extraction-service/#interface","title":"Interface","text":"<pre><code>public interface IMarkdownExtractionService\n{\n    ExtractionResult ExtractSectionsFromConfig(string filePath, SourceConfig sourceConfig);\n}\n</code></pre>"},{"location":"source-files/markdown-extraction-service/#extraction-strategies","title":"Extraction Strategies","text":"Strategy Implementation <code>firstHeading</code> Finds the first line matching <code>#{level}</code> prefix. Returns heading text without the <code>#</code> prefix. <code>firstParagraph</code> Finds the first non-empty, non-heading line after a heading. Returns the text. <code>betweenPatterns</code> Scans lines, starts capturing at <code>startPattern</code> regex, stops at any <code>stopPatterns</code> regex. Respects <code>includeStartLine</code>. <code>regex</code> Matches a regex pattern against each line. Returns the first match (supports capture groups)."},{"location":"source-files/markdown-extraction-service/#key-difference-from-pdf-extraction","title":"Key difference from PDF extraction","text":"<p>Markdown is already structured text \u2014 no PdfPig, no column detection, no font analysis needed. The service is simple line-based text parsing (~170 lines).</p>"},{"location":"source-files/markdown-extraction-service/#strategy-parameters","title":"Strategy Parameters","text":""},{"location":"source-files/markdown-extraction-service/#firstheading","title":"firstHeading","text":"<ul> <li><code>level</code> (int) \u2014 Heading level to match (1 = <code>#</code>, 2 = <code>##</code>, etc.). Default: 1.</li> </ul>"},{"location":"source-files/markdown-extraction-service/#betweenpatterns","title":"betweenPatterns","text":"<ul> <li><code>startPattern</code> (string) \u2014 Regex to match the start line</li> <li><code>stopPatterns</code> (string[]) \u2014 Regexes that stop capturing when matched</li> <li><code>includeStartLine</code> (bool) \u2014 Whether to include the matched start line. Default: true.</li> </ul>"},{"location":"source-files/markdown-extraction-service/#regex","title":"regex","text":"<ul> <li><code>pattern</code> (string) \u2014 Regex pattern to match</li> <li><code>flags</code> (string) \u2014 Regex flags (e.g. <code>\"i\"</code> for case-insensitive)</li> <li><code>captureGroup</code> (int) \u2014 Which capture group to return. Default: 0 (full match).</li> </ul>"},{"location":"source-files/markdown-extraction-service/#registration","title":"Registration","text":"<p>Registered as scoped via <code>UpDocComposer</code>:</p> <pre><code>builder.Services.AddScoped&lt;IMarkdownExtractionService, MarkdownExtractionService&gt;();\n</code></pre>"},{"location":"source-files/markdown-extraction-service/#dependencies","title":"Dependencies","text":"<ul> <li><code>ILogger&lt;MarkdownExtractionService&gt;</code> \u2014 for logging extraction progress and errors</li> </ul>"},{"location":"source-files/markdown-extraction-service/#namespace","title":"Namespace","text":"<pre><code>namespace UpDoc.Services;\n</code></pre>"},{"location":"source-files/page-picker-modal-element/","title":"page-picker-modal.element.ts","text":"<p>Sidebar modal that displays a grid of PDF page thumbnails for selecting which pages to include in extraction.</p>"},{"location":"source-files/page-picker-modal-element/#what-it-does","title":"What it does","text":"<p>Renders all pages of a PDF as thumbnail images in a 4-column grid, with Umbraco-native selectable checkboxes. Users can select/deselect individual pages or use Select All/Deselect All. Returns the selected page numbers on confirm.</p>"},{"location":"source-files/page-picker-modal-element/#how-it-works","title":"How it works","text":"<ol> <li>On <code>firstUpdated</code>, fetches an auth token for PDF thumbnail rendering</li> <li>Initialises selection: if <code>selectedPages</code> data is provided, uses that; otherwise selects all pages</li> <li>Renders a <code>uui-card-media</code> for each page with <code>selectable select-only</code> attributes (checkbox in top-left corner, matching Umbraco media library pattern)</li> <li>Each card contains an <code>up-doc-pdf-thumbnail</code> component that renders the actual PDF page via PDF.js</li> <li>On confirm: if all pages selected, returns <code>null</code> (meaning \"all\"); otherwise returns the sorted array of selected page numbers</li> </ol>"},{"location":"source-files/page-picker-modal-element/#ui-layout","title":"UI layout","text":"<ul> <li>Header toolbar: Selection count (\"X of Y pages selected\") + Select All/Deselect All toggle button</li> <li>Page grid: 4-column CSS Grid of <code>uui-card-media</code> cards, each 200px thumbnail width</li> <li>Actions: Cancel + Confirm button (disabled when no pages selected)</li> </ul>"},{"location":"source-files/page-picker-modal-element/#key-patterns","title":"Key patterns","text":"<ul> <li>Uses <code>@selected</code> and <code>@deselected</code> as separate event handlers on <code>uui-card-media</code> (not a single toggle event)</li> <li>Selection tracked as <code>Set&lt;number&gt;</code> with immutable updates (new Set on each change) for Lit reactivity</li> <li>Confirm button label changes dynamically: \"Include all pages\" vs \"Include X page(s)\"</li> </ul>"},{"location":"source-files/page-picker-modal-element/#custom-element","title":"Custom element","text":"<p><code>&lt;up-doc-page-picker-modal&gt;</code></p>"},{"location":"source-files/page-picker-modal-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 alias <code>UpDoc.PagePickerModal</code></li> </ul>"},{"location":"source-files/page-picker-modal-element/#used-by","title":"Used by","text":"<ul> <li>Opened via <code>UMB_PAGE_PICKER_MODAL</code> token from:<ul> <li><code>create-workflow-sidebar.element.ts</code> (workflow creation flow)</li> <li><code>up-doc-workflow-source-view.element.ts</code> (Source workspace tab)</li> </ul> </li> </ul>"},{"location":"source-files/page-picker-modal-token/","title":"page-picker-modal.token.ts","text":"<p>Modal token for the PDF page picker sidebar.</p>"},{"location":"source-files/page-picker-modal-token/#what-it-does","title":"What it does","text":"<p>Defines the data contract and default configuration for opening the page picker modal. Uses Umbraco's <code>UmbModalToken</code> pattern with typed data in/value out.</p>"},{"location":"source-files/page-picker-modal-token/#interfaces","title":"Interfaces","text":""},{"location":"source-files/page-picker-modal-token/#pagepickermodaldata","title":"<code>PagePickerModalData</code>","text":"<p>Data passed when opening the modal:</p> Property Type Description <code>mediaKey</code> <code>string</code> Umbraco media item GUID for the PDF <code>totalPages</code> <code>number</code> Total number of pages in the PDF <code>selectedPages</code> <code>number[] \\| null</code> Currently selected pages (1-based), or <code>null</code> for \"all\""},{"location":"source-files/page-picker-modal-token/#pagepickermodalvalue","title":"<code>PagePickerModalValue</code>","text":"<p>Value returned when the modal is submitted:</p> Property Type Description <code>selectedPages</code> <code>number[] \\| null</code> Selected page numbers (1-based), or <code>null</code> if all pages selected"},{"location":"source-files/page-picker-modal-token/#token","title":"Token","text":"<p><code>UMB_PAGE_PICKER_MODAL</code> \u2014 sidebar type, medium size.</p>"},{"location":"source-files/page-picker-modal-token/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 alias <code>UpDoc.PagePickerModal</code></li> </ul>"},{"location":"source-files/page-picker-modal-token/#used-by","title":"Used by","text":"<ul> <li><code>create-workflow-sidebar.element.ts</code> \u2014 page picker during workflow creation</li> <li><code>up-doc-workflow-source-view.element.ts</code> \u2014 page picker in the Source workspace tab</li> </ul>"},{"location":"source-files/pdf-extraction-controller/","title":"PdfExtractionController.cs","text":"<p>API controller that exposes PDF extraction functionality to the Umbraco backoffice.</p>"},{"location":"source-files/pdf-extraction-controller/#what-it-does","title":"What it does","text":"<p>Provides Management API endpoints for extracting content from PDFs:</p> <ol> <li>Accepts a media item's unique ID (GUID)</li> <li>Retrieves the media item from Umbraco</li> <li>Gets the file path from the media properties</li> <li>Calls the PDF extraction service</li> <li>Returns the extracted text and page count</li> </ol>"},{"location":"source-files/pdf-extraction-controller/#endpoint","title":"Endpoint","text":"<pre><code>GET /umbraco/management/api/v1/updoc/extract?mediaKey={guid}\n</code></pre>"},{"location":"source-files/pdf-extraction-controller/#parameters","title":"Parameters","text":"Parameter Type Description mediaKey Guid The unique identifier of the media item"},{"location":"source-files/pdf-extraction-controller/#response","title":"Response","text":"<pre><code>{\n    \"text\": \"Extracted text content...\",\n    \"pageCount\": 4\n}\n</code></pre>"},{"location":"source-files/pdf-extraction-controller/#error-responses","title":"Error responses","text":"<ul> <li><code>404 Not Found</code> - Media item not found or file not on disk</li> <li><code>400 Bad Request</code> - Media has no file or extraction failed</li> </ul>"},{"location":"source-files/pdf-extraction-controller/#section-extraction-endpoint","title":"Section extraction endpoint","text":"<pre><code>GET /umbraco/management/api/v1/updoc/page-section?mediaKey={guid}&amp;heading={text}\n</code></pre>"},{"location":"source-files/pdf-extraction-controller/#parameters_1","title":"Parameters","text":"Parameter Type Description mediaKey Guid The unique identifier of the media item heading string The heading text to search for (case-insensitive)"},{"location":"source-files/pdf-extraction-controller/#response_1","title":"Response","text":"<pre><code>{\n    \"heading\": \"Suggested Itinerary\",\n    \"content\": \"Day 1: Arrive in...\\nDay 2: Visit...\"\n}\n</code></pre>"},{"location":"source-files/pdf-extraction-controller/#error-responses_1","title":"Error responses","text":"<ul> <li><code>404 Not Found</code> - Media item not found or file not on disk</li> <li><code>400 Bad Request</code> - Heading not found or extraction failed</li> </ul>"},{"location":"source-files/pdf-extraction-controller/#markdown-extraction-endpoint","title":"Markdown extraction endpoint","text":"<pre><code>GET /umbraco/management/api/v1/updoc/extract-markdown?mediaKey={guid}\n</code></pre> <p>Extracts the full PDF content as Markdown with column detection for multi-column layouts.</p>"},{"location":"source-files/pdf-extraction-controller/#parameters_2","title":"Parameters","text":"Parameter Type Description mediaKey Guid The unique identifier of the media item"},{"location":"source-files/pdf-extraction-controller/#response_2","title":"Response","text":"<pre><code>{\n    \"title\": \"The Castles and Gardens of Kent\",\n    \"subtitle\": \"5 days from \u00a3889\",\n    \"markdown\": \"## Day 1\\n\\nArrive at...\\n\\n## Day 2\\n\\nVisit...\",\n    \"rawText\": \"Full raw text for debugging\"\n}\n</code></pre>"},{"location":"source-files/pdf-extraction-controller/#error-responses_2","title":"Error responses","text":"<ul> <li><code>404 Not Found</code> - Media item not found or file not on disk</li> <li><code>400 Bad Request</code> - Extraction failed</li> </ul>"},{"location":"source-files/pdf-extraction-controller/#map-file-endpoint","title":"Map file endpoint","text":"<pre><code>GET /umbraco/management/api/v1/updoc/maps/{blueprintId}\n</code></pre> <p>Returns the map file configuration for a given blueprint.</p>"},{"location":"source-files/pdf-extraction-controller/#parameters_3","title":"Parameters","text":"Parameter Type Description blueprintId Guid The blueprint unique identifier"},{"location":"source-files/pdf-extraction-controller/#response_3","title":"Response","text":"<p>Returns the full <code>MapFile</code> JSON object (name, documentTypeAlias, blueprintId, sourceTypes, propertyMappings).</p>"},{"location":"source-files/pdf-extraction-controller/#error-responses_3","title":"Error responses","text":"<ul> <li><code>404 Not Found</code> -- No map file found for the given blueprint</li> </ul>"},{"location":"source-files/pdf-extraction-controller/#section-extraction-endpoint-config-driven","title":"Section extraction endpoint (config-driven)","text":"<pre><code>GET /umbraco/management/api/v1/updoc/extract-sections?mediaKey={guid}&amp;blueprintId={guid}&amp;sourceType=pdf\n</code></pre> <p>Extracts structured sections from a source document using the extraction rules defined in the config for the given blueprint. Routes to the correct extraction service based on <code>sourceType</code>.</p>"},{"location":"source-files/pdf-extraction-controller/#parameters_4","title":"Parameters","text":"Parameter Type Description mediaKey Guid The unique identifier of the media item blueprintId Guid The blueprint unique identifier (used to look up the config) sourceType string The source type (<code>pdf</code> or <code>markdown</code>). Defaults to <code>pdf</code>."},{"location":"source-files/pdf-extraction-controller/#response_4","title":"Response","text":"<pre><code>{\n    \"sections\": {\n        \"title\": \"The Castles and Gardens of Kent\",\n        \"description\": \"5 days from \u00a3889\",\n        \"content\": \"## Day 1\\n\\nArrive at...\"\n    },\n    \"propertyMappings\": [\n        {\n            \"from\": { \"sectionType\": \"title\" },\n            \"to\": { \"property\": \"pageTitle\", \"alsoMapTo\": [\"pageTitleShort\"] }\n        }\n    ]\n}\n</code></pre> <p>The response includes both the extracted <code>sections</code> and the <code>propertyMappings</code> from the map file, so the frontend can apply each mapping to the document being created.</p>"},{"location":"source-files/pdf-extraction-controller/#error-responses_4","title":"Error responses","text":"<ul> <li><code>404 Not Found</code> -- No map file found for the blueprint, or media item not found</li> <li><code>400 Bad Request</code> -- Map file has no PDF extraction rules, or extraction failed</li> </ul>"},{"location":"source-files/pdf-extraction-controller/#private-helper-resolvemediafilepath","title":"Private helper: ResolveMediaFilePath","text":"<p>The new endpoints use a shared <code>ResolveMediaFilePath(Guid mediaKey)</code> private method that encapsulates the media lookup and file path resolution logic (handling both JSON and simple path formats for <code>umbracoFile</code>). Returns <code>null</code> if the media item is not found or the file does not exist on disk.</p>"},{"location":"source-files/pdf-extraction-controller/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/pdf-extraction-controller/#umbraco-17-management-api","title":"Umbraco 17 Management API","text":"<p>Uses the new Management API pattern introduced in Umbraco 14+: - <code>[ApiVersion(\"1.0\")]</code> - API versioning - <code>[MapToApi(\"updoc\")]</code> - API grouping for Swagger - <code>[Authorize(Policy = AuthorizationPolicies.BackOfficeAccess)]</code> - Backoffice auth - <code>[JsonOptionsName(\"UmbracoManagementApi\")]</code> - Umbraco JSON serialization</p>"},{"location":"source-files/pdf-extraction-controller/#media-file-path-resolution","title":"Media file path resolution","text":"<p>The <code>umbracoFile</code> property can be stored as: - Simple path: <code>/media/xxx/file.pdf</code> - JSON object: <code>{\"src\":\"/media/xxx/file.pdf\"}</code></p> <p>The controller handles both formats.</p>"},{"location":"source-files/pdf-extraction-controller/#dependencies","title":"Dependencies","text":"<ul> <li><code>IMediaService</code> -- Umbraco media service</li> <li><code>IPdfExtractionService</code> -- PDF extraction service</li> <li><code>IPdfPagePropertiesService</code> -- PDF page properties service</li> <li><code>IMarkdownExtractionService</code> -- Markdown extraction service</li> <li><code>IWorkflowService</code> -- Map file service for blueprint-to-config lookups</li> <li><code>IWebHostEnvironment</code> -- For resolving file paths</li> <li><code>ILogger&lt;PdfExtractionController&gt;</code> -- Logging</li> </ul>"},{"location":"source-files/pdf-extraction-controller/#frontend-usage","title":"Frontend usage","text":"<pre><code>const response = await fetch(\n    `/umbraco/management/api/v1/updoc/extract?mediaKey=${mediaUnique}`,\n    {\n        method: 'GET',\n        headers: {\n            'Authorization': `Bearer ${token}`,\n        },\n    }\n);\n</code></pre>"},{"location":"source-files/pdf-extraction-service/","title":"PdfExtractionService.cs","text":"<p>Service that extracts text content from PDF files using UglyToad.PdfPig.</p>"},{"location":"source-files/pdf-extraction-service/#what-it-does","title":"What it does","text":"<p>Provides PDF text extraction functionality:</p> <ol> <li>Opens PDF files from file path or stream</li> <li>Iterates through all pages</li> <li>Extracts text content from each page</li> <li>Returns combined text with page break markers</li> </ol>"},{"location":"source-files/pdf-extraction-service/#interface","title":"Interface","text":"<pre><code>public interface IPdfExtractionService\n{\n    PdfExtractionResult ExtractFromFile(string filePath);\n    PdfExtractionResult ExtractFromStream(Stream stream);\n}\n</code></pre>"},{"location":"source-files/pdf-extraction-service/#result-class","title":"Result class","text":"<pre><code>public class PdfExtractionResult\n{\n    public string RawText { get; set; }    // Combined text from all pages\n    public int PageCount { get; set; }      // Number of pages in PDF\n    public string? Error { get; set; }      // Error message if extraction failed\n}\n</code></pre>"},{"location":"source-files/pdf-extraction-service/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/pdf-extraction-service/#uglytoadpdfpig","title":"UglyToad.PdfPig","text":"<p>A .NET library for reading and extracting content from PDF files. It provides: - Cross-platform PDF parsing - Text extraction with positioning information - No external dependencies</p>"},{"location":"source-files/pdf-extraction-service/#error-handling","title":"Error handling","text":"<p>The service wraps all operations in try-catch to provide graceful error handling: - Returns error message in result instead of throwing - Allows caller to check <code>Error</code> property for failures</p>"},{"location":"source-files/pdf-extraction-service/#usage","title":"Usage","text":"<pre><code>public class MyController : ControllerBase\n{\n    private readonly IPdfExtractionService _pdfService;\n\n    public MyController(IPdfExtractionService pdfService)\n    {\n        _pdfService = pdfService;\n    }\n\n    public IActionResult ExtractPdf(string path)\n    {\n        var result = _pdfService.ExtractFromFile(path);\n\n        if (!string.IsNullOrEmpty(result.Error))\n            return BadRequest(result.Error);\n\n        return Ok(result.RawText);\n    }\n}\n</code></pre>"},{"location":"source-files/pdf-extraction-service/#registration","title":"Registration","text":"<p>Registered via <code>UpDocComposer</code> as a scoped service.</p>"},{"location":"source-files/pdf-page-properties-service/","title":"PdfPagePropertiesService.cs","text":"<p>Service that extracts page properties (title and description) from PDF files using font size and position analysis.</p>"},{"location":"source-files/pdf-page-properties-service/#what-it-does","title":"What it does","text":"<p>Analyzes the first page of a PDF to extract structured page properties:</p> <ol> <li>Opens PDF files from file path or stream</li> <li>Extracts text with position and font size data</li> <li>Groups words into lines by Y-coordinate</li> <li>Identifies title from largest font text at top of page</li> <li>Identifies description from next text block below title</li> </ol>"},{"location":"source-files/pdf-page-properties-service/#interface","title":"Interface","text":"<pre><code>public interface IPdfPagePropertiesService\n{\n    PdfPageProperties ExtractFromFile(string filePath);\n    PdfPageProperties ExtractFromStream(Stream stream);\n    PdfSectionResult ExtractSectionByHeading(string filePath, string headingText);\n    PdfMarkdownResult ExtractAsMarkdown(string filePath);\n    ExtractionResult ExtractSections(string filePath, PdfExtractionRules rules);\n}\n</code></pre>"},{"location":"source-files/pdf-page-properties-service/#result-classes","title":"Result classes","text":"<pre><code>public class PdfPageProperties\n{\n    public string Title { get; set; }        // Document title from largest font\n    public string Description { get; set; }  // Description from text below title\n    public string? Error { get; set; }       // Error message if extraction failed\n}\n\npublic class PdfSectionResult\n{\n    public string Heading { get; set; }      // The heading that was found\n    public string Content { get; set; }      // The content text extracted under the heading\n    public string? Error { get; set; }       // Error message if extraction failed\n}\n\npublic class PdfMarkdownResult\n{\n    public string Title { get; set; }        // Document title (H1)\n    public string Subtitle { get; set; }     // Document subtitle/description\n    public string Markdown { get; set; }     // Full content as Markdown\n    public string RawText { get; set; }      // Raw text for debugging\n    public string? Error { get; set; }       // Error message if extraction failed\n}\n\npublic class ExtractionResult\n{\n    public Dictionary&lt;string, string&gt; Sections { get; set; } = new();  // Keyed by type: title, description, content\n    public string RawText { get; set; } = string.Empty;                // Raw text with font sizes for debugging\n    public string? Error { get; set; }                                 // Error message if extraction failed\n}\n</code></pre>"},{"location":"source-files/pdf-page-properties-service/#property-mapping","title":"Property mapping","text":"<p>The extracted properties map to Umbraco page fields:</p> Extracted Property Umbraco Field(s) Title Page Title, Page Title Short, Node Name Description Page Description"},{"location":"source-files/pdf-page-properties-service/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/pdf-page-properties-service/#title-extraction","title":"Title extraction","text":"<ol> <li>Groups words into lines by Y-coordinate proximity</li> <li>Calculates average font size per line</li> <li>Identifies largest font size in document</li> <li>Collects consecutive lines from top with similar large font</li> <li>Combines into single title string</li> </ol>"},{"location":"source-files/pdf-page-properties-service/#description-extraction","title":"Description extraction","text":"<ol> <li>Finds first non-title line with content</li> <li>Collects lines with similar font size (15% tolerance)</li> <li>Limits to 3 lines maximum</li> <li>Combines into description string</li> </ol>"},{"location":"source-files/pdf-page-properties-service/#font-size-estimation","title":"Font size estimation","text":"<p>Uses word bounding box height as a proxy for font size since PDF Pig's <code>GetWords()</code> provides reliable bounding boxes.</p>"},{"location":"source-files/pdf-page-properties-service/#section-extraction-by-heading","title":"Section extraction by heading","text":"<p>The <code>ExtractSectionByHeading</code> method extracts content from a specific section:</p> <ol> <li>Searches all pages for a line containing the heading text (case-insensitive)</li> <li>Captures all text lines below the heading</li> <li>Stops when it encounters another heading (similar or larger font size)</li> <li>Returns the heading found and the content as plain text</li> </ol> <p>Special handling for itinerary extraction: When the heading matches a \"Day N\" pattern (e.g., \"Day 1\"), the extraction continues through all subsequent \"Day N\" headings (Day 2, Day 3, etc.) until a non-Day heading is encountered. This allows extracting complete itineraries that span multiple days.</p> <pre><code>// Example: Extract full itinerary by searching for \"Day 1\"\nvar result = _pagePropertiesService.ExtractSectionByHeading(path, \"Day 1\");\n// Result.Content will contain Day 1, Day 2, Day 3... until end of itinerary\n</code></pre>"},{"location":"source-files/pdf-page-properties-service/#markdown-extraction-with-column-detection","title":"Markdown extraction with column detection","text":"<p>The <code>ExtractAsMarkdown</code> method extracts the full PDF content as Markdown, with intelligent column detection for multi-column layouts common in travel brochures and itineraries:</p> <ol> <li>Analyzes word positions to detect column boundaries</li> <li>Merges multi-column content into a single flow</li> <li>Identifies headings by font size and applies Markdown heading levels</li> <li>Preserves paragraph structure with proper spacing</li> </ol> <pre><code>// Example: Extract full PDF as Markdown\nvar result = _pagePropertiesService.ExtractAsMarkdown(path);\n// Result.Title = \"The Castles and Gardens of Kent\"\n// Result.Subtitle = \"5 days from \u00a3889\"\n// Result.Markdown = \"## Day 1\\n\\nArrive at...\\n\\n## Day 2\\n\\nVisit...\"\n</code></pre>"},{"location":"source-files/pdf-page-properties-service/#map-driven-section-extraction-extractsections","title":"Map-driven section extraction (ExtractSections)","text":"<p>The <code>ExtractSections</code> method extracts structured sections from a PDF using rules defined in a <code>PdfExtractionRules</code> object (from a map file). Instead of hardcoded patterns, it uses configurable rules for title detection, description matching, content start/stop boundaries, and heading levels.</p> <pre><code>var result = _pagePropertiesService.ExtractSections(path, mapFile.SourceTypes.Pdf.Extraction);\n// result.Sections[\"title\"] = \"The Castles and Gardens of Kent\"\n// result.Sections[\"description\"] = \"5 days from \u00a3889\"\n// result.Sections[\"content\"] = \"## Day 1\\n\\nArrive at...\"\n</code></pre> <p>The extraction process:</p> <ol> <li>Extracts text lines from all pages (with optional column detection filtering)</li> <li>Identifies the title using the <code>TitleDetection.FontSizeThreshold</code> ratio against the largest font</li> <li>Matches the description using the <code>DescriptionPattern</code> regex</li> <li>Captures content between the <code>Content.StartPattern</code> regex and any <code>Content.StopPatterns</code></li> <li>Formats content headings using the configured <code>Content.HeadingLevel</code> (h1-h4)</li> <li>Returns a <code>Dictionary&lt;string, string&gt;</code> with keys: <code>title</code>, <code>description</code>, <code>content</code></li> </ol> <p>The private <code>ExtractSectionsFromDocument</code> method implements this logic, using <code>Regex</code> objects built from the map file rules instead of the hardcoded patterns used by <code>ExtractAsMarkdown</code>.</p>"},{"location":"source-files/pdf-page-properties-service/#usage","title":"Usage","text":"<pre><code>public class MyController : ControllerBase\n{\n    private readonly IPdfPagePropertiesService _pagePropertiesService;\n\n    public MyController(IPdfPagePropertiesService pagePropertiesService)\n    {\n        _pagePropertiesService = pagePropertiesService;\n    }\n\n    public IActionResult GetPageProperties(string path)\n    {\n        var result = _pagePropertiesService.ExtractFromFile(path);\n\n        if (!string.IsNullOrEmpty(result.Error))\n            return BadRequest(result.Error);\n\n        return Ok(new\n        {\n            title = result.Title,\n            description = result.Description\n        });\n    }\n}\n</code></pre>"},{"location":"source-files/pdf-page-properties-service/#rule-condition-matching-matchescondition","title":"Rule condition matching (MatchesCondition)","text":"<p>The static <code>MatchesCondition</code> method evaluates a single rule condition against a PDF element. Used by <code>ContentTransformService</code> during the Shape layer to determine which rule matches each element.</p> <pre><code>public static bool MatchesCondition(PdfElement element, RuleCondition condition, int index, int total)\n</code></pre> <p>Supported condition types:</p> Type Matching Logic <code>fontSizeEquals</code> <code>Math.Abs(element.FontSize - value) &lt;= 0.5</code> <code>fontSizeRange</code> <code>fontSize &gt;= min &amp;&amp; fontSize &lt;= max</code> (parses <code>{ min, max }</code> JSON object) <code>fontSizeAbove</code> <code>element.FontSize &gt; value</code> <code>fontSizeBelow</code> <code>element.FontSize &lt; value</code> <code>fontNameContains</code> Case-insensitive substring match on font name <code>colorEquals</code> Case-insensitive hex color comparison <code>positionFirst</code> <code>index == 0</code> <code>positionLast</code> <code>index == total - 1</code> <code>textBeginsWith</code> Case-insensitive <code>StartsWith</code> on element text <code>textEndsWith</code> Case-insensitive <code>EndsWith</code> on element text <code>textContains</code> Case-insensitive <code>Contains</code> on element text <code>textMatchesPattern</code> Regex match on element text <p>The <code>fontSizeRange</code> condition accepts a JSON object <code>{ \"min\": 9, \"max\": 13 }</code> and is preferred over <code>fontSizeEquals</code> for cross-PDF compatibility, since font metrics can vary by 1-3 points across PDFs from the same template.</p>"},{"location":"source-files/pdf-page-properties-service/#registration","title":"Registration","text":"<p>Registered via <code>UpDocComposer</code> as a scoped service.</p>"},{"location":"source-files/section-rules-editor-modal-element/","title":"section-rules-editor-modal.element.ts","text":"<p>Sidebar modal for defining rules that break a transform section into individually-mappable roles using the Outlook email rules pattern.</p>"},{"location":"source-files/section-rules-editor-modal-element/#what-it-does","title":"What it does","text":"<p>Allows the workflow author to define rules for a single section (e.g., \"Organiser Info\"). Each rule assigns a role name to elements matching a set of conditions. Rules are evaluated first-match-wins against the section's elements, with live preview showing matched/unmatched elements.</p>"},{"location":"source-files/section-rules-editor-modal-element/#how-it-works","title":"How it works","text":"<ol> <li>On <code>firstUpdated</code>, deep-clones existing rules (if any) to avoid mutating the original</li> <li>Renders rule cards with role name input + condition rows</li> <li>Evaluates all rules against elements in real-time (client-side, no server calls)</li> <li>Shows matched element per rule (green) or \"No match\" (amber)</li> <li>Lists unmatched elements at the bottom with \"Create rule\" buttons</li> <li>On save, returns the complete rule set to the caller</li> </ol>"},{"location":"source-files/section-rules-editor-modal-element/#rule-evaluation","title":"Rule evaluation","text":"<ul> <li>First-match-wins: Rules evaluated top-to-bottom. An element claimed by one rule is excluded from later rules.</li> <li>AND logic: All conditions in a rule must match for an element to be claimed.</li> <li>One match per rule: Each rule matches at most one element (first match only).</li> </ul>"},{"location":"source-files/section-rules-editor-modal-element/#condition-types","title":"Condition types","text":"Type Description Value <code>textBeginsWith</code> Element text starts with value string <code>textEndsWith</code> Element text ends with value string <code>textContains</code> Element text contains value string <code>textMatchesPattern</code> Element text matches regex regex string <code>fontSizeEquals</code> Font size matches (within 0.5pt) number <code>fontSizeRange</code> Font size within min/max range (inclusive) <code>{ min, max }</code> <code>fontSizeAbove</code> Font size greater than value number <code>fontSizeBelow</code> Font size less than value number <code>fontNameContains</code> Font name contains value string <code>colorEquals</code> Color hex matches string <code>positionFirst</code> First element in section (none) <code>positionLast</code> Last element in section (none)"},{"location":"source-files/section-rules-editor-modal-element/#auto-populate","title":"Auto-populate","text":"<p>Clicking \"Create rule\" on an unmatched element pre-fills conditions from all its metadata:</p> <ul> <li>Font size (always)</li> <li>Font name (always)</li> <li>Color (if not black)</li> <li>Text prefix (if text contains a colon within first 30 chars)</li> <li>Position (if first or last element)</li> </ul> <p>Role name is auto-suggested from the first few words of the element text (kebab-case).</p>"},{"location":"source-files/section-rules-editor-modal-element/#ui-layout","title":"UI layout","text":"<ul> <li>Section info bar: Element count, rule count, matched/unmatched counts</li> <li>Rule cards: Numbered cards with role name input, condition rows (type dropdown + value input + remove), live match preview</li> <li>Unmatched elements: Dashed border section at bottom listing unclaimed elements with their metadata badges and \"Create rule\" buttons</li> <li>Actions: Close + Save button</li> </ul>"},{"location":"source-files/section-rules-editor-modal-element/#find-replace","title":"Find &amp; Replace","text":"<p>Each rule can have a \"Find &amp; Replace\" section for cleaning up matched element text before it enters the transform output. Entries are applied in order.</p> <p>Each entry consists of two rows:</p> Row Dropdown Input Find Text begins with / Text ends with / Text contains Text to find Replace Replace with / Replace all with (adapts to find type) Replacement text <ul> <li>Text begins with \u2014 replaces only at the start, \"Replace with\"</li> <li>Text ends with \u2014 replaces only at the end, \"Replace with\"</li> <li>Text contains \u2014 replaces all occurrences, \"Replace all with\"</li> </ul> <p>The find type dropdown reuses the same vocabulary as rule conditions, making the UI consistent.</p>"},{"location":"source-files/section-rules-editor-modal-element/#inner-section-collapsing","title":"Inner section collapsing","text":"<p>All inner sections within expanded rules (Conditions, Exceptions, Part, Format, Find &amp; Replace) are collapsed by default. Section headers act as toggles \u2014 click to expand/collapse. This keeps rule cards compact even when expanded.</p>"},{"location":"source-files/section-rules-editor-modal-element/#custom-element","title":"Custom element","text":"<ul> <li>Tag: <code>&lt;up-doc-section-rules-editor-modal&gt;</code></li> <li>Extends: <code>UmbModalBaseElement&lt;SectionRulesEditorModalData, SectionRulesEditorModalValue&gt;</code></li> </ul>"},{"location":"source-files/section-rules-editor-modal-token/","title":"section-rules-editor-modal.token.ts","text":"<p>Modal token for the section rules editor sidebar.</p>"},{"location":"source-files/section-rules-editor-modal-token/#what-it-does","title":"What it does","text":"<p>Defines the data contract and default configuration for opening the section rules editor modal. Uses Umbraco's <code>UmbModalToken</code> pattern with typed data in/value out.</p>"},{"location":"source-files/section-rules-editor-modal-token/#interfaces","title":"Interfaces","text":""},{"location":"source-files/section-rules-editor-modal-token/#sectionruleseditormodaldata","title":"<code>SectionRulesEditorModalData</code>","text":"<p>Data passed when opening the modal:</p> Property Type Description <code>workflowName</code> <code>string</code> Name of the workflow (for context, not used in modal) <code>sectionId</code> <code>string</code> Transform section ID (e.g., <code>\"preamble-p1-z1\"</code>, <code>\"features\"</code>) <code>sectionHeading</code> <code>string</code> Human-readable section heading for the modal title <code>elements</code> <code>AreaElement[]</code> The elements belonging to this section (from area detection) <code>existingRules</code> <code>SectionRuleSet \\| null</code> Existing rules for this section, if any"},{"location":"source-files/section-rules-editor-modal-token/#sectionruleseditormodalvalue","title":"<code>SectionRulesEditorModalValue</code>","text":"<p>Value returned when the modal is submitted:</p> Property Type Description <code>rules</code> <code>SectionRuleSet</code> The updated rule set for this section"},{"location":"source-files/section-rules-editor-modal-token/#token","title":"Token","text":"<ul> <li>Alias: <code>UpDoc.SectionRulesEditorModal</code></li> <li>Type: sidebar</li> <li>Size: medium</li> </ul>"},{"location":"source-files/transforms/","title":"transforms.ts","text":"<p>Utility functions for converting extracted content into formats suitable for Umbraco document properties.</p>"},{"location":"source-files/transforms/#what-it-does","title":"What it does","text":"<p>Provides four exported functions for content transformation:</p> <ol> <li><code>markdownToHtml</code> -- converts Markdown text to HTML using the <code>marked</code> library</li> <li><code>normalizeToKebabCase</code> -- normalizes text to kebab-case for section IDs (mirrors C# <code>NormalizeToKebabCase</code>)</li> <li><code>stripMarkdown</code> -- strips Markdown formatting, returning plain text (for text/textArea fields)</li> <li><code>buildRteValue</code> -- wraps HTML content in the Umbraco Rich Text Editor (RTE) value structure</li> </ol>"},{"location":"source-files/transforms/#functions","title":"Functions","text":""},{"location":"source-files/transforms/#markdowntohtml","title":"markdownToHtml","text":"<pre><code>export function markdownToHtml(markdown: string): string\n</code></pre> <p>Converts a Markdown string to HTML using the <code>marked</code> library with GitHub Flavored Markdown (GFM) enabled:</p> <pre><code>const html = marked.parse(markdown, {\n    gfm: true,      // GitHub Flavored Markdown\n    breaks: false,   // Don't convert \\n to &lt;br&gt;\n});\n</code></pre> <p>Fallback handling: - Returns an empty string if the input is falsy - If <code>marked.parse</code> returns a Promise (unexpected with sync config), falls back to wrapping in <code>&lt;p&gt;</code> tags - If an exception occurs, falls back to manual conversion: double newlines become <code>&lt;/p&gt;&lt;p&gt;</code>, single newlines become <code>&lt;br&gt;</code></p>"},{"location":"source-files/transforms/#normalizetokebabcase","title":"normalizeToKebabCase","text":"<pre><code>export function normalizeToKebabCase(text: string): string\n</code></pre> <p>Converts text to kebab-case for use as section IDs. Mirrors the C# <code>NormalizeToKebabCase</code> in <code>ContentTransformService</code>:</p> <ul> <li>Lowercases, trims, replaces non-alphanumeric runs with hyphens, strips leading/trailing hyphens</li> <li><code>\"FEATURES\"</code> \u2192 <code>\"features\"</code>, <code>\"WHAT WE WILL SEE\"</code> \u2192 <code>\"what-we-will-see\"</code></li> </ul>"},{"location":"source-files/transforms/#stripmarkdown","title":"stripMarkdown","text":"<pre><code>export function stripMarkdown(markdown: string): string\n</code></pre> <p>Strips Markdown formatting from text, returning plain text. Used when mapping markdown content to plain text fields (<code>text</code>, <code>textArea</code>). Removes:</p> <ul> <li>Heading prefixes (<code># ## ###</code>)</li> <li>Bold (<code>**text**</code>) and italic (<code>*text*</code>) markers</li> <li>Strikethrough (<code>~~text~~</code>) and inline code (<code>`text`</code>)</li> <li>Bullet list prefixes (<code>- * +</code>), numbered list prefixes (<code>1. 2.</code>), blockquote prefixes (<code>&gt;</code>)</li> </ul> <p>Returns an empty string if the input is falsy.</p>"},{"location":"source-files/transforms/#buildrtevalue","title":"buildRteValue","text":"<pre><code>export function buildRteValue(htmlContent: string)\n</code></pre> <p>Builds the value object expected by Umbraco's Rich Text Editor property:</p> <pre><code>return {\n    blocks: {\n        contentData: [],\n        settingsData: [],\n        expose: [],\n        Layout: {},\n    },\n    markup: htmlContent,\n};\n</code></pre> <p>The <code>blocks</code> structure is required by Umbraco's RTE even when no blocks are used. The <code>markup</code> field contains the actual HTML content.</p>"},{"location":"source-files/transforms/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/transforms/#extracted-from-action","title":"Extracted from action","text":"<p>These functions were originally the <code>#convertToHtml</code> private method on <code>UpDocEntityAction</code>. They were extracted to a separate module so both the action's <code>#applyBlockMapping</code> method and any future consumers can reuse them.</p>"},{"location":"source-files/transforms/#used-together","title":"Used together","text":"<p>The typical usage pattern is to pipe content through both functions:</p> <pre><code>const htmlContent = markdownToHtml(sectionValue);\ntargetValue.value = buildRteValue(htmlContent);\n</code></pre> <p>This converts extracted Markdown content into the full RTE value structure expected by Umbraco's Management API.</p>"},{"location":"source-files/transforms/#imports","title":"Imports","text":"<pre><code>import { marked } from 'marked';\n</code></pre> <p>The <code>marked</code> library is a dependency of the UpDoc npm package.</p>"},{"location":"source-files/transforms/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-action.ts</code> -- <code>markdownToHtml</code>/<code>buildRteValue</code> for richText fields, <code>stripMarkdown</code> for text/textArea fields</li> <li><code>up-doc-collection-action.element.ts</code> -- same as above (bridge files kept in sync)</li> <li><code>up-doc-modal.element.ts</code> -- <code>stripMarkdown</code> for document name pre-fill</li> </ul>"},{"location":"source-files/up-doc-action/","title":"up-doc-action.ts","text":"<p>The entity action class that handles the \"Create Document from Source\" menu click.</p>"},{"location":"source-files/up-doc-action/#what-it-does","title":"What it does","text":"<p>When a user clicks \"Create from Source\" in the collection view, this action:</p> <ol> <li>Gets the parent document's document type</li> <li>Discovers allowed child document types and their blueprints (grouped by document type)</li> <li>Fetches active workflows and filters blueprints to only those with complete workflows</li> <li>Opens the blueprint picker dialog -- user selects a document type, then a blueprint</li> <li>Opens the source sidebar modal -- passes the selected <code>blueprintId</code> so the modal can fetch the config and extract content</li> <li>Receives <code>extractedSections</code> (element ID \u2192 text lookup) and <code>config</code> from the modal return value</li> <li>Scaffolds from the selected blueprint to get default values</li> <li>Loops over <code>config.map.mappings</code> to apply each mapping using path-based targeting, with first-write-replaces and subsequent-writes-concatenate semantics</li> <li>Creates a new document via the Management API</li> <li>Saves the document to properly persist it and trigger cache updates</li> <li>Shows success/error notifications</li> <li>Navigates to the newly created document</li> </ol>"},{"location":"source-files/up-doc-action/#class-structure","title":"Class structure","text":"<pre><code>export class UpDocEntityAction extends UmbEntityActionBase&lt;never&gt; {\n    #documentTypeStructureRepository = new UmbDocumentTypeStructureRepository(this);\n    #blueprintItemRepository = new UmbDocumentBlueprintItemRepository(this);\n    #documentItemRepository = new UmbDocumentItemRepository(this);\n\n    constructor(host: UmbControllerHost, args: UmbEntityActionArgs&lt;never&gt;) {\n        super(host, args);\n    }\n\n    override async execute() {\n        // Opens modals, discovers blueprints, creates document\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-action/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-action/#modal-handling-with-cancellation","title":"Modal handling with cancellation","text":"<p>The modal can be cancelled (clicking outside or Close button), which throws an error. This is handled gracefully:</p> <pre><code>let modalValue;\ntry {\n    modalValue = await umbOpenModal(this, UMB_UP_DOC_MODAL, {\n        data: {\n            unique: parentUnique,\n            documentTypeName: selectedDocType?.documentTypeName ?? '',\n            blueprintName: selectedBlueprint?.blueprintName ?? '',\n            blueprintId: blueprintUnique,\n        },\n    });\n} catch {\n    // Modal was cancelled\n    return;\n}\n</code></pre>"},{"location":"source-files/up-doc-action/#destructuring-modal-return-value","title":"Destructuring modal return value","text":"<p>The modal returns <code>extractedSections</code> (a <code>Record&lt;string, string&gt;</code> keyed by element IDs like <code>p1-e2</code>) and <code>config</code> (the full <code>DocumentTypeConfig</code>):</p> <pre><code>const { name, mediaUnique, extractedSections, config } = modalValue;\n\nif (!mediaUnique || !name || !config) {\n    return;\n}\n</code></pre>"},{"location":"source-files/up-doc-action/#blueprint-filtering-via-active-workflows","title":"Blueprint filtering via active workflows","text":"<p>Before opening the blueprint picker, the action fetches the list of active workflows and filters out blueprints that don't have complete workflows:</p> <pre><code>const authContext = await this.getContext(UMB_AUTH_CONTEXT);\nconst token = await authContext.getLatestToken();\n\nconst activeWorkflows = await fetchActiveWorkflows(token);\nconst activeBlueprintIds = new Set(activeWorkflows.blueprintIds);\n\n// Only include blueprints that have complete workflows\nconst workflowBlueprints = blueprints.filter((bp) =&gt; activeBlueprintIds.has(bp.unique));\n</code></pre> <p>This means editors only see blueprints where an admin has fully configured the workflow (destination + map + at least one source). If no workflows match any allowed child type, a warning notification is shown and the action exits early.</p>"},{"location":"source-files/up-doc-action/#config-driven-mapping-loop-with-field-tracking","title":"Config-driven mapping loop with field tracking","text":"<p>The action loops over <code>config.map.mappings</code> and applies each mapping. A <code>mappedFields</code> Set tracks which destination fields have already been written:</p> <pre><code>const mappedFields = new Set&lt;string&gt;();\n\nfor (const mapping of config.map.mappings) {\n    if (mapping.enabled === false) continue;\n\n    const sectionValue = extractedSections[mapping.source];\n    if (!sectionValue) continue;\n\n    for (const dest of mapping.destinations) {\n        this.#applyDestinationMapping(values, dest, sectionValue, config, mappedFields);\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-action/#multi-element-field-handling","title":"Multi-element field handling","text":"<p>When multiple source elements map to the same destination field (e.g., a title split across two PDF lines), the <code>mappedFields</code> Set controls the behavior:</p> <ul> <li>First write to a field: replaces the blueprint default value</li> <li>Subsequent writes to the same field: concatenates with a space separator</li> </ul> <pre><code>if (existing) {\n    if (mappedFields.has(alias)) {\n        // Already written \u2014 concatenate\n        const currentValue = typeof existing.value === 'string' ? existing.value : '';\n        existing.value = `${currentValue} ${transformedValue}`;\n    } else {\n        // First write \u2014 replace the blueprint default\n        existing.value = transformedValue;\n    }\n} else {\n    values.push({ alias, value: transformedValue });\n}\nmappedFields.add(alias);\n</code></pre> <p>This prevents blueprint defaults from being prepended to mapped values while still allowing multi-element concatenation.</p>"},{"location":"source-files/up-doc-action/#destination-mapping-with-block-disambiguation","title":"Destination mapping with block disambiguation","text":"<p>The <code>#applyDestinationMapping</code> method handles three cases:</p> <ol> <li>Block property with <code>blockKey</code> \u2014 looks up the specific block instance in <code>destination.json</code> by key, retrieves its <code>identifyBy</code> matcher, then calls <code>#applyBlockGridValue</code> to find and update the correct block in the scaffold</li> <li>Simple field \u2014 direct property alias (e.g., <code>\"pageTitle\"</code>)</li> <li>Dot-path block property (legacy) \u2014 <code>\"gridKey.blockKey.propertyKey\"</code> format for backwards compatibility</li> </ol> <pre><code>#applyDestinationMapping(values, dest, sectionValue, config, mappedFields) {\n    // 1. Block property with blockKey \u2014 find specific block instance\n    if (dest.blockKey) {\n        // Look up block in destination config by key \u2192 get identifyBy \u2192 apply\n    }\n\n    // 2. Simple field: \"pageTitle\"\n    if (pathParts.length === 1) { ... }\n\n    // 3. Legacy dot-path: \"contentGrid.itineraryBlock.richTextContent\"\n    if (pathParts.length === 3) { ... }\n}\n</code></pre> <p>See Mapping Directions for details on how block disambiguation works in each mapping direction.</p>"},{"location":"source-files/up-doc-action/#block-grid-value-application","title":"Block grid value application","text":"<p>The <code>#applyBlockGridValue</code> method finds a block within a block grid by searching for a property value match, then writes the extracted content. It uses <code>mappedFields</code> with a compound key (<code>${block.key}:${targetProperty}</code>) to track writes \u2014 first write replaces the blueprint default, subsequent writes concatenate with newline:</p> <pre><code>#applyBlockGridValue(\n    values: Array&lt;{ alias: string; value: unknown }&gt;,\n    gridAlias: string,\n    blockSearch: { property: string; value: string },\n    targetProperty: string,\n    value: string,\n    convertMarkdown: boolean | undefined,\n    mappedFields: Set&lt;string&gt;\n) {\n    // Find block by identifyBy matcher, then:\n    const fieldKey = `${block.key}:${targetProperty}`;\n    if (mappedFields.has(fieldKey)) {\n        // Concatenate with newline\n        targetValue.value = `${currentValue}\\n${value}`;\n    } else {\n        // First write \u2014 replace blueprint default\n        targetValue.value = value;\n    }\n    mappedFields.add(fieldKey);\n}\n</code></pre> <p>This allows multiple source elements mapped to the same block property (e.g., 12 bullet points \u2192 one rich text field) to assemble into a single concatenated value.</p>"},{"location":"source-files/up-doc-action/#content-format-conversion","title":"Content format conversion","text":"<p>After all mappings are applied, <code>#convertRichTextFields</code> processes field values based on the destination field type (from <code>destination.json</code>):</p> <ul> <li><code>richText</code> fields: Markdown is converted to HTML using <code>markdownToHtml</code> and wrapped in <code>buildRteValue</code></li> <li><code>text</code> / <code>textArea</code> fields: Markdown formatting is stripped using <code>stripMarkdown</code> (removes heading prefixes like <code>#</code>, bold markers, bullet prefixes, etc.)</li> </ul> <p>This applies to both top-level document properties and block-level properties within the block grid.</p>"},{"location":"source-files/up-doc-action/#scaffolding-from-blueprint","title":"Scaffolding from blueprint","text":"<p>The scaffold endpoint returns the blueprint's default values including pre-populated block grids:</p> <pre><code>const scaffoldResponse = await fetch(\n    `/umbraco/management/api/v1/document-blueprint/${blueprintUnique}/scaffold`,\n    { headers: { Authorization: `Bearer ${token}` } }\n);\nconst scaffold = await scaffoldResponse.json();\n</code></pre>"},{"location":"source-files/up-doc-action/#authentication-for-api-calls","title":"Authentication for API calls","text":"<p>Umbraco uses bearer token authentication for Management API calls:</p> <pre><code>const authContext = await this.getContext(UMB_AUTH_CONTEXT);\nconst token = await authContext.getLatestToken();\n\nconst response = await fetch(url, {\n    headers: {\n        Authorization: `Bearer ${token}`,\n    },\n});\n</code></pre>"},{"location":"source-files/up-doc-action/#imports","title":"Imports","text":"<pre><code>import { UMB_UP_DOC_MODAL } from './up-doc-modal.token.js';\nimport { UMB_BLUEPRINT_PICKER_MODAL } from './blueprint-picker-modal.token.js';\nimport type { DocumentTypeOption } from './blueprint-picker-modal.token.js';\nimport type { DocumentTypeConfig, MappingDestination } from './workflow.types.js';\nimport { fetchActiveWorkflows } from './workflow.service.js';\nimport { markdownToHtml, buildRteValue, stripMarkdown } from './transforms.js';\nimport { UmbEntityActionBase } from '@umbraco-cms/backoffice/entity-action';\nimport { umbOpenModal } from '@umbraco-cms/backoffice/modal';\nimport { UMB_NOTIFICATION_CONTEXT } from '@umbraco-cms/backoffice/notification';\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\nimport { UmbDocumentTypeStructureRepository } from '@umbraco-cms/backoffice/document-type';\nimport { UmbDocumentBlueprintItemRepository } from '@umbraco-cms/backoffice/document-blueprint';\nimport { UmbDocumentItemRepository } from '@umbraco-cms/backoffice/document';\n</code></pre>"},{"location":"source-files/up-doc-action/#data-flow","title":"Data flow","text":"<ol> <li><code>this.args.unique</code> -- Parent document ID (from the collection view context)</li> <li>Action fetches parent document to get its document type unique</li> <li>Action discovers allowed child document types and their blueprints</li> <li>Fetches active workflows, filters blueprints to only those with complete workflows</li> <li>Blueprint picker dialog returns <code>{ blueprintUnique, documentTypeUnique }</code></li> <li>Source sidebar modal receives <code>{ unique, documentTypeName, blueprintName, blueprintId }</code> and returns <code>{ name, mediaUnique, extractedSections, config }</code></li> <li>Scaffolds from selected blueprint to get default values</li> <li>Loops over <code>config.map.mappings</code>, applying each to scaffold values (first write replaces, subsequent writes concatenate)</li> <li>POSTs to create document API</li> <li>Fetches and saves the document to properly persist it</li> <li>Shows notification and navigates to the new document</li> </ol>"},{"location":"source-files/up-doc-action/#navigation-after-creation","title":"Navigation after creation","text":"<p>After successfully creating the document, the action navigates to the new document with a short delay:</p> <pre><code>if (newDocumentId) {\n    const newPath = `/umbraco/section/content/workspace/document/edit/${newDocumentId}`;\n    setTimeout(() =&gt; {\n        window.location.href = newPath;\n    }, 150);\n}\n</code></pre> <p>The delay helps avoid race condition errors with Block Preview that can occur during rapid navigation.</p>"},{"location":"source-files/up-doc-action/#default-export","title":"Default export","text":"<p>The class is exported both as named and default export -- the default export is what the manifest's <code>api</code> loader expects.</p>"},{"location":"source-files/up-doc-collection-action-element/","title":"up-doc-collection-action.element.ts","text":"<p>A custom Lit element that renders a \"Create from Source\" button in the collection toolbar, next to the existing \"Create [DocType]\" button.</p>"},{"location":"source-files/up-doc-collection-action-element/#what-it-does","title":"What it does","text":"<p>When a user is viewing a document collection (e.g., Group Tours list view), this element:</p> <ol> <li>Uses <code>UMB_DOCUMENT_WORKSPACE_CONTEXT</code> to get the current parent document and its document type</li> <li>Checks whether any allowed child types have blueprints with complete workflows</li> <li>If workflows exist, renders a \"Create from Source\" button</li> <li>On click, runs the same flow as the entity action: blueprint picker \u2192 source sidebar \u2192 scaffold \u2192 map \u2192 create document</li> </ol>"},{"location":"source-files/up-doc-collection-action-element/#why-a-custom-element-not-an-api-class","title":"Why a custom element (not an API class)","text":"<p>Umbraco's collection action system supports two patterns: - <code>api</code> \u2014 a class extending <code>UmbCollectionActionBase</code> (for simple execute/getHref) - <code>element</code> \u2014 a custom Lit element for full control over rendering</p> <p>We use the <code>element</code> approach because: - We need to conditionally render (hide the button when no workflows exist) - We need to access <code>UMB_DOCUMENT_WORKSPACE_CONTEXT</code> for the parent document info - Umbraco's own \"Create Group Tour\" button uses this same pattern</p>"},{"location":"source-files/up-doc-collection-action-element/#visibility","title":"Visibility","text":"<p>The button is self-hiding. Instead of using a custom condition (which would need <code>UMB_ENTITY_CONTEXT</code> \u2014 not available in collection context), the element: 1. Consumes <code>UMB_DOCUMENT_WORKSPACE_CONTEXT</code> to get the document type 2. Fetches active workflows 3. Checks if any allowed child types have workflow blueprints 4. Sets <code>_hasWorkflows = true</code> only if workflows exist 5. The <code>render()</code> method returns empty HTML when <code>_hasWorkflows</code> is false</p>"},{"location":"source-files/up-doc-collection-action-element/#manifest-registration","title":"Manifest registration","text":"<pre><code>{\n    type: 'collectionAction',\n    kind: 'button',\n    alias: 'UpDoc.CollectionAction',\n    name: 'UpDoc Collection Action',\n    element: () =&gt; import('./up-doc-collection-action.element.js'),\n    weight: 50,\n    meta: {\n        label: 'Create from Source',\n    },\n    conditions: [\n        {\n            alias: 'Umb.Condition.CollectionAlias',\n            match: 'Umb.Collection.Document',\n        },\n    ],\n}\n</code></pre> <p>The <code>Umb.Condition.CollectionAlias</code> condition ensures it only appears on document collections (not media, members, etc.). The <code>weight: 50</code> places it after Umbraco's own create button (weight 100).</p>"},{"location":"source-files/up-doc-collection-action-element/#document-creation-and-mapping","title":"Document creation and mapping","text":"<p>The collection action contains the full document creation pipeline:</p> <ol> <li>Scaffolds a document from the selected blueprint</li> <li>Deep-clones scaffold values</li> <li>Iterates through <code>config.map.mappings</code>, applying each to the cloned values</li> <li>Creates the document via Umbraco Management API POST</li> <li>Immediately saves (PUT) to persist and trigger cache updates</li> </ol>"},{"location":"source-files/up-doc-collection-action-element/#destination-mapping-with-block-disambiguation","title":"Destination mapping with block disambiguation","text":"<p><code>#applyDestinationMapping</code> handles three cases:</p> <ol> <li>Block property with <code>blockKey</code> \u2014 looks up the specific block instance in <code>destination.json</code> by key, retrieves its <code>identifyBy</code> matcher, then calls <code>#applyBlockGridValue</code></li> <li>Simple field \u2014 direct property alias (e.g., <code>\"pageTitle\"</code>)</li> <li>Legacy dot-path \u2014 <code>\"gridKey.blockKey.propertyKey\"</code> format for backwards compat</li> </ol>"},{"location":"source-files/up-doc-collection-action-element/#content-format-conversion","title":"Content format conversion","text":"<p>After all mappings are applied, <code>#convertRichTextFields</code> processes field values based on the destination field type (from <code>destination.json</code>):</p> <ul> <li><code>richText</code> fields: Markdown is converted to HTML using <code>markdownToHtml</code> and wrapped in <code>buildRteValue</code></li> <li><code>text</code> / <code>textArea</code> fields: Markdown formatting is stripped using <code>stripMarkdown</code> (removes heading prefixes like <code>#</code>, bold markers, bullet prefixes, etc.)</li> </ul> <p>This applies to both top-level document properties and block-level properties within the block grid.</p>"},{"location":"source-files/up-doc-collection-action-element/#concatenation-tracking","title":"Concatenation tracking","text":"<p><code>mappedFields</code> (a <code>Set&lt;string&gt;</code>) tracks which fields have been written. First write replaces the blueprint default; subsequent writes concatenate: - Top-level fields: key = alias (e.g., <code>\"pageTitle\"</code>), concatenated with space - Block properties: key = <code>${block.key}:${propertyAlias}</code> (e.g., <code>\"abc-123:richTextContent\"</code>), concatenated with newline</p> <p>This allows multiple source elements mapped to the same destination to assemble into one value (e.g., 12 bullet points \u2192 one rich text field).</p>"},{"location":"source-files/up-doc-collection-action-element/#relationship-to-up-doc-actionts","title":"Relationship to up-doc-action.ts","text":"<p>The collection action duplicates the document creation logic from <code>up-doc-action.ts</code>. Both files contain: - Blueprint discovery and filtering - Modal opening (blueprint picker + source sidebar) - Scaffolding from blueprint - Property mapping (<code>#applyDestinationMapping</code>, <code>#applyBlockGridValue</code>) - Concatenation tracking via <code>mappedFields</code> - Document creation and save</p> <p>This duplication exists because the entity action extends <code>UmbEntityActionBase</code> while the collection action extends <code>UmbLitElement</code> \u2014 they have different base classes and lifecycle patterns. A future refactoring could extract the shared logic into a service module.</p> <p>IMPORTANT: When modifying mapping or bridge logic, changes must be applied to BOTH files. The collection action is the primary code path used by the \"Create from Source\" button in content collection views.</p>"},{"location":"source-files/up-doc-collection-action-element/#key-difference-from-entity-action","title":"Key difference from entity action","text":"<p>The entity action uses <code>this.args.unique</code> (from <code>UmbEntityActionArgs</code>) for the parent document ID. The collection action uses <code>UMB_DOCUMENT_WORKSPACE_CONTEXT</code> which provides <code>unique</code> and <code>contentTypeUnique</code> observables.</p>"},{"location":"source-files/up-doc-composer/","title":"UpDocComposer.cs","text":"<p>Umbraco composer that registers services for the UpDoc extension.</p>"},{"location":"source-files/up-doc-composer/#what-it-does","title":"What it does","text":"<p>Registers extraction services with Umbraco's dependency injection container during application startup.</p>"},{"location":"source-files/up-doc-composer/#code","title":"Code","text":"<pre><code>public class UpDocComposer : IComposer\n{\n    public void Compose(IUmbracoBuilder builder)\n    {\n        builder.Services.AddScoped&lt;IPdfExtractionService, PdfExtractionService&gt;();\n        builder.Services.AddScoped&lt;IPdfPagePropertiesService, PdfPagePropertiesService&gt;();\n        builder.Services.AddScoped&lt;IMarkdownExtractionService, MarkdownExtractionService&gt;();\n        builder.Services.AddSingleton&lt;IWorkflowService, WorkflowService&gt;();\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-composer/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-composer/#icomposer","title":"IComposer","text":"<p>Umbraco's composition pattern for registering services: - Automatically discovered at startup - Runs before the application starts - Used for DI registration, event subscriptions, etc.</p>"},{"location":"source-files/up-doc-composer/#service-lifetimes","title":"Service lifetimes","text":"<p><code>AddScoped</code> means: - One instance per HTTP request - Disposed at the end of the request - Appropriate for services that may hold request-specific state - Used for <code>IPdfExtractionService</code>, <code>IPdfPagePropertiesService</code>, and <code>IMarkdownExtractionService</code></p> <p><code>AddSingleton</code> means: - One instance for entire application lifetime - Used for <code>IWorkflowService</code> because it caches map files in memory after first load and the data is read-only</p>"},{"location":"source-files/up-doc-composer/#alternatives","title":"Alternatives","text":"<ul> <li><code>AddTransient</code> - New instance every time it's requested</li> </ul>"},{"location":"source-files/up-doc-composer/#when-to-use-composers","title":"When to use composers","text":"<p>Use composers when you need to: - Register custom services - Subscribe to Umbraco events - Configure Umbraco features - Add middleware or filters</p>"},{"location":"source-files/up-doc-has-workflows-condition/","title":"up-doc-has-workflows.condition.ts","text":"<p>Custom Umbraco condition that controls when the \"Create Document from Source\" entity action is visible.</p>"},{"location":"source-files/up-doc-has-workflows-condition/#what-it-does","title":"What it does","text":"<p>Performs a per-node check: for each content node, it checks whether any of that node's allowed child document types have a blueprint with a complete UpDoc workflow. If not, the entity action is hidden for that specific node.</p> <p>This means the \"Create Document from Source\" menu item only appears on nodes where it would actually work -- e.g., on \"Group Tours\" (which allows groupTour children with a workflow) but not on \"Standard Pages\" (which only allows standardWebPage children with no workflow).</p>"},{"location":"source-files/up-doc-has-workflows-condition/#how-it-works","title":"How it works","text":"<ol> <li>Consumes <code>UMB_ENTITY_CONTEXT</code> to get the current node's unique ID (reacts to navigation)</li> <li>Consumes <code>UMB_AUTH_CONTEXT</code> to get a bearer token</li> <li>When both are available, evaluates:    a. Fetches active workflows (cached globally via <code>fetchActiveWorkflows()</code>)    b. Looks up the entity's document type via <code>UmbDocumentItemRepository</code>    c. Gets allowed child types via <code>UmbDocumentTypeStructureRepository</code>    d. For each allowed child type, checks if any blueprint ID is in the active set    e. Sets <code>this.permitted = true</code> on first match, <code>false</code> if no matches</li> <li>Re-evaluates when the entity unique changes (navigating between nodes)</li> </ol> <pre><code>export class UpDocHasWorkflowsCondition\n    extends UmbConditionBase&lt;UpDocHasWorkflowsConditionConfig&gt;\n    implements UmbExtensionCondition\n{\n    #documentTypeStructureRepository = new UmbDocumentTypeStructureRepository(this);\n    #blueprintItemRepository = new UmbDocumentBlueprintItemRepository(this);\n    #documentItemRepository = new UmbDocumentItemRepository(this);\n\n    constructor(host, args) {\n        super(host, args);\n\n        this.consumeContext(UMB_AUTH_CONTEXT, (authContext) =&gt; {\n            this.#authContext = authContext;\n            this.#tryEvaluate();\n        });\n\n        this.consumeContext(UMB_ENTITY_CONTEXT, (entityContext) =&gt; {\n            this.observe(entityContext.unique, (unique) =&gt; {\n                this.#entityUnique = unique ?? null;\n                this.#tryEvaluate();\n            });\n        });\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-has-workflows-condition/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-has-workflows-condition/#per-node-evaluation-via-umb_entity_context","title":"Per-node evaluation via UMB_ENTITY_CONTEXT","text":"<p>The condition uses Umbraco's <code>UMB_ENTITY_CONTEXT</code> to get the entity unique for the content node being evaluated. This context is provided per-entity in the content tree, so each node gets its own condition evaluation.</p> <p>The <code>observe()</code> pattern means the condition re-evaluates when navigating between nodes, not just on first load.</p>"},{"location":"source-files/up-doc-has-workflows-condition/#two-context-coordination","title":"Two-context coordination","text":"<p>Both <code>UMB_AUTH_CONTEXT</code> and <code>UMB_ENTITY_CONTEXT</code> arrive asynchronously. The condition stores both values and only evaluates when both are available:</p> <pre><code>#tryEvaluate() {\n    if (this.#authContext &amp;&amp; this.#entityUnique !== undefined) {\n        this.#evaluate(this.#authContext, this.#entityUnique);\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-has-workflows-condition/#performance","title":"Performance","text":"<ul> <li>Active workflows: Globally cached, one API call per browser session</li> <li>Document item lookup: Cached by Umbraco's <code>UmbDocumentItemRepository</code></li> <li>Allowed children: Cached by Umbraco's <code>UmbDocumentTypeStructureRepository</code></li> <li>Blueprint lookup: Cached by Umbraco's <code>UmbDocumentBlueprintItemRepository</code></li> <li>Early exit: Stops checking child types on first blueprint match</li> </ul>"},{"location":"source-files/up-doc-has-workflows-condition/#global-condition-config-type","title":"Global condition config type","text":"<p>The config type is registered globally so Umbraco's extension registry can match the condition alias:</p> <pre><code>export type UpDocHasWorkflowsConditionConfig =\n    UmbConditionConfigBase&lt;'UpDoc.Condition.HasAvailableWorkflows'&gt;;\n\ndeclare global {\n    interface UmbExtensionConditionConfigMap {\n        UpDocHasWorkflowsConditionConfig: UpDocHasWorkflowsConditionConfig;\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-has-workflows-condition/#fail-safe-behaviour","title":"Fail-safe behaviour","text":"<p>If any API call fails (network error, server down, etc.), the condition defaults to <code>permitted = false</code>. This means the entity action is hidden rather than showing a broken experience.</p>"},{"location":"source-files/up-doc-has-workflows-condition/#imports","title":"Imports","text":"<pre><code>import { UmbConditionBase } from '@umbraco-cms/backoffice/extension-registry';\nimport type {\n    UmbConditionConfigBase,\n    UmbConditionControllerArguments,\n    UmbExtensionCondition,\n} from '@umbraco-cms/backoffice/extension-api';\nimport type { UmbControllerHost } from '@umbraco-cms/backoffice/controller-api';\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\nimport { UMB_ENTITY_CONTEXT } from '@umbraco-cms/backoffice/entity';\nimport { UmbDocumentTypeStructureRepository } from '@umbraco-cms/backoffice/document-type';\nimport { UmbDocumentBlueprintItemRepository } from '@umbraco-cms/backoffice/document-blueprint';\nimport { UmbDocumentItemRepository } from '@umbraco-cms/backoffice/document';\nimport { fetchActiveWorkflows } from './workflow.service.js';\n</code></pre>"},{"location":"source-files/up-doc-has-workflows-condition/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> -- registered as a <code>condition</code> extension type with alias <code>UpDoc.Condition.HasAvailableWorkflows</code></li> <li>Used by the <code>UpDoc.EntityAction</code> entity action as a condition</li> </ul>"},{"location":"source-files/up-doc-has-workflows-condition/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-action.ts</code> -- the entity action this condition gates</li> </ul>"},{"location":"source-files/up-doc-modal-element/","title":"up-doc-modal.element.ts","text":"<p>The Lit component that renders the \"Create from Source\" sidebar modal.</p>"},{"location":"source-files/up-doc-modal-element/#what-it-does","title":"What it does","text":"<p>Provides the UI for users to:</p> <ol> <li>Choose a source type (PDF Document, Markdown, Web Page, or Word Document)</li> <li>Configure the source (pick a media item, paste a URL, etc.)</li> <li>Enter a document name (or leave blank to auto-populate from mapped title elements)</li> <li>For PDF and Markdown sources: automatically runs rich extraction when a media item is selected</li> <li>Pre-fills the document name by finding elements mapped to the first destination field and concatenating them</li> <li>Review mapped content in the Content tab \u2014 shows destination field labels with assembled values from the extraction</li> <li>Copy individual mapped values via hover-reveal action buttons</li> <li>Check the destination document type and blueprint in the Destination tab</li> <li>Submit or cancel the operation</li> </ol> <p>PDF and Markdown source types are fully functional. Web Page and Word Document source types show their respective UI (URL input and media picker) but display \"not yet available\" messages and the Create button remains disabled.</p> <p>The source type dropdown is dynamically populated from the workflow config. When the modal opens, it fetches the config for the selected blueprint and only shows source types that have config files (e.g., if only <code>source-pdf.json</code> exists, only \"PDF Document\" appears). If only one source type is available, it is auto-selected.</p>"},{"location":"source-files/up-doc-modal-element/#tabbed-interface","title":"Tabbed Interface","text":"<p>The modal uses a tabbed interface with navigation tabs in the header:</p> <ul> <li>Source tab (default, active on open): Choose a source type, provide the source file/URL, enter document name</li> <li>Content tab: Review mapped content before creating the document (disabled until extraction completes)</li> <li>Destination tab: Read-only reference showing the selected document type and blueprint</li> </ul> <p>The tab order follows the user's workflow: Source (what to import) -&gt; Content (review extraction) -&gt; Destination (where it's going, already decided). The Source tab is active on arrival because that's the user's immediate next action. The Destination tab is last because the user already chose the document type and blueprint in the preceding dialog steps \u2014 it's a reference, not a next step.</p> <p>The tabs follow Umbraco's sidebar modal header pattern using <code>slot=\"navigation\"</code> on the <code>uui-tab-group</code>.</p>"},{"location":"source-files/up-doc-modal-element/#class-structure","title":"Class structure","text":"<pre><code>type TabType = 'source' | 'content' | 'destination';\n\n@customElement('up-doc-modal')\nexport class UpDocModalElement extends UmbModalBaseElement&lt;\n    UmbUpDocModalData,\n    UmbUpDocModalValue\n&gt; {\n    @state() private _activeTab: TabType = 'source';\n    @state() private _documentName = '';\n    @state() private _sourceType: SourceType | '' = '';\n    @state() private _sourceUrl = '';\n    @state() private _selectedMediaUnique: string | null = null;\n    @state() private _extractedSections: Record&lt;string, string&gt; = {};\n    @state() private _config: DocumentTypeConfig | null = null;\n    @state() private _isExtracting = false;\n    @state() private _extractionError: string | null = null;\n    @state() private _availableSourceTypes: string[] = [];\n    @state() private _loadingSourceTypes = true;\n\n    // ... methods and render\n}\n</code></pre> <p>The modal stores: - <code>_activeTab</code> -- tracks which tab is currently active ('source', 'content', or 'destination') - <code>_extractedSections</code> -- a <code>Record&lt;string, string&gt;</code> holding all extracted values keyed by element ID (e.g., <code>p1-e2</code>, <code>p1-e3</code>). These IDs match the source keys in <code>map.json</code>. - <code>_config</code> -- the full <code>DocumentTypeConfig</code> loaded once at startup via <code>fetchConfig()</code>, containing source, destination, and map configs</p>"},{"location":"source-files/up-doc-modal-element/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-modal-element/#extending-umbmodalbaseelement","title":"Extending UmbModalBaseElement","text":"<p>All Umbraco modals extend <code>UmbModalBaseElement&lt;TData, TValue&gt;</code>: - <code>TData</code> -- The data passed TO the modal when opening - <code>TValue</code> -- The data returned FROM the modal when submitted</p>"},{"location":"source-files/up-doc-modal-element/#area-aware-extraction-via-extractfromsource","title":"Area-aware extraction via #extractFromSource","text":"<p>The <code>#extractFromSource</code> method calls <code>transformAdhoc</code> from <code>workflow.service.ts</code> to run the full Extract \u2192 Shape pipeline. This produces sections with IDs matching <code>map.json</code> source keys:</p> <ol> <li>Calls <code>transformAdhoc(workflowName, mediaUnique, token)</code> to get the transform result</li> <li>Flattens all areas/groups/sections via <code>allTransformSections()</code></li> <li>Builds a <code>sectionLookup</code> record mapping composite keys (e.g., <code>features.content</code>, <code>features.title</code>) to text values</li> <li>Pre-fills the document name from mapped title sections (with <code>stripMarkdown</code> applied)</li> </ol> <p>The config is loaded once at modal startup (not per-extraction), so <code>_config</code> is already available when extraction completes.</p>"},{"location":"source-files/up-doc-modal-element/#document-name-pre-fill","title":"Document name pre-fill","text":"<p>The <code>#prefillDocumentName</code> method finds the first top-level (non-block) destination target in <code>map.json</code>, collects text from all sections mapped to that target, strips any markdown formatting, and joins them with spaces.</p> <p>The method applies <code>stripMarkdown()</code> to remove heading prefixes (e.g., <code># Title</code> \u2192 <code>Title</code>) since extracted content may contain markdown formatting that shouldn't appear in the document name.</p> <p>This handles cases like a title split across two PDF lines (e.g., \"Flemish Masters \u2013\" + \"Bruges, Antwerp &amp; Ghent\" \u2192 \"Flemish Masters \u2013 Bruges, Antwerp &amp; Ghent\"). If no mapping-based name is found, it falls back to the first non-empty section value (also stripped of markdown).</p>"},{"location":"source-files/up-doc-modal-element/#content-tab-with-grouped-preview","title":"Content tab with grouped preview","text":"<p>The Content tab shows destination field labels with assembled values from the extraction, grouped by the destination document's tab structure. This gives the user a preview that matches the layout they'll see when editing the document in Umbraco.</p> <p>The <code>#buildGroupedPreview()</code> method groups mapped content by destination tab using shared utilities from <code>destination-utils.ts</code>:</p> <pre><code>interface ContentTabGroup {\n    tabId: string;\n    tabLabel: string;\n    items: Array&lt;{ label: string; value: string; blockLabel?: string }&gt;;\n}\n</code></pre> <ul> <li>Uses <code>resolveDestinationTab()</code> to classify each mapping into a destination tab</li> <li>Uses <code>resolveBlockLabel()</code> to resolve block labels for Page Content items</li> <li>Compound keys (<code>blockKey:alias</code>) ensure block property values are correctly grouped</li> <li>Items within Page Content are sub-grouped by block, with block headers as visual dividers</li> <li>Only tabs with mapped content are shown</li> </ul> <p>When multiple tabs have content, inner <code>uui-tab-group</code> tabs appear (matching the Destination view's tab pattern). When only one tab has content, the tab bar is omitted to avoid a single useless tab.</p>"},{"location":"source-files/up-doc-modal-element/#destination-tab","title":"Destination tab","text":"<p>The Destination tab shows read-only reference information about where the extracted content will be created:</p> <pre><code>#renderDestinationTab() {\n    return html`\n        &lt;uui-box headline=\"Document Type\"&gt;\n            &lt;div class=\"destination-value\"&gt;\n                &lt;umb-icon name=\"icon-document-dashed-line\"&gt;&lt;/umb-icon&gt;\n                &lt;span&gt;${this.data?.documentTypeName}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/uui-box&gt;\n        &lt;uui-box headline=\"Blueprint\"&gt;\n            &lt;div class=\"destination-value\"&gt;\n                &lt;umb-icon name=\"icon-blueprint\"&gt;&lt;/umb-icon&gt;\n                &lt;span&gt;${this.data?.blueprintName}&lt;/span&gt;\n            &lt;/div&gt;\n        &lt;/uui-box&gt;\n    `;\n}\n</code></pre> <p>Both <code>documentTypeName</code> and <code>blueprintName</code> are passed via the modal data from the preceding picker dialogs.</p>"},{"location":"source-files/up-doc-modal-element/#tab-navigation","title":"Tab navigation","text":"<p>The tabs are rendered in the modal header using <code>slot=\"navigation\"</code>:</p> <pre><code>#renderTabs() {\n    const hasContent = this.#hasExtractedContent();\n    return html`\n        &lt;uui-tab-group slot=\"navigation\"&gt;\n            &lt;uui-tab\n                label=\"Source\"\n                ?active=${this._activeTab === 'source'}\n                orientation=\"horizontal\"\n                @click=${() =&gt; this.#handleTabClick('source')}&gt;\n                &lt;uui-icon slot=\"icon\" name=\"icon-page-add\"&gt;&lt;/uui-icon&gt;\n                Source\n            &lt;/uui-tab&gt;\n            &lt;uui-tab\n                label=\"Content\"\n                ?active=${this._activeTab === 'content'}\n                orientation=\"horizontal\"\n                ?disabled=${!hasContent}\n                @click=${() =&gt; this.#handleTabClick('content')}&gt;\n                &lt;uui-icon slot=\"icon\" name=\"icon-edit\"&gt;&lt;/uui-icon&gt;\n                Content\n            &lt;/uui-tab&gt;\n            &lt;uui-tab\n                label=\"Destination\"\n                ?active=${this._activeTab === 'destination'}\n                orientation=\"horizontal\"\n                @click=${() =&gt; this.#handleTabClick('destination')}&gt;\n                &lt;uui-icon slot=\"icon\" name=\"icon-document\"&gt;&lt;/uui-icon&gt;\n                Destination\n            &lt;/uui-tab&gt;\n        &lt;/uui-tab-group&gt;\n    `;\n}\n\n#hasExtractedContent(): boolean {\n    return Object.keys(this._extractedSections).length &gt; 0;\n}\n</code></pre> <p>Tab content routing uses a switch statement:</p> <pre><code>#renderTabContent() {\n    switch (this._activeTab) {\n        case 'source':\n            return this.#renderSourceTab();\n        case 'content':\n            return this.#renderContentTab();\n        case 'destination':\n            return this.#renderDestinationTab();\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-modal-element/#dynamic-source-type-loading","title":"Dynamic source type loading","text":"<p>When the modal opens, it immediately fetches the workflow config via <code>fetchConfig()</code> to discover which source types have config files. The config is stored in <code>_config</code> for use by extraction and preview:</p> <pre><code>async #loadAvailableSourceTypes() {\n    this._loadingSourceTypes = true;\n    try {\n        const config = await fetchConfig(blueprintId, token);\n        if (config) {\n            this._config = config;\n            if (config.sources) {\n                this._availableSourceTypes = Object.keys(config.sources);\n                if (this._availableSourceTypes.length === 1) {\n                    this._sourceType = this._availableSourceTypes[0] as SourceType;\n                }\n            }\n        }\n    } finally {\n        this._loadingSourceTypes = false;\n    }\n}\n</code></pre> <p>The dropdown only shows source types that exist in the config's <code>sources</code> dictionary. This means if a workflow only has <code>source-pdf.json</code>, the user won't see Markdown, Web Page, or Word Document as options. Human-readable labels are mapped via <code>SOURCE_TYPE_LABELS</code>.</p>"},{"location":"source-files/up-doc-modal-element/#source-type-selection","title":"Source type selection","text":"<p>The <code>uui-select</code> dropdown shows \"Choose a source...\" when no source type is selected (only when multiple source types are available). When the user changes the source type, source-specific state is reset (selected media, URL, extracted sections, extraction error). The <code>_config</code> is preserved across source type changes since it was loaded once at startup.</p>"},{"location":"source-files/up-doc-modal-element/#conditional-source-ui-rendering","title":"Conditional source UI rendering","text":"<p>Each source type renders its own UI via <code>#renderSourceUI()</code>: - PDF (<code>#renderPdfSource()</code>) -- Media picker + extraction status (fully functional) - Markdown (<code>#renderMarkdownSource()</code>) -- Media picker + extraction status (fully functional, same pattern as PDF) - Web (<code>#renderWebSource()</code>) -- URL input + \"not yet available\" message - Doc (<code>#renderDocSource()</code>) -- Media picker + \"not yet available\" message</p>"},{"location":"source-files/up-doc-modal-element/#create-button-enablement","title":"Create button enablement","text":"<p>The <code>#getCanCreate()</code> method controls when the Create button is enabled: - Requires a document name and no active extraction - For PDF and Markdown: also requires a selected media item - For Web and Doc: always returns false (not yet functional)</p>"},{"location":"source-files/up-doc-modal-element/#modal-context-methods","title":"Modal context methods","text":"<pre><code>#handleSave() {\n    this.value = {\n        name: this._documentName,\n        sourceType: this._sourceType as SourceType,\n        mediaUnique: this._selectedMediaUnique,\n        sourceUrl: this._sourceUrl || null,\n        extractedSections: this._extractedSections,\n        config: this._config,\n    };\n    this._submitModal();\n}\n\n#handleClose() {\n    this._rejectModal();\n}\n</code></pre> <p>The <code>#handleSave</code> method returns <code>extractedSections</code> (element ID \u2192 text lookup) and <code>config</code> so the action has everything needed to apply mappings.</p>"},{"location":"source-files/up-doc-modal-element/#template-structure","title":"Template structure","text":"<p>The modal uses a tabbed interface with three tabs:</p>"},{"location":"source-files/up-doc-modal-element/#source-tab-default","title":"Source Tab (default)","text":"<ol> <li>Document Name box -- Text input with explanatory text</li> <li>Source box -- Contains a source type dropdown and conditional source-specific UI</li> </ol>"},{"location":"source-files/up-doc-modal-element/#content-tab","title":"Content Tab","text":"<ul> <li>Inner tabs matching the destination document's tab structure (Page Properties, Page Content, custom tabs)</li> <li>When only one tab has content, the tab bar is hidden</li> <li>Page Content items are sub-grouped by block with block name headers</li> <li>Mapped field cards -- Each destination field displayed as a card with:</li> <li>Header showing the human-readable destination field label (resolved from destination config)</li> <li>Body with assembled content from all mapped source elements (concatenated with spaces)</li> <li>Hover-reveal action bar with Copy button</li> <li>Empty state message when no mappings exist</li> </ul>"},{"location":"source-files/up-doc-modal-element/#destination-tab_1","title":"Destination Tab","text":"<ul> <li>Destination box -- Read-only display of:</li> <li>Document Type name with icon</li> <li>Blueprint name with icon</li> </ul> <p>Uses Umbraco's UI components: - <code>umb-body-layout</code> -- Standard modal layout with headline \"Create from Source\" - <code>uui-tab-group</code> -- Navigation tabs in the header (via <code>slot=\"navigation\"</code>) - <code>uui-tab</code> -- Individual tabs for Source, Content, and Destination - <code>uui-box</code> -- Content containers with headlines - <code>uui-select</code> -- Dropdown for choosing source type - <code>umb-property-layout</code> -- Form field wrapper with label - <code>umb-input-media</code> -- Media picker for selecting PDF/Doc - <code>umb-icon</code> -- Umbraco icons for document type and blueprint display - <code>uui-input</code> -- Text input for document name and URL - <code>uui-loader-bar</code> -- Loading indicator during extraction - <code>uui-icon</code> -- Status icons for success/error/info states - <code>uui-action-bar</code> -- Container for hover-reveal action buttons - <code>uui-button</code> -- Action buttons (Create, Close, Copy)</p>"},{"location":"source-files/up-doc-modal-element/#extraction-status-display","title":"Extraction status display","text":"<p>The modal shows visual feedback during and after extraction: - Extracting: Loading bar with \"Extracting content from source...\" message - Error: Red box with error message - Success: Green box with \"Content extracted successfully\"</p>"},{"location":"source-files/up-doc-modal-element/#imports","title":"Imports","text":"<pre><code>import type { UmbUpDocModalData, UmbUpDocModalValue, SourceType } from './up-doc-modal.token.js';\nimport type { DocumentTypeConfig } from './workflow.types.js';\nimport { transformAdhoc, allTransformSections, fetchConfig } from './workflow.service.js';\nimport { getDestinationTabs, resolveDestinationTab, resolveBlockLabel } from './destination-utils.js';\nimport { stripMarkdown } from './transforms.js';\nimport { html, customElement, css, state, nothing } from '@umbraco-cms/backoffice/external/lit';\nimport { UmbTextStyles } from '@umbraco-cms/backoffice/style';\nimport { UmbModalBaseElement } from '@umbraco-cms/backoffice/modal';\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\n</code></pre>"},{"location":"source-files/up-doc-modal-element/#global-declaration","title":"Global declaration","text":"<pre><code>declare global {\n    interface HTMLElementTagNameMap {\n        'up-doc-modal': UpDocModalElement;\n    }\n}\n</code></pre> <p>This provides TypeScript support when using <code>document.createElement('up-doc-modal')</code>.</p>"},{"location":"source-files/up-doc-modal-token/","title":"up-doc-modal.token.ts","text":"<p>Defines the modal token and TypeScript interfaces for type-safe modal communication.</p>"},{"location":"source-files/up-doc-modal-token/#what-it-does","title":"What it does","text":"<p>Creates a unique identifier (token) for the modal that:</p> <ol> <li>Links the modal manifest to the modal element</li> <li>Defines the data types for input and output</li> <li>Configures modal appearance (sidebar vs dialog, size)</li> </ol>"},{"location":"source-files/up-doc-modal-token/#types","title":"Types","text":"<pre><code>export type SourceType = 'pdf' | 'markdown' | 'web' | 'doc';\n</code></pre> <p>Defines the available source types for content extraction. <code>pdf</code> and <code>markdown</code> are fully functional; <code>web</code> and <code>doc</code> are UI placeholders.</p>"},{"location":"source-files/up-doc-modal-token/#the-interfaces","title":"The interfaces","text":"<pre><code>export interface UmbUpDocModalData {\n    unique: string | null;     // Parent document ID\n    documentTypeName: string;  // Display name of the document type\n    blueprintName: string;     // Display name of the selected blueprint\n    blueprintId: string;       // Blueprint GUID, used to fetch config\n}\n\nexport interface UmbUpDocModalValue {\n    name: string;                                    // The document name\n    sourceType: SourceType;                          // Which source type was selected\n    mediaUnique: string | null;                      // The selected media item's ID\n    sourceUrl: string | null;                        // The entered URL (for web source)\n    extractedSections: Record&lt;string, string&gt;;       // Extracted sections keyed by key\n    config: DocumentTypeConfig | null;               // Full config for property mapping\n}\n</code></pre> <p>The <code>UmbUpDocModalData</code> interface includes: - <code>blueprintId</code> so the modal can pass it to the <code>extractSections</code> API call, which needs it to look up the correct config files on the backend - <code>documentTypeName</code> and <code>blueprintName</code> for display on the Destination tab</p> <p>The <code>UmbUpDocModalValue</code> interface returns: - <code>extractedSections</code> -- a <code>Record&lt;string, string&gt;</code> containing all extracted values keyed by section key (from source.json) - <code>config</code> -- the full <code>DocumentTypeConfig</code> containing source, destination, and map configs so the action knows how to apply each section</p>"},{"location":"source-files/up-doc-modal-token/#the-token","title":"The token","text":"<pre><code>export const UMB_UP_DOC_MODAL = new UmbModalToken&lt;UmbUpDocModalData, UmbUpDocModalValue&gt;(\n    'UpDoc.Modal',  // Must match manifest alias\n    {\n        modal: {\n            type: 'sidebar',  // Opens as sidebar panel\n            size: 'small',    // Sidebar width\n        },\n    },\n);\n</code></pre>"},{"location":"source-files/up-doc-modal-token/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-modal-token/#umbmodaltoken","title":"UmbModalToken","text":"<p>A generic class that provides: - Type safety for <code>umbOpenModal()</code> calls - Configuration for how the modal appears - A unique string alias linking manifest to component</p>"},{"location":"source-files/up-doc-modal-token/#modal-types","title":"Modal types","text":"<ul> <li><code>'sidebar'</code> -- Slides in from the right (used here)</li> <li><code>'dialog'</code> -- Centered overlay dialog</li> </ul>"},{"location":"source-files/up-doc-modal-token/#sidebar-sizes","title":"Sidebar sizes","text":"<ul> <li><code>'small'</code> -- Narrow sidebar (used here)</li> <li><code>'medium'</code> -- Standard width</li> <li><code>'large'</code> -- Wide sidebar</li> <li><code>'full'</code> -- Full width</li> </ul>"},{"location":"source-files/up-doc-modal-token/#imports","title":"Imports","text":"<pre><code>import { UmbModalToken } from '@umbraco-cms/backoffice/modal';\nimport type { DocumentTypeConfig } from './workflow.types.js';\n</code></pre> <p>The <code>DocumentTypeConfig</code> type is imported from <code>workflow.types.js</code> for use in <code>UmbUpDocModalValue</code>.</p>"},{"location":"source-files/up-doc-modal-token/#usage","title":"Usage","text":"<p>When opening the modal:</p> <pre><code>import { UMB_UP_DOC_MODAL } from './up-doc-modal.token.js';\n\nconst value = await umbOpenModal(this, UMB_UP_DOC_MODAL, {\n    data: {\n        unique: parentId,\n        documentTypeName: 'Group Tour',\n        blueprintName: 'My Blueprint',\n        blueprintId: blueprintUnique,\n    },  // TypeScript knows this must be UmbUpDocModalData\n});\n// value is typed as UmbUpDocModalValue\n// Includes: name, sourceType, mediaUnique, sourceUrl, extractedSections, config\n</code></pre>"},{"location":"source-files/up-doc-pdf-picker-element/","title":"up-doc-pdf-picker.element.ts","text":"<p>PDF media picker with thumbnail preview. Replaces <code>umb-input-media</code> for PDF selection in the Create Workflow sidebar.</p>"},{"location":"source-files/up-doc-pdf-picker-element/#what-it-does","title":"What it does","text":"<p>Provides a complete pick-preview-remove flow for selecting a PDF from Umbraco's media library:</p> <ol> <li>Empty state \u2014 <code>&lt;uui-button look=\"placeholder\"&gt;</code> matching Umbraco's standard media picker \"Choose\" button</li> <li>After selection \u2014 <code>&lt;uui-card-media&gt;</code> with a real PDF page 1 thumbnail (rendered by <code>up-doc-pdf-thumbnail</code>) and the media item's file name</li> <li>Actions \u2014 Remove (trash icon) and Change (edit icon) in a <code>&lt;uui-action-bar&gt;</code> on the card</li> </ol>"},{"location":"source-files/up-doc-pdf-picker-element/#why-not-use-umb-input-media","title":"Why not use umb-input-media?","text":"<p><code>umb-input-media</code> uses <code>umb-imaging-thumbnail</code> which falls back to a generic icon for PDFs \u2014 there's no visual preview. By building our own picker, we can inject a real PDF page render via <code>up-doc-pdf-thumbnail</code> while keeping all other behaviour (media picker modal, card layout, action buttons) consistent with Umbraco's patterns.</p>"},{"location":"source-files/up-doc-pdf-picker-element/#how-it-works","title":"How it works","text":"<ol> <li>Choose button \u2014 opens <code>UMB_MEDIA_PICKER_MODAL</code> via <code>UMB_MODAL_MANAGER_CONTEXT</code> (standard Umbraco media picker)</li> <li>On selection \u2014 stores the media key, fetches the media item name via <code>GET /umbraco/management/api/v1/media/item?id={guid}</code></li> <li>Thumbnail render \u2014 passes the media key and auth token to <code>&lt;up-doc-pdf-thumbnail&gt;</code> which handles PDF.js rendering</li> <li>Events \u2014 dispatches <code>CustomEvent('change', { detail: { mediaKey } })</code> on selection or removal</li> </ol>"},{"location":"source-files/up-doc-pdf-picker-element/#uui-patterns-used","title":"UUI patterns used","text":"Component Usage <code>uui-button look=\"placeholder\"</code> Empty state \"Choose\" button \u2014 matches <code>umb-input-media</code>'s add button <code>uui-card-media</code> Card wrapper with name label \u2014 matches media library cards <code>uui-action-bar slot=\"actions\"</code> Hover action buttons on the card <code>uui-icon</code> Icons for add, trash, edit actions"},{"location":"source-files/up-doc-pdf-picker-element/#registered-in","title":"Registered in","text":"<ul> <li>Not registered in <code>manifest.ts</code> \u2014 imported directly by <code>create-workflow-sidebar.element.ts</code></li> </ul>"},{"location":"source-files/up-doc-pdf-picker-element/#used-by","title":"Used by","text":"<ul> <li><code>create-workflow-sidebar.element.ts</code> \u2014 PDF source type section</li> </ul>"},{"location":"source-files/up-doc-pdf-thumbnail-element/","title":"up-doc-pdf-thumbnail.element.ts","text":"<p>Renders a single PDF page as an image thumbnail using PDF.js. Used inside <code>uui-card-media</code> and other components that need a visual preview of a PDF page.</p>"},{"location":"source-files/up-doc-pdf-thumbnail-element/#what-it-does","title":"What it does","text":"<p>Given a media key and page number, fetches the PDF from the UpDoc API, renders the specified page to an offscreen canvas using PDF.js, then converts it to a PNG data URL via <code>canvas.toDataURL('image/png')</code>. The result is a standard <code>&lt;img&gt;</code> element that works anywhere \u2014 no visible canvas in the DOM.</p>"},{"location":"source-files/up-doc-pdf-thumbnail-element/#how-the-canvas-to-image-technique-works","title":"How the canvas-to-image technique works","text":"<p>This is the key architectural decision that makes PDF thumbnails work inside Umbraco's existing components:</p> <ol> <li>Fetch PDF bytes \u2014 calls <code>GET /updoc/workflows/media-pdf?mediaKey={guid}</code> with auth token</li> <li>Load into PDF.js \u2014 <code>pdfjsLib.getDocument({ data: arrayBuffer })</code> returns a <code>PDFDocumentProxy</code></li> <li>Get page \u2014 <code>pdfDoc.getPage(pageNumber)</code> returns a <code>PDFPageProxy</code></li> <li>Create offscreen canvas \u2014 <code>document.createElement('canvas')</code> (never added to the DOM)</li> <li>Render to offscreen canvas \u2014 <code>pdfPage.render({ canvasContext, viewport })</code> draws the PDF page at the desired scale</li> <li>Convert to data URL \u2014 <code>offscreenCanvas.toDataURL('image/png')</code> produces a <code>data:image/png;base64,...</code> string</li> <li>Render as <code>&lt;img&gt;</code> \u2014 the data URL is a standard image source that works in any <code>&lt;img&gt;</code> tag, <code>uui-card-media</code>, or anywhere else</li> </ol> <p>This approach means Umbraco components like <code>uui-card-media</code> see a normal image \u2014 no shadow DOM hacking, no custom slots, no special integration needed. The PDF rendering is entirely invisible to the consuming component.</p>"},{"location":"source-files/up-doc-pdf-thumbnail-element/#caching","title":"Caching","text":"<ul> <li>PDF documents are cached in a module-level <code>Map&lt;string, PDFDocumentProxy&gt;</code> keyed by media key. Fetching the same PDF twice reuses the loaded document.</li> <li>Rendered images are not cached separately \u2014 each render produces a new data URL. This is acceptable because the offscreen canvas render is fast (~50ms) compared to the PDF fetch.</li> </ul>"},{"location":"source-files/up-doc-pdf-thumbnail-element/#concurrency-protection","title":"Concurrency protection","text":"<p>PDF.js throws if <code>pdfPage.render()</code> is called while another render is in progress on the same canvas. The component handles this with:</p> <ul> <li><code>_currentRenderTask</code> \u2014 tracks the active <code>RenderTask</code>, cancelled before starting a new render</li> <li><code>_rendering</code> boolean guard \u2014 prevents overlapping async calls</li> <li>Render only triggers on property changes (<code>mediaKey</code>, <code>page</code>, <code>token</code>), not on internal state changes (<code>_loading</code>, <code>_error</code>)</li> </ul>"},{"location":"source-files/up-doc-pdf-thumbnail-element/#properties","title":"Properties","text":"Property Type Default Description <code>mediaKey</code> <code>String</code> <code>''</code> Umbraco media item GUID <code>page</code> <code>Number</code> <code>1</code> Page number to render (1-based) <code>width</code> <code>Number</code> <code>300</code> Render width in pixels (aspect ratio preserved) <code>token</code> <code>String</code> <code>''</code> Bearer auth token for the PDF fetch"},{"location":"source-files/up-doc-pdf-thumbnail-element/#render-states","title":"Render states","text":"<ul> <li>Loading \u2014 <code>&lt;uui-loader-bar&gt;</code> shown while fetching/rendering</li> <li>Error \u2014 icon + message (e.g., \"Page 5 out of range (1-4)\")</li> <li>Ready \u2014 <code>&lt;img&gt;</code> with the rendered PDF page</li> </ul>"},{"location":"source-files/up-doc-pdf-thumbnail-element/#api-dependency","title":"API dependency","text":"<p>Requires the <code>GET /updoc/workflows/media-pdf</code> endpoint (added in this feature) which serves raw PDF bytes by media key. This endpoint exists because during Create Workflow, no workflow folder exists yet \u2014 so the existing workflow-based PDF endpoint can't be used.</p>"},{"location":"source-files/up-doc-pdf-thumbnail-element/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-pdf-picker.element.ts</code> \u2014 single page preview inside <code>uui-card-media</code></li> <li>Future: page picker sidebar (grid of all pages with checkboxes)</li> </ul>"},{"location":"source-files/up-doc-usync-fallback-condition/","title":"up-doc-usync-fallback.condition.ts","text":"<p>Custom Umbraco condition that permits when uSync is NOT installed. Used to control fallback sidebar group visibility.</p>"},{"location":"source-files/up-doc-usync-fallback-condition/#what-it-does","title":"What it does","text":"<p>Observes the Umbraco extension registry for <code>menu</code> type extensions. If <code>usync.menu</code> is found, the condition is NOT permitted (uSync is present, so UpDoc joins uSync's group). If <code>usync.menu</code> is absent, the condition IS permitted (UpDoc creates its own \"Synchronisation\" sidebar group).</p>"},{"location":"source-files/up-doc-usync-fallback-condition/#how-it-works","title":"How it works","text":"<pre><code>export class UpDocUsyncFallbackCondition\n    extends UmbConditionBase&lt;UmbConditionConfigBase&gt;\n    implements UmbExtensionCondition\n{\n    constructor(host, args) {\n        super(host, args);\n        this.observe(\n            umbExtensionsRegistry.byType('menu'),\n            (menus) =&gt; {\n                const hasUsync = menus.some((m) =&gt; m.alias === 'usync.menu');\n                this.permitted = !hasUsync;\n            },\n            'upDocUsyncCheck',\n        );\n    }\n}\n</code></pre> <p>Key pattern: Extends <code>UmbConditionBase</code> (not <code>UmbControllerBase</code>). Uses <code>this.observe()</code> on the extension registry observable for reactive updates. The <code>permitted</code> setter automatically notifies the framework when the value changes.</p>"},{"location":"source-files/up-doc-usync-fallback-condition/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> as <code>UpDoc.Condition.UsyncNotInstalled</code></li> <li>Applied to the fallback <code>sectionSidebarApp</code> (<code>UpDoc.SidebarApp</code>)</li> </ul>"},{"location":"source-files/up-doc-usync-fallback-condition/#used-by","title":"Used by","text":"<ul> <li><code>manifest.ts</code> \u2014 conditions array on the fallback sidebar group. When uSync IS installed, this condition blocks the fallback, preventing a duplicate \"Synchronisation\" header.</li> </ul>"},{"location":"source-files/up-doc-usync-fallback-condition/#future-improvement","title":"Future improvement","text":"<p>Currently hardcodes <code>usync.menu</code> as the check. A future enhancement would dynamically discover ANY existing \"Synchronisation\" sidebar group by label, making it package-agnostic. See <code>planning/DYNAMIC_SIDEBAR_GROUP.md</code>.</p>"},{"location":"source-files/up-doc-workflow-destination-view-element/","title":"up-doc-workflow-destination-view.element.ts","text":"<p>Workspace view for the Destination tab of a workflow. Displays the blueprint's fields and block grids organised by inner tabs (Page Properties, Page Content).</p>"},{"location":"source-files/up-doc-workflow-destination-view-element/#what-it-does","title":"What it does","text":"<p>Renders a read-only view of the workflow's destination configuration \u2014 the blueprint fields that content will be mapped into. Fields are grouped by their tab assignment (e.g. \"Page Properties\") and block grids appear under \"Page Content\".</p>"},{"location":"source-files/up-doc-workflow-destination-view-element/#how-it-works","title":"How it works","text":"<ol> <li>On <code>connectedCallback</code>, consumes <code>UMB_WORKSPACE_CONTEXT</code> and observes the <code>unique</code> value</li> <li>When <code>unique</code> changes, calls <code>fetchWorkflowByName()</code> to load the workflow configuration</li> <li>Uses <code>getDestinationTabs()</code> from <code>destination-utils.ts</code> to build inner tabs (shared logic with Map view and Content tab)</li> <li>If block grids exist and there's no explicit \"Page Content\" tab, adds one automatically (handled by the shared utility)</li> <li>Renders using Umbraco's native <code>umb-body-layout</code> + <code>uui-tab-group</code> + <code>uui-tab</code> pattern</li> </ol>"},{"location":"source-files/up-doc-workflow-destination-view-element/#tab-structure","title":"Tab structure","text":"<pre><code>umb-body-layout (header-fit-height)\n\u251c\u2500\u2500 uui-tab-group (slot=\"header\")\n\u2502   \u251c\u2500\u2500 uui-tab \"Page Properties\"\n\u2502   \u2514\u2500\u2500 uui-tab \"Page Content\"\n\u2514\u2500\u2500 uui-box\n    \u2514\u2500\u2500 (tab content: fields or block grids)\n</code></pre> <p>The inner tabs follow Umbraco's content-area tab pattern (as seen in the Document Type editor and Content editor). The <code>uui-tab</code> elements require both a <code>label</code> attribute and text content inside the element for the label to render visibly.</p>"},{"location":"source-files/up-doc-workflow-destination-view-element/#field-rendering","title":"Field rendering","text":"<p>Each field displays:</p> <ul> <li>Label (bold) + type badge (e.g. \"Umbraco.TextBox\") + Required tag if mandatory</li> <li>Alias (monospace) + description (if present)</li> </ul>"},{"location":"source-files/up-doc-workflow-destination-view-element/#block-grid-rendering","title":"Block grid rendering","text":"<p>Block grids show:</p> <ul> <li>Grid header with label and alias</li> <li>Each block with icon, label, and \"identified by\" hint</li> <li>Block properties with label, type badge, and accepted formats</li> </ul>"},{"location":"source-files/up-doc-workflow-destination-view-element/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-workflow-destination-view-element/#inner-tabs-vs-workspace-tabs","title":"Inner tabs vs workspace tabs","text":"<p>This view has its own internal tab bar (Page Properties / Page Content) which is separate from the top-level workspace view tabs (Destination / Markdown / Pdf). The inner tabs use <code>umb-body-layout header-fit-height</code> with <code>uui-tab-group slot=\"header\"</code>, while the workspace tabs are managed by <code>umb-workspace-editor</code>.</p>"},{"location":"source-files/up-doc-workflow-destination-view-element/#uui-tab-rendering","title":"uui-tab rendering","text":"<p>The <code>uui-tab</code> element requires text content inside it (<code>${tab.label}</code>) in addition to the <code>label</code> attribute for the text to be visible when rendered inside <code>umb-body-layout</code>. This is a key implementation detail.</p>"},{"location":"source-files/up-doc-workflow-destination-view-element/#imports","title":"Imports","text":"<pre><code>import type { DocumentTypeConfig, DestinationField, DestinationBlockGrid } from './workflow.types.js';\nimport { fetchWorkflowByName } from './workflow.service.js';\nimport { getDestinationTabs } from './destination-utils.js';\nimport { html, customElement, css, state, nothing } from '@umbraco-cms/backoffice/external/lit';\nimport { UmbLitElement } from '@umbraco-cms/backoffice/lit-element';\nimport { UmbTextStyles } from '@umbraco-cms/backoffice/style';\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\nimport { UMB_WORKSPACE_CONTEXT } from '@umbraco-cms/backoffice/workspace';\n</code></pre>"},{"location":"source-files/up-doc-workflow-destination-view-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 registered as a <code>workspaceView</code> with alias <code>UpDoc.WorkflowWorkspaceView.Destination</code>, weight 300 (leftmost tab)</li> <li>Conditioned on <code>Umb.Condition.WorkspaceAlias</code> matching <code>UpDoc.WorkflowWorkspace</code></li> </ul>"},{"location":"source-files/up-doc-workflow-destination-view-element/#used-by","title":"Used by","text":"<ul> <li>Displayed as the \"Destination\" tab when viewing an individual workflow in the workflow workspace</li> </ul>"},{"location":"source-files/up-doc-workflow-detail-modal-element/","title":"up-doc-workflow-detail-modal.element.ts","text":"<p>Read-only sidebar modal that displays the full configuration of an UpDoc workflow. Opened by clicking a workflow row in the workflows view.</p>"},{"location":"source-files/up-doc-workflow-detail-modal-element/#what-it-does","title":"What it does","text":"<p>Displays a two-level tab structure showing destination configuration and source extraction rules for a workflow:</p> <ul> <li>Top-level tabs (workspace-style with icons): Destination + one tab per source type (e.g. Markdown, PDF)</li> <li>Inner tabs within Destination (content-area style): dynamically generated from document type field tab groupings (e.g. \"Page Properties\", \"Page Content\")</li> </ul>"},{"location":"source-files/up-doc-workflow-detail-modal-element/#how-it-works","title":"How it works","text":"<ol> <li>Receives workflow name via modal data</li> <li>Fetches full workflow config from <code>GET /umbraco/management/api/v1/updoc/workflows/{name}</code> via <code>fetchWorkflowByName()</code></li> <li>Renders destination fields with type badges, block grid configuration, and source extraction sections with strategy badges</li> </ol>"},{"location":"source-files/up-doc-workflow-detail-modal-element/#tab-structure","title":"Tab structure","text":""},{"location":"source-files/up-doc-workflow-detail-modal-element/#destination-tab","title":"Destination tab","text":"<p>Groups fields by their tab membership in the document type:</p> <ul> <li>Shows each field with its alias, type badge, and mapped status</li> <li>Block grid fields expand to show their block types and properties</li> <li>Fields that are mapped show their mapping source key</li> </ul>"},{"location":"source-files/up-doc-workflow-detail-modal-element/#source-tabs-one-per-source-type","title":"Source tabs (one per source type)","text":"<p>Each source tab shows:</p> <ul> <li>Extraction sections with strategy badges (e.g. \"largestFont\", \"regex\", \"betweenPatterns\")</li> <li>Strategy parameters displayed as key-value pairs in a monospace code block</li> <li>Output format and page range metadata</li> </ul>"},{"location":"source-files/up-doc-workflow-detail-modal-element/#key-css-classes","title":"Key CSS classes","text":"<ul> <li><code>.field-type</code> \u2014 neutral badge for property editor type (uses <code>--uui-color-text-alt</code> on <code>--uui-color-surface-alt</code>)</li> <li><code>.section-strategy</code> \u2014 neutral badge for extraction strategy (uses same neutral style)</li> <li><code>.strategy-params</code> \u2014 monospace parameter display area</li> </ul>"},{"location":"source-files/up-doc-workflow-detail-modal-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 registered as a <code>modal</code> with alias <code>UpDoc.WorkflowDetailModal</code></li> </ul>"},{"location":"source-files/up-doc-workflow-detail-modal-element/#used-by","title":"Used by","text":"<ul> <li>Opened from <code>up-doc-workflows-view.element.ts</code> when a workflow row is clicked</li> </ul>"},{"location":"source-files/up-doc-workflow-detail-modal-token/","title":"up-doc-workflow-detail-modal.token.ts","text":"<p>Modal token definition for the Workflow Detail sidebar modal.</p>"},{"location":"source-files/up-doc-workflow-detail-modal-token/#what-it-does","title":"What it does","text":"<p>Defines the data and return value types for the read-only workflow detail modal, and exports the modal token used to open it.</p>"},{"location":"source-files/up-doc-workflow-detail-modal-token/#interfaces","title":"Interfaces","text":""},{"location":"source-files/up-doc-workflow-detail-modal-token/#workflowdetailmodaldata","title":"WorkflowDetailModalData","text":"<pre><code>interface WorkflowDetailModalData {\n    workflowName: string; // The workflow folder name to display\n}\n</code></pre>"},{"location":"source-files/up-doc-workflow-detail-modal-token/#workflowdetailmodalvalue","title":"WorkflowDetailModalValue","text":"<p>Empty \u2014 the modal is read-only and returns no data.</p>"},{"location":"source-files/up-doc-workflow-detail-modal-token/#token","title":"Token","text":"<pre><code>export const UMB_WORKFLOW_DETAIL_MODAL = new UmbModalToken&lt;WorkflowDetailModalData, never&gt;(\n    'UpDoc.WorkflowDetailModal',\n    { modal: { type: 'sidebar', size: 'medium' } },\n);\n</code></pre>"},{"location":"source-files/up-doc-workflow-detail-modal-token/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-workflows-view.element.ts</code> \u2014 opens the modal when a workflow row is clicked</li> <li><code>up-doc-workflow-detail-modal.element.ts</code> \u2014 implements the modal UI</li> </ul>"},{"location":"source-files/up-doc-workflow-map-view-element/","title":"up-doc-workflow-map-view.element.ts","text":"<p>Workspace view for the Map tab of a workflow. Displays all source-to-destination mappings from <code>map.json</code>, grouped by destination tab structure.</p>"},{"location":"source-files/up-doc-workflow-map-view-element/#what-it-does","title":"What it does","text":"<p>Renders the current mapping configuration \u2014 showing which source extraction elements are wired to which destination fields. Mappings are grouped by destination tab (Page Properties, Page Content) and sub-grouped by block within Page Content. Provides a visual overview of all mappings and allows deletion of individual mappings.</p>"},{"location":"source-files/up-doc-workflow-map-view-element/#how-it-works","title":"How it works","text":"<ol> <li>On <code>connectedCallback</code>, consumes <code>UMB_WORKSPACE_CONTEXT</code> and observes the <code>unique</code> value</li> <li>When <code>unique</code> changes, calls <code>fetchWorkflowByName()</code> to load the workflow configuration (includes map.json and destination.json)</li> <li>Also loads the sample extraction via <code>fetchSampleExtraction()</code> to resolve source element IDs to text previews</li> <li>Groups mappings by destination tab using <code>resolveDestinationTab()</code> from <code>destination-utils.ts</code>, then sub-groups Page Content mappings by block using <code>resolveBlockLabel()</code></li> <li>Renders each group as a section with a header and its own <code>uui-table</code></li> <li>Delete button removes a mapping and saves via <code>saveMapConfig()</code> PUT endpoint</li> </ol>"},{"location":"source-files/up-doc-workflow-map-view-element/#grouped-sections","title":"Grouped sections","text":"<p>Mappings are organised into sections matching the destination document's tab structure:</p> <ul> <li>Page Properties \u2014 top-level fields like Page Title, Page Description</li> <li>Page Content \u2014 [Block Label] \u2014 block properties grouped by block (e.g., \"Page Content \u2014 Features\", \"Page Content \u2014 Accommodation\")</li> <li>Unmapped \u2014 orphaned mappings whose destination target no longer exists in <code>destination.json</code></li> </ul> <p>Each section has a header with the group name and a mapping count badge. Groups are ordered to match <code>getDestinationTabs()</code> output, with Unmapped at the bottom.</p>"},{"location":"source-files/up-doc-workflow-map-view-element/#empty-state","title":"Empty state","text":"<p>When no mappings exist, shows a centred message: \"No mappings yet. Use the Source tab to map extracted content to destination fields.\"</p>"},{"location":"source-files/up-doc-workflow-map-view-element/#mapping-row-rendering","title":"Mapping row rendering","text":"<p>Each row displays:</p> <ul> <li>Source: Element ID (monospace) + text preview (truncated to 60 chars)</li> <li>Arrow: Visual indicator</li> <li>Destination: Resolved field label (from destination.json), with block path for block properties</li> <li>Actions: Disabled badge (if mapping disabled) + delete button</li> </ul>"},{"location":"source-files/up-doc-workflow-map-view-element/#label-resolution","title":"Label resolution","text":"<ul> <li>Destination labels: Resolved from <code>destination.json</code> via <code>#resolveDestinationLabel(dest)</code> which accepts a <code>MappingDestination</code> object. When <code>blockKey</code> is present, finds the specific block by key for an accurate label. Otherwise checks top-level fields first, then falls back to first block match (backwards compat for old mappings). Block properties display as \"Block Label &gt; Property Label\".</li> <li>Source text: Resolved from <code>sample-extraction.json</code> by matching element ID</li> </ul>"},{"location":"source-files/up-doc-workflow-map-view-element/#imports","title":"Imports","text":"<pre><code>import type { DocumentTypeConfig, SectionMapping, MappingDestination, RichExtractionResult } from './workflow.types.js';\nimport { fetchWorkflowByName, fetchSampleExtraction, saveMapConfig } from './workflow.service.js';\nimport { getDestinationTabs, resolveDestinationTab, resolveBlockLabel } from './destination-utils.js';\nimport { html, customElement, css, state, nothing } from '@umbraco-cms/backoffice/external/lit';\nimport { UmbLitElement } from '@umbraco-cms/backoffice/lit-element';\nimport { UmbTextStyles } from '@umbraco-cms/backoffice/style';\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\nimport { UMB_WORKSPACE_CONTEXT } from '@umbraco-cms/backoffice/workspace';\n</code></pre>"},{"location":"source-files/up-doc-workflow-map-view-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 registered as a <code>workspaceView</code> with alias <code>UpDoc.WorkflowWorkspaceView.Map</code>, weight 100 (rightmost tab)</li> <li>Conditioned on <code>Umb.Condition.WorkspaceAlias</code> matching <code>UpDoc.WorkflowWorkspace</code></li> </ul>"},{"location":"source-files/up-doc-workflow-map-view-element/#used-by","title":"Used by","text":"<ul> <li>Displayed as the \"Map\" tab when viewing an individual workflow in the workflow workspace</li> </ul>"},{"location":"source-files/up-doc-workflow-source-view-element/","title":"up-doc-workflow-source-view.element.ts","text":"<p>Workspace view for the Source tab in the workflow workspace. Displays extracted content and the transformed content view for all three source types (PDF, Markdown, Web).</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#what-it-does","title":"What it does","text":"<p>Displays the sample extraction for a workflow in two modes:</p> <ul> <li>Extracted \u2014 for PDF: area detection hierarchy showing pages, areas (colour-coded), sections (with headings), and individual text elements with metadata. For Markdown/Web: flat element list with metadata badges.</li> <li>Transformed \u2014 assembled sections with pattern detection (bullet list, paragraph, sub-headed, preamble). For PDF: includes mapping controls. For Markdown/Web: read-only preview of heading-grouped sections rendered as HTML.</li> </ul> <p>All three source types share the same Extracted/Transformed tab pair and info box layout for a consistent user experience. PDF uses a rich four-level hierarchy with area detection; Markdown and Web use a simpler flat element display on the Extracted tab but share the same Transformed tab rendering.</p> <p>Users can include/exclude sections (via toggle), include/exclude pages, map sections to destination fields, collapse/expand any level, and re-extract from a different source.</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#how-it-works","title":"How it works","text":""},{"location":"source-files/up-doc-workflow-source-view-element/#layout-pattern","title":"Layout pattern","text":"<p>Uses <code>umb-body-layout header-fit-height</code> with a single <code>slot=\"header\"</code> div containing <code>uui-tab-group</code> for view switching (Extracted / Transformed). Info boxes and content are in the scrollable area below.</p> <pre><code>&lt;umb-body-layout header-fit-height&gt;\n    &lt;div slot=\"header\" class=\"source-header\"&gt;\n        &lt;uui-tab-group&gt;&lt;!-- Extracted / Transformed --&gt;&lt;/uui-tab-group&gt;\n    &lt;/div&gt;\n    &lt;div class=\"info-boxes\"&gt;&lt;!-- uui-box cards: Source, Pages, Areas, Sections --&gt;&lt;/div&gt;\n    &lt;div class=\"collapse-row\"&gt;&lt;!-- Collapse All button, right-aligned --&gt;&lt;/div&gt;\n    &lt;!-- scrollable content --&gt;\n&lt;/umb-body-layout&gt;\n</code></pre>"},{"location":"source-files/up-doc-workflow-source-view-element/#info-boxes-usync-inspired","title":"Info boxes (uSync-inspired)","text":"<p>Four equal-width <code>&lt;uui-box&gt;</code> cards in a flex row with <code>flex-grow: 1</code>, following the uSync dashboard pattern. Each box uses the <code>headline</code> attribute for its title label.</p> <ol> <li>Source \u2014 h2 filename, document icon, extraction date, Re-extract and Change PDF buttons</li> <li>Pages \u2014 stat number (e.g., \"2 of 4\" or \"All\"), \"Choose Pages\" button opens page picker modal</li> <li>Areas \u2014 stat number, \"Edit Areas\" or \"Define Areas\" button opens area editor modal</li> <li>Sections \u2014 stat number, \"Edit Sections\" button that opens a section picker popover listing all transform sections. Each menu item shows <code>icon-check</code> (green) if the section already has rules, or <code>icon-thumbnail-list</code> (default) if not. Clicking a section opens the Section Rules Editor modal.</li> </ol> <p>All boxes use equal-height layout via <code>min-height: 180px</code> on <code>.box-content</code> with <code>margin-top: auto</code> on <code>.box-buttons</code> to pin buttons to the bottom. Stat numbers are vertically centred using flex. All buttons use <code>color=\"default\"</code> for consistent styling.</p> <p>The Collapse All / Expand All button sits in its own row below the boxes, right-aligned.</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#page-selection","title":"Page selection","text":"<p>Users can filter which PDF pages are extracted. Stored in <code>source.json</code> as a <code>pages</code> array of page numbers. Page selection is managed via the \"Choose Pages\" button in the Pages info box, which opens a page picker modal. Selection is saved immediately and applied on next re-extract.</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#data-loading","title":"Data loading","text":"<p>On load, the component:</p> <ol> <li>Consumes <code>UMB_WORKSPACE_CONTEXT</code> and observes the <code>unique</code> value (workflow name)</li> <li>For PDF sources: loads in parallel \u2014 sample extraction, area detection, workflow config, transform result, source config. Initialises page selection state from source config. If sample extraction and area detection exist, automatically triggers a fresh transform to ensure data is current.</li> <li>For Markdown/Web sources: loads sample extraction, workflow config, and transform result (auto-generated during extraction by the backend). No area detection or page selection.</li> <li>Stores all in state for rendering</li> </ol>"},{"location":"source-files/up-doc-workflow-source-view-element/#extracted-mode-area-detection-hierarchy","title":"Extracted mode (area detection hierarchy)","text":"<p>Elements are displayed in a four-level collapsible hierarchy:</p> <ol> <li>Page \u2014 <code>uui-box</code> with \"Page N\" headline, section/area counts, page include toggle, and collapse chevron in <code>header-actions</code> slot. Excluded pages are dimmed.</li> <li>Area \u2014 colour-coded left border with area name label, section count, and collapse chevron. Areas with rules show an \"N rules\" badge and \"Edit Rules\" button. Areas without rules show a \"Flat\"/\"Configured\" structure badge and \"Define Structure\"/\"Redefine\" button plus an include/exclude toggle. For areas with rules, composed sections from the transform pipeline are rendered instead of raw elements, showing role name, content preview, and mapping status badges.</li> <li>Section \u2014 structural label \"Section \u2013 {name}\" with include/exclude toggle, element count, and collapse chevron. The heading text from the PDF is rendered as the first child element (with a HEADING badge), not as the section header itself. This separates our structural UI from the actual PDF content. Preamble sections (no heading) show \"Content\" as the structural label.</li> <li>Element \u2014 individual elements with semantic role badge (Heading/List Item/Paragraph), font size, font name, and colour badges.</li> </ol>"},{"location":"source-files/up-doc-workflow-source-view-element/#collapse-behaviour","title":"Collapse behaviour","text":"<p>All four levels are collapsible via a consistent chevron icon (<code>icon-navigation-right</code> when collapsed, <code>icon-navigation-down</code> when expanded). The chevron is always the rightmost element in each row.</p> <p>State is managed by a single <code>_collapsed</code> Set with key prefixes: - Pages: <code>page-${pageNum}</code> - Areas: <code>area-p${pageNum}-a${areaIndex}</code> or <code>area-p${pageNum}-undefined</code> - Sections: <code>p${pageNum}-a${areaIndex}-s${sIdx}</code></p> <p>A Collapse dropdown (using <code>uui-button</code> + <code>uui-popover-container</code> + <code>uui-menu-item</code>, matching Umbraco's \"Create\" dropdown pattern) provides per-level toggle controls:</p> <ul> <li>Expand All \u2014 opens everything</li> <li>Collapse/Expand Pages \u2014 toggles all page-level items</li> <li>Collapse/Expand Areas \u2014 toggles all area-level items</li> <li>Collapse/Expand Sections \u2014 toggles all section-level items</li> </ul> <p>Each label dynamically flips based on current state (e.g., \"Collapse Areas\" \u2192 \"Expand Areas\" when all areas are collapsed). The include/exclude toggle uses <code>@click stopPropagation</code> to prevent also triggering collapse.</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#transformed-mode","title":"Transformed mode","text":"<p>Shows assembled sections from the transform pipeline as individual <code>uui-box</code> cards:</p> <ul> <li>Each section is a <code>uui-box</code> with the section heading as the headline</li> <li>Simple sections (heading-only or duplicate heading/content): one body row with rendered Markdown content on the left and mapping badge + Map button on the right</li> <li>Multi-part sections (heading + any content): separate rows within the box for title and content, each with its own badge + Map button, separated by horizontal border lines. Any section with both a heading and content gets a separate title row for independent mapping, regardless of content complexity.</li> <li>Content text is clamped to <code>max-width: 75ch</code> for comfortable reading line length; badges and Map buttons are right-aligned via <code>margin-left: auto</code> on <code>.md-part-actions</code></li> <li>Map buttons are hidden by default and appear on box hover (like Umbraco's block grid editor)</li> <li>Mapped sections show a green left border and green <code>uui-tag</code> badges with an \"x\" button to unmap directly</li> <li>Markdown content is rendered as HTML via <code>markdownToHtml()</code> \u2014 headings, bullet lists, blockquotes, and inline formatting are all visible</li> </ul>"},{"location":"source-files/up-doc-workflow-source-view-element/#section-rules-editing","title":"Section rules editing","text":"<p>The \"Edit Sections\" button in the Sections info box opens a popover section picker. The picker lists all transform sections (built from area detection data) as <code>uui-menu-item</code> entries. Selecting a section opens the <code>UMB_SECTION_RULES_EDITOR_MODAL</code> sidebar, passing the section's elements from area detection. When the modal returns saved rules, they're persisted via the <code>saveSectionRules()</code> API.</p> <p>The section-to-element lookup walks area detection pages to find elements belonging to each transform section, matching by section ID (kebab-case for headed sections, <code>preamble-p{page}-a{area}</code> for preamble sections).</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#mapping","title":"Mapping","text":"<p>From the Transformed view, users can map section parts (title, content, description, summary) to destination fields. Each mappable part has its own Map button that opens <code>UMB_DESTINATION_PICKER_MODAL</code>. Results are saved to <code>map.json</code> using source keys in the format <code>${sectionId}.${partSuffix}</code> (e.g., <code>features.title</code>, <code>features.content</code>). Mapped parts show green <code>uui-tag</code> badges with an \"x\" button for inline unmapping. Mapped sections get a green left border on the <code>uui-box</code>.</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#non-pdf-render-path-markdownweb","title":"Non-PDF render path (Markdown/Web)","text":"<p>For markdown and web source types, the component uses the same <code>umb-body-layout</code> with <code>#renderExtractionHeader()</code> for tab switching. Key differences from PDF:</p> <ul> <li>Info boxes: <code>#renderNonPdfInfoBoxes()</code> renders 4 boxes \u2014 a functional Source box (filename/URL, extraction date, Change file/Re-extract button) plus 3 placeholder boxes (\"Box 1\", \"Box 2\", \"Box 3\") reserved for future features.</li> <li>Extracted tab: <code>#renderSimpleElements()</code> shows a flat list of extracted elements with metadata badges (font name, font size, colour).</li> <li>Transformed tab: <code>#renderTransformed()</code> / <code>#buildFullMarkdown()</code> renders the auto-generated transform result as HTML sections \u2014 identical rendering to PDF's Transformed view.</li> <li>Extraction flow: After extraction, the backend auto-generates <code>transform.json</code> (deterministic heading-based grouping), which the frontend immediately fetches so the Transformed tab is populated without a separate trigger step.</li> </ul>"},{"location":"source-files/up-doc-workflow-source-view-element/#empty-state","title":"Empty state","text":"<p>When no sample extraction exists, shows a source-appropriate empty state: - PDF: centered prompt with \"Choose PDF\" button - Markdown: file picker prompt - Web: URL input field with \"Extract\" button, plus file upload fallback</p>"},{"location":"source-files/up-doc-workflow-source-view-element/#key-methods","title":"Key methods","text":"Method Purpose <code>#loadData()</code> Loads extraction, area detection, config, transform, source config in parallel <code>#parsePageRange(input)</code> Converts \"1-3, 5\" to <code>[1, 2, 3, 5]</code> <code>#pagesToRangeString(pages)</code> Converts <code>[1, 2, 3, 5]</code> to \"1-3, 5\" <code>#togglePage(pageNum)</code> Toggles a page on/off and updates the range input <code>#savePageSelection()</code> Persists page selection to source.json <code>#onReExtract()</code> Re-extracts using previously stored media key <code>#onPickMedia()</code> Opens media picker, runs extraction on selected PDF <code>#isCollapsed(key)</code> Checks if a page/area/section is collapsed <code>#toggleCollapse(key)</code> Toggles collapse state for any level <code>#getKeysForLevel(level)</code> Returns all collapse keys for a given level (pages/areas/sections) <code>#isLevelCollapsed(level)</code> Checks if all items at a level are currently collapsed <code>#toggleLevel(level)</code> Toggles all items at a given level (collapse \u2194 expand) <code>#expandAll()</code> Expands everything (clears collapsed set) <code>#onEditAreas()</code> Opens area editor modal for defining/editing extraction areas <code>#getTransformSectionsWithElements()</code> Builds list of transform sections with their area detection elements for the section picker <code>#findElementsForSection(sectionId)</code> Walks area detection pages to find elements matching a transform section by ID <code>#buildPreambleId(pageNum, areaIdx)</code> Constructs preamble section IDs matching the transform convention <code>#onSectionPickerToggle(e)</code> Handles popover open/close for the section picker <code>#onEditSectionRules(sectionId, heading, elements)</code> Opens rules editor modal for a section, saves returned rules via API <code>#renderExtractionHeader()</code> Tab group slotted into header <code>#renderInfoBoxes()</code> Four equal-height uui-box cards (Source, Pages, Areas, Sections) <code>#renderExtractionContent()</code> Dispatches to area detection or transformed view <code>#renderAreaPage()</code> Renders a page with toggle, area count, and collapse <code>#renderArea()</code> Renders \"Area N\" with sections and collapse <code>#renderUndefinedArea()</code> Renders \"Undefined\" area for unclassified content <code>#renderSection()</code> Renders a section with toggle, heading, children, collapse <code>#renderAreaElement()</code> Renders individual text element with type + metadata badges <code>#classifyText()</code> Classifies text as 'list' or 'paragraph' by leading pattern <code>#renderTransformedSection()</code> Renders an assembled section with pattern badge and mapping <code>#renderNonPdfInfoBoxes()</code> Four info boxes for markdown/web: functional Source box + 3 placeholders <code>#renderNonPdfContent()</code> Routes non-PDF between <code>#renderSimpleElements()</code> (Extracted) and <code>#renderTransformed()</code> (Transformed) <code>#renderMappingBadges()</code> Shows Map button or green mapped-target badges <code>#hasAreaRules(area)</code> Checks if an area has rules defined in source config <code>#getTransformSectionsForArea(area, pageNum)</code> Gets transform sections belonging to an area (matched by colour + page) <code>#onMapSection(section)</code> Opens destination picker for a section's content key (<code>{id}.content</code>), saves result to map.json <code>#renderComposedSectionRow(section)</code> Renders a composed section row with role name, content preview, mapping badges, and Map button"},{"location":"source-files/up-doc-workflow-source-view-element/#imports","title":"Imports","text":"<pre><code>import type { RichExtractionResult, DocumentTypeConfig, MappingDestination, AreaDetectionResult, DetectedArea, DetectedSection, AreaElement, TransformResult, TransformedSection, SourceConfig, AreaTemplate, SectionRuleSet, InferSectionPatternResponse, MapConfig, SectionMapping } from './workflow.types.js';\nimport { fetchSampleExtraction, triggerSampleExtraction, fetchWorkflowByName, fetchAreaDetection, triggerTransform, fetchTransformResult, updateSectionInclusion, savePageSelection, fetchSourceConfig, fetchAreaTemplate, saveAreaTemplate, saveAreaRules, inferSectionPattern, saveMapConfig } from './workflow.service.js';\nimport { markdownToHtml, normalizeToKebabCase } from './transforms.js';\nimport { UMB_DESTINATION_PICKER_MODAL } from './destination-picker-modal.token.js';\nimport { UMB_SECTION_RULES_EDITOR_MODAL } from './section-rules-editor-modal.token.js';\nimport { UmbLitElement } from '@umbraco-cms/backoffice/lit-element';\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\nimport { UMB_WORKSPACE_CONTEXT } from '@umbraco-cms/backoffice/workspace';\nimport { UMB_MODAL_MANAGER_CONTEXT } from '@umbraco-cms/backoffice/modal';\nimport { UMB_MEDIA_PICKER_MODAL } from '@umbraco-cms/backoffice/media';\n</code></pre>"},{"location":"source-files/up-doc-workflow-source-view-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 single <code>workspaceView</code> registration:<ul> <li><code>UpDoc.WorkflowWorkspaceView.Source</code> (weight 200, icon <code>icon-page-add</code>)</li> </ul> </li> <li>Conditioned on <code>Umb.Condition.WorkspaceAlias</code> matching <code>UpDoc.WorkflowWorkspace</code></li> </ul>"},{"location":"source-files/up-doc-workflow-source-view-element/#used-by","title":"Used by","text":"<ul> <li>Displayed as the Source tab when viewing an individual workflow in the workflow workspace</li> </ul>"},{"location":"source-files/up-doc-workflow-workspace-context/","title":"up-doc-workflow-workspace.context.ts","text":"<p>Workspace context and editor element for individual workflow pages. Provides routing, state management, and the editor shell for the workflow workspace.</p>"},{"location":"source-files/up-doc-workflow-workspace-context/#what-it-does","title":"What it does","text":"<p>Contains two exports:</p> <ol> <li><code>UpDocWorkflowWorkspaceEditorElement</code> \u2014 A minimal Lit element that renders <code>&lt;umb-workspace-editor&gt;</code> with a dynamic headline</li> <li><code>UpDocWorkflowWorkspaceContext</code> \u2014 The workspace context class that manages routing and state for individual workflow pages</li> </ol> <p>When a user clicks a workflow in the collection view, the context receives the workflow name via the route parameter, formats it as a display name, and provides it to workspace views via observables.</p>"},{"location":"source-files/up-doc-workflow-workspace-context/#how-it-works","title":"How it works","text":""},{"location":"source-files/up-doc-workflow-workspace-context/#editor-element","title":"Editor element","text":"<p>The editor element (<code>up-doc-workflow-workspace-editor</code>) consumes the workspace context to get the display name and renders the standard <code>&lt;umb-workspace-editor&gt;</code> component with it as the headline:</p> <pre><code>@customElement('up-doc-workflow-workspace-editor')\nclass UpDocWorkflowWorkspaceEditorElement extends UmbLitElement {\n    override render() {\n        return html`&lt;umb-workspace-editor headline=${this._name}&gt;&lt;/umb-workspace-editor&gt;`;\n    }\n}\n</code></pre>"},{"location":"source-files/up-doc-workflow-workspace-context/#workspace-context","title":"Workspace context","text":"<p>The context class:</p> <ol> <li>Extends <code>UmbContextBase</code> and registers under <code>UMB_WORKSPACE_CONTEXT</code></li> <li>Manages an <code>UmbObjectState&lt;UpDocWorkflowData&gt;</code> with <code>unique</code> and <code>name</code> fields</li> <li>Exposes <code>unique</code> and <code>name</code> as observable parts for workspace views to consume</li> <li>Configures a route <code>edit/:unique</code> that maps URL parameters to <code>load()</code></li> <li>Formats kebab-case workflow names to title case for display (e.g. <code>group-tour</code> \u2192 <code>Group Tour</code>)</li> </ol> <pre><code>export class UpDocWorkflowWorkspaceContext extends UmbContextBase {\n    public readonly workspaceAlias = 'UpDoc.WorkflowWorkspace';\n    readonly unique = this.#data.asObservablePart((data) =&gt; data?.unique);\n    readonly name = this.#data.asObservablePart((data) =&gt; data?.name);\n    readonly routes = new UmbWorkspaceRouteManager(this);\n}\n\nexport { UpDocWorkflowWorkspaceContext as api };\n</code></pre> <p>The <code>api</code> export is required by Umbraco's workspace manifest pattern for lazy-loaded workspace contexts.</p>"},{"location":"source-files/up-doc-workflow-workspace-context/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-workflow-workspace-context/#routable-workspace-pattern","title":"Routable workspace pattern","text":"<p>Uses <code>kind: 'routable'</code> in the manifest, which means:</p> <ul> <li>URL routing with <code>edit/:unique</code> path segments</li> <li>Tree item selection state (if connected to a tree)</li> <li>Proper navigation between different workflow pages</li> </ul>"},{"location":"source-files/up-doc-workflow-workspace-context/#entity-type","title":"Entity type","text":"<p>Returns <code>'updoc-workflow'</code> from <code>getEntityType()</code>, matching the <code>entityType</code> in the workspace manifest. This connects the workspace to the correct tree items and navigation.</p>"},{"location":"source-files/up-doc-workflow-workspace-context/#name-formatting","title":"Name formatting","text":"<p>Workflow folder names use kebab-case (e.g. <code>example-group-tour</code>). The <code>load()</code> method converts this to title case for the headline display.</p>"},{"location":"source-files/up-doc-workflow-workspace-context/#imports","title":"Imports","text":"<pre><code>import { UmbWorkspaceRouteManager, UMB_WORKSPACE_CONTEXT } from '@umbraco-cms/backoffice/workspace';\nimport { UmbObjectState } from '@umbraco-cms/backoffice/observable-api';\nimport { UmbContextBase } from '@umbraco-cms/backoffice/class-api';\nimport { UmbLitElement } from '@umbraco-cms/backoffice/lit-element';\n</code></pre>"},{"location":"source-files/up-doc-workflow-workspace-context/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> \u2014 registered as a <code>workspace</code> with <code>kind: 'routable'</code>, alias <code>UpDoc.WorkflowWorkspace</code>, entity type <code>updoc-workflow</code></li> </ul>"},{"location":"source-files/up-doc-workflow-workspace-context/#used-by","title":"Used by","text":"<ul> <li>Workspace views (<code>up-doc-workflow-destination-view.element.ts</code>, <code>up-doc-workflow-source-views.element.ts</code>) consume the context to get the current workflow name</li> <li><code>up-doc-workflows-view.element.ts</code> navigates to this workspace via <code>history.pushState</code></li> </ul>"},{"location":"source-files/up-doc-workflows-view-element/","title":"up-doc-workflows-view.element.ts","text":"<p>Dashboard view element that lists and manages UpDoc workflows. Displayed in the Settings section under the UpDoc tree.</p>"},{"location":"source-files/up-doc-workflows-view-element/#what-it-does","title":"What it does","text":"<p>Provides a table-based UI for viewing all configured workflows, creating new ones, and deleting existing ones. Each workflow represents a complete pipeline from source extraction to document creation.</p>"},{"location":"source-files/up-doc-workflows-view-element/#how-it-works","title":"How it works","text":"<ol> <li>On <code>connectedCallback</code>, fetches all workflows from the <code>/umbraco/management/api/v1/updoc/workflows</code> API</li> <li>Renders workflows in a <code>uui-table</code> with columns for name, document type, blueprint, sources, mappings, and status</li> <li>Shows an empty state with explanation text when no workflows exist</li> <li>\"Create Workflow\" button triggers a stepped creation flow (see below)</li> <li>Clicking a workflow row navigates to the workflow workspace page via <code>history.pushState</code></li> <li>\"Delete\" button shows a <code>UMB_CONFIRM_MODAL</code> confirmation dialog, then DELETEs the workflow and clears the client-side config cache</li> </ol>"},{"location":"source-files/up-doc-workflows-view-element/#create-workflow-flow-stepped","title":"Create Workflow flow (stepped)","text":"<p>The \"Create Workflow\" button triggers a multi-step flow using <code>umbOpenModal</code>:</p> <ol> <li>Fetch document types \u2014 calls <code>GET /updoc/document-types</code> and <code>GET /updoc/document-types/{alias}/blueprints</code> for each</li> <li>Build DocumentTypeOption[] \u2014 only includes document types that have at least one blueprint</li> <li>Open blueprint picker dialog \u2014 <code>UMB_BLUEPRINT_PICKER_MODAL</code> shows doc type \u2192 blueprint selection</li> <li>Open Create Workflow sidebar \u2014 <code>UMB_CREATE_WORKFLOW_SIDEBAR</code> collects workflow name, source type, and optional sample document</li> <li>POST to API \u2014 creates the workflow folder on disk via <code>/updoc/workflows</code></li> <li>Refresh \u2014 reloads the workflow list</li> </ol> <p>If no document types have blueprints, shows an error message instead of opening the picker.</p>"},{"location":"source-files/up-doc-workflows-view-element/#ui-states","title":"UI states","text":"<ul> <li>Loading: Shows <code>uui-loader-bar</code></li> <li>Error: Shows error message with \"Retry\" button</li> <li>Empty: Shows explanatory text and \"Create Workflow\" button</li> <li>Populated: Shows workflow table with \"Create Workflow\" button above</li> </ul>"},{"location":"source-files/up-doc-workflows-view-element/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/up-doc-workflows-view-element/#workflowsummary-interface","title":"WorkflowSummary interface","text":"<p>The component consumes a <code>WorkflowSummary</code> interface from the API:</p> <pre><code>interface WorkflowSummary {\n    name: string;\n    documentTypeAlias: string;\n    blueprintId: string | null;\n    blueprintName: string | null;\n    sourceTypes: string[];\n    mappingCount: number;\n    isComplete: boolean;\n    validationWarnings: string[];\n}\n</code></pre>"},{"location":"source-files/up-doc-workflows-view-element/#workflow-navigation","title":"Workflow navigation","text":"<p>Clicking a workflow row navigates to the workflow workspace page using client-side routing:</p> <pre><code>#handleViewWorkflow(workflow: WorkflowSummary) {\n    const encodedName = encodeURIComponent(workflow.name);\n    window.history.pushState({}, '', `section/settings/workspace/updoc-workflow/edit/${encodedName}`);\n    window.dispatchEvent(new PopStateEvent('popstate'));\n}\n</code></pre> <p>The URL follows Umbraco's routable workspace pattern: <code>section/{section}/workspace/{entityType}/edit/{unique}</code>. The <code>popstate</code> event triggers Umbraco's router to handle the navigation.</p>"},{"location":"source-files/up-doc-workflows-view-element/#cache-invalidation-on-delete","title":"Cache invalidation on delete","text":"<p>After deleting a workflow, calls <code>clearConfigCache()</code> from <code>workflow.service.ts</code> to ensure the <code>UpDoc.Condition.HasAvailableWorkflows</code> condition re-evaluates. Without this, the entity action would remain visible for nodes whose workflows were just deleted.</p>"},{"location":"source-files/up-doc-workflows-view-element/#authentication","title":"Authentication","text":"<p>All API calls use <code>UMB_AUTH_CONTEXT</code> to obtain a bearer token for the Management API.</p>"},{"location":"source-files/up-doc-workflows-view-element/#imports","title":"Imports","text":"<pre><code>import { html, css, customElement, state } from '@umbraco-cms/backoffice/external/lit';\nimport { UmbLitElement } from '@umbraco-cms/backoffice/lit-element';\nimport { UmbTextStyles } from '@umbraco-cms/backoffice/style';\nimport { UMB_AUTH_CONTEXT } from '@umbraco-cms/backoffice/auth';\nimport { UMB_MODAL_MANAGER_CONTEXT, UMB_CONFIRM_MODAL, umbOpenModal } from '@umbraco-cms/backoffice/modal';\nimport { UMB_BLUEPRINT_PICKER_MODAL } from './blueprint-picker-modal.token.js';\nimport { UMB_CREATE_WORKFLOW_SIDEBAR } from './create-workflow-sidebar.token.js';\nimport { clearConfigCache } from './workflow.service.js';\n</code></pre>"},{"location":"source-files/up-doc-workflows-view-element/#registered-in","title":"Registered in","text":"<ul> <li><code>manifest.ts</code> -- registered as a <code>workspaceView</code> with alias <code>UpDoc.WorkspaceView.Workflows</code></li> </ul>"},{"location":"source-files/up-doc-workflows-view-element/#used-by","title":"Used by","text":"<ul> <li>Displayed in the UpDoc settings section when navigating to the Workflows view</li> </ul>"},{"location":"source-files/visual-grouping/","title":"visual-grouping.ts","text":"<p>Pure utility module for computing visual groups from extraction elements based on font size hierarchy. No Lit or Umbraco dependencies.</p>"},{"location":"source-files/visual-grouping/#what-it-does","title":"What it does","text":"<p>Groups a flat list of extracted elements into heading + children structures using font size analysis. Headings are elements with a font size larger than the most frequent (mode) font size on the page. This enables the source view to visually represent the document's structure (e.g., \"FEATURES\" heading with bullet points indented beneath it).</p>"},{"location":"source-files/visual-grouping/#exports","title":"Exports","text":""},{"location":"source-files/visual-grouping/#groupelementsbyheadingelements-extractionelement-visualgroup","title":"<code>groupElementsByHeading(elements: ExtractionElement[]): VisualGroup[]</code>","text":"<p>Takes a flat array of elements (typically one page's worth) and returns visual groups.</p> <p>Algorithm:</p> <ol> <li>Compute the mode (most frequent) font size \u2014 this is the body text size</li> <li>Any element with fontSize strictly greater than the mode is a heading</li> <li>Walk elements top-to-bottom: each heading starts a new group; body elements accumulate as children</li> <li>Elements before the first heading form an ungrouped section (<code>heading: null</code>)</li> <li>If all elements have the same font size, returns one ungrouped group</li> </ol> <p>Example: For a page with 9pt body text and 12pt section headings:</p> <ul> <li><code>VisualGroup { heading: \"FEATURES\" (12pt), children: [\"\u2022 Hotel\", \"\u2022 Dinner\", ...] }</code></li> <li><code>VisualGroup { heading: \"ACCOMMODATION\" (12pt), children: [\"We stay four nights...\"] }</code></li> </ul>"},{"location":"source-files/visual-grouping/#imports","title":"Imports","text":"<pre><code>import type { ExtractionElement, VisualGroup } from './workflow.types.js';\n</code></pre>"},{"location":"source-files/visual-grouping/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-workflow-source-view.element.ts</code> \u2014 calls <code>groupElementsByHeading()</code> in <code>#renderPageGroup()</code></li> </ul>"},{"location":"source-files/workflow-controller/","title":"WorkflowController.cs","text":"<p>ASP.NET Core API controller for UpDoc workflow CRUD operations.</p>"},{"location":"source-files/workflow-controller/#route","title":"Route","text":"<p><code>/umbraco/management/api/v1/updoc/workflows</code></p>"},{"location":"source-files/workflow-controller/#endpoints","title":"Endpoints","text":"Method Path Description GET <code>/</code> Returns all workflow summaries GET <code>/active</code> Returns document type aliases and blueprint IDs with complete workflows GET <code>/{name}</code> Returns full configuration for a specific workflow (bypasses validation) POST <code>/</code> Creates a new workflow folder with stub files + auto-populates destination.json DELETE <code>/{name}</code> Deletes a workflow folder POST <code>/{name}/sample-extraction</code> Extracts content from a source (PDF, Markdown, or Web URL) and saves as sample extraction. For markdown/web sources, also auto-generates transform.json via <code>ConvertStructuredToTransformResult</code> (deterministic heading-based grouping) GET <code>/{name}/sample-extraction</code> Returns the saved sample extraction POST <code>/{name}/regenerate-destination</code> Regenerates destination.json from the blueprint PUT <code>/{name}/map</code> Saves updated map.json POST <code>/{name}/transform</code> Runs area detection and content transform on the workflow's sample extraction GET <code>/{name}/transform</code> Returns the saved transform result"},{"location":"source-files/workflow-controller/#get-name-direct-config-loading-with-auto-regeneration","title":"GET /{name} \u2014 Direct config loading with auto-regeneration","text":"<p>Uses <code>GetConfigByName(name)</code> which loads the workflow config directly from disk without running validation. This is important because validation rejects workflows with partially-complete mappings (e.g., mappings referencing aliases that haven't been fully wired yet). The workspace editor needs to load these in-progress configs.</p> <p>After loading, the endpoint always regenerates <code>destination.json</code> from the current blueprint content. This ensures the Destination tab reflects the latest blueprint state (block ordering, property changes, etc.) without requiring manual regeneration. If regeneration fails, the cached file on disk is used as a fallback.</p>"},{"location":"source-files/workflow-controller/#dependencies","title":"Dependencies","text":"<ul> <li><code>IWorkflowService</code> \u2014 handles workflow file operations, config loading, and validation</li> <li><code>IDestinationStructureService</code> \u2014 builds destination.json from blueprint content</li> <li><code>IPdfPagePropertiesService</code> \u2014 detects areas in PDFs via <code>DetectAreas()</code></li> <li><code>IContentTransformService</code> \u2014 assembles area detection into sections via <code>Transform()</code></li> <li><code>IMediaService</code> \u2014 resolves media file paths</li> <li><code>IWebHostEnvironment</code> \u2014 provides web root path for file resolution</li> </ul>"},{"location":"source-files/workflow-controller/#documenttypecontrollercs","title":"DocumentTypeController.cs","text":"<p>A companion controller at <code>/umbraco/management/api/v1/updoc/document-types</code> provides endpoints for the Create Workflow modal pickers:</p> Method Path Description GET <code>/</code> Returns all non-element document types (alias, name, icon, id) GET <code>/{alias}/blueprints</code> Returns blueprints for a given document type"},{"location":"source-files/workflow-controller/#dependencies_1","title":"Dependencies","text":"<ul> <li><code>IContentTypeService</code> \u2014 Umbraco core service for document type lookups</li> <li><code>IContentService</code> \u2014 Umbraco core service for blueprint lookups</li> </ul>"},{"location":"source-files/workflow-controller/#authentication","title":"Authentication","text":"<p>All endpoints require <code>BackOfficeAccess</code> authorization policy. Frontend calls must include a bearer token from <code>UMB_AUTH_CONTEXT</code>.</p>"},{"location":"source-files/workflow-controller/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-workflows-view.element.ts</code> \u2014 CRUD operations on workflows</li> <li><code>create-workflow-sidebar.element.ts</code> \u2014 document type and blueprint picker data</li> <li><code>workflow.service.ts</code> \u2014 fetches active workflows, full configs, sample extractions, and saves map configs</li> <li><code>up-doc-workflow-source-view.element.ts</code> \u2014 sample extraction trigger and retrieval</li> </ul>"},{"location":"source-files/workflow-models/","title":"C# Configuration Models","text":"<p>Strongly-typed C# classes for deserializing the three-file configuration architecture. The models are split across multiple files in the <code>UpDoc.Models</code> namespace.</p>"},{"location":"source-files/workflow-models/#three-file-architecture","title":"Three-File Architecture","text":"<p>UpDoc uses a three-file configuration system stored in <code>updoc/workflows/{docType}/</code>:</p> File C# Model Purpose <code>source.json</code> <code>SourceConfig</code> HOW to extract sections from source documents <code>destination.json</code> <code>DestinationConfig</code> WHAT fields are available in the target document type <code>map.json</code> <code>MapConfig</code> WIRING between source sections and destination fields <p>All three are loaded and bundled into <code>DocumentTypeConfig</code> by the <code>WorkflowService</code>.</p>"},{"location":"source-files/workflow-models/#sourceconfigcs-sourcejson","title":"SourceConfig.cs (source.json)","text":"<p>Defines how to extract named sections from source documents using strategy-based extraction.</p>"},{"location":"source-files/workflow-models/#root-model","title":"Root Model","text":"<pre><code>public class SourceConfig\n{\n    [JsonPropertyName(\"$schema\")]\n    public string? Schema { get; set; }\n\n    [JsonPropertyName(\"version\")]\n    public string Version { get; set; } = \"1.0\";\n\n    [JsonPropertyName(\"sourceTypes\")]\n    public List&lt;string&gt; SourceTypes { get; set; } = new() { \"pdf\" };\n\n    [JsonPropertyName(\"globals\")]\n    public SourceGlobals? Globals { get; set; }\n\n    [JsonPropertyName(\"sections\")]\n    public List&lt;SourceSection&gt; Sections { get; set; } = new();\n}\n</code></pre>"},{"location":"source-files/workflow-models/#sourcesection","title":"SourceSection","text":"<p>Each section defines what to extract and how:</p> <pre><code>public class SourceSection\n{\n    [JsonPropertyName(\"key\")]\n    public string Key { get; set; } = string.Empty;      // Referenced in map.json\n\n    [JsonPropertyName(\"label\")]\n    public string Label { get; set; } = string.Empty;    // UI display name\n\n    [JsonPropertyName(\"strategy\")]\n    public string Strategy { get; set; } = string.Empty; // Extraction algorithm\n\n    [JsonPropertyName(\"outputFormat\")]\n    public string OutputFormat { get; set; } = \"text\";   // text, markdown, or html\n\n    [JsonPropertyName(\"required\")]\n    public bool Required { get; set; }\n\n    [JsonPropertyName(\"pages\")]\n    [JsonConverter(typeof(PagesConverter))]\n    public Pages Pages { get; set; } = new Pages { IsAll = true };\n\n    [JsonPropertyName(\"columnFilter\")]\n    public bool? ColumnFilter { get; set; }\n\n    [JsonPropertyName(\"strategyParams\")]\n    public StrategyParams? StrategyParams { get; set; }\n}\n</code></pre>"},{"location":"source-files/workflow-models/#extraction-strategies","title":"Extraction Strategies","text":"Strategy Purpose Key Params <code>largestFont</code> Text at/above font size threshold <code>fontSizeThreshold</code> <code>regex</code> Pattern matching <code>pattern</code>, <code>flags</code>, <code>captureGroup</code> <code>betweenPatterns</code> Content between start/stop markers <code>startPattern</code>, <code>stopPatterns</code>, <code>headingLevel</code> <code>region</code> Bounding box extraction <code>region: { x, y, unit }</code> <code>afterLabel</code> Text following a label <code>label</code>, <code>labelPattern</code>, <code>extractMode</code> <code>firstHeading</code> First heading at level (markdown) <code>level</code> <code>firstParagraph</code> First paragraph after heading (markdown) -- <code>cssSelector</code> CSS selector (web) <code>selector</code>, <code>attribute</code> <code>xpath</code> XPath expression (web/Word) <code>xpath</code>"},{"location":"source-files/workflow-models/#custom-json-converters","title":"Custom JSON Converters","text":"<ul> <li><code>PagesConverter</code> - Handles <code>pages</code> as either <code>[1, 2, 3]</code> or <code>\"all\"</code></li> <li><code>PageEndConverter</code> - Handles <code>end</code> as either a number or <code>\"last\"</code></li> </ul>"},{"location":"source-files/workflow-models/#destinationconfigcs-destinationjson","title":"DestinationConfig.cs (destination.json)","text":"<p>Documents available target fields in the Umbraco document type. This is the contract for what can be mapped to.</p>"},{"location":"source-files/workflow-models/#root-model_1","title":"Root Model","text":"<pre><code>public class DestinationConfig\n{\n    [JsonPropertyName(\"$schema\")]\n    public string? Schema { get; set; }\n\n    [JsonPropertyName(\"version\")]\n    public string Version { get; set; } = \"1.0\";\n\n    [JsonPropertyName(\"documentTypeAlias\")]\n    public string DocumentTypeAlias { get; set; } = string.Empty;\n\n    [JsonPropertyName(\"documentTypeName\")]\n    public string? DocumentTypeName { get; set; }\n\n    [JsonPropertyName(\"blueprintId\")]\n    public string? BlueprintId { get; set; }\n\n    [JsonPropertyName(\"blueprintName\")]\n    public string? BlueprintName { get; set; }\n\n    [JsonPropertyName(\"fields\")]\n    public List&lt;DestinationField&gt; Fields { get; set; } = new();\n\n    [JsonPropertyName(\"blockGrids\")]\n    public List&lt;DestinationBlockGrid&gt;? BlockGrids { get; set; }\n}\n</code></pre>"},{"location":"source-files/workflow-models/#block-grid-structure","title":"Block Grid Structure","text":"<pre><code>public class DestinationBlockGrid\n{\n    [JsonPropertyName(\"key\")]\n    public string Key { get; set; } = string.Empty;     // Used in map.json paths\n\n    [JsonPropertyName(\"alias\")]\n    public string Alias { get; set; } = string.Empty;   // Umbraco property alias\n\n    [JsonPropertyName(\"label\")]\n    public string? Label { get; set; }\n\n    [JsonPropertyName(\"blocks\")]\n    public List&lt;DestinationBlock&gt; Blocks { get; set; } = new();\n}\n\npublic class DestinationBlock\n{\n    [JsonPropertyName(\"key\")]\n    public string Key { get; set; } = string.Empty;      // Used in map.json paths\n\n    [JsonPropertyName(\"contentTypeAlias\")]\n    public string ContentTypeAlias { get; set; } = string.Empty;\n\n    [JsonPropertyName(\"label\")]\n    public string? Label { get; set; }\n\n    [JsonPropertyName(\"identifyBy\")]\n    public BlockIdentifier? IdentifyBy { get; set; }     // How to find this block\n\n    [JsonPropertyName(\"properties\")]\n    public List&lt;BlockProperty&gt;? Properties { get; set; }\n}\n\npublic class BlockIdentifier\n{\n    [JsonPropertyName(\"property\")]\n    public string Property { get; set; } = string.Empty;  // Property to search\n\n    [JsonPropertyName(\"value\")]\n    public string Value { get; set; } = string.Empty;     // Value to match\n}\n</code></pre>"},{"location":"source-files/workflow-models/#mapconfigcs-mapjson","title":"MapConfig.cs (map.json)","text":"<p>Pure relational mapping between source sections and destination fields. Contains no extraction logic or field metadata.</p>"},{"location":"source-files/workflow-models/#root-model_2","title":"Root Model","text":"<pre><code>public class MapConfig\n{\n    [JsonPropertyName(\"$schema\")]\n    public string? Schema { get; set; }\n\n    [JsonPropertyName(\"version\")]\n    public string Version { get; set; } = \"1.0\";\n\n    [JsonPropertyName(\"name\")]\n    public string? Name { get; set; }\n\n    [JsonPropertyName(\"description\")]\n    public string? Description { get; set; }\n\n    [JsonPropertyName(\"mappings\")]\n    public List&lt;SectionMapping&gt; Mappings { get; set; } = new();\n}\n</code></pre>"},{"location":"source-files/workflow-models/#mapping-structure","title":"Mapping Structure","text":"<pre><code>public class SectionMapping\n{\n    [JsonPropertyName(\"source\")]\n    public string Source { get; set; } = string.Empty;     // Key from source.json\n\n    [JsonPropertyName(\"destinations\")]\n    public List&lt;MappingDestination&gt; Destinations { get; set; } = new();\n\n    [JsonPropertyName(\"enabled\")]\n    public bool Enabled { get; set; } = true;\n\n    [JsonPropertyName(\"comment\")]\n    public string? Comment { get; set; }\n}\n\npublic class MappingDestination\n{\n    [JsonPropertyName(\"target\")]\n    public string Target { get; set; } = string.Empty;     // Target path\n\n    [JsonPropertyName(\"transforms\")]\n    public List&lt;MappingTransform&gt;? Transforms { get; set; }\n}\n</code></pre>"},{"location":"source-files/workflow-models/#target-path-syntax","title":"Target Path Syntax","text":"Pattern Example Meaning Simple field <code>\"pageTitle\"</code> Direct property on document Block property <code>\"contentGrid.itineraryBlock.richTextContent\"</code> blockGridKey.blockKey.propertyKey"},{"location":"source-files/workflow-models/#transforms","title":"Transforms","text":"<pre><code>public class MappingTransform\n{\n    [JsonPropertyName(\"type\")]\n    public string Type { get; set; } = string.Empty;\n\n    [JsonPropertyName(\"params\")]\n    public TransformParams? Params { get; set; }\n}\n</code></pre> <p>Available transform types: <code>convertMarkdownToHtml</code>, <code>convertHtmlToMarkdown</code>, <code>truncate</code>, <code>template</code>, <code>regex</code>, <code>trim</code>, <code>uppercase</code>, <code>lowercase</code>, <code>stripHtml</code>.</p>"},{"location":"source-files/workflow-models/#documenttypeconfig-combined","title":"DocumentTypeConfig (Combined)","text":"<p>Container returned by <code>WorkflowService.GetConfigByBlueprintIdAsync()</code>:</p> <pre><code>public class DocumentTypeConfig\n{\n    public string FolderPath { get; set; } = string.Empty;\n    public string DocumentTypeAlias { get; set; } = string.Empty;\n    public Dictionary&lt;string, SourceConfig&gt; Sources { get; set; } = new();\n    public DestinationConfig Destination { get; set; } = new();\n    public MapConfig Map { get; set; } = new();\n}\n</code></pre> <p>The <code>Sources</code> dictionary is keyed by source type (e.g. <code>\"pdf\"</code>, <code>\"markdown\"</code>), loaded from <code>{folderName}-source-{type}.json</code> files. This is serialized to JSON and returned by the <code>/updoc/config/{blueprintId}</code> and <code>/updoc/extract-sections</code> API endpoints.</p>"},{"location":"source-files/workflow-models/#workflowmodelscs-legacy","title":"WorkflowModels.cs (Legacy)","text":"<p>Contains extraction rule classes used for backward compatibility:</p> <ul> <li><code>PdfExtractionRules</code> - Legacy extraction settings</li> <li><code>ColumnDetectionConfig</code> - Column detection (duplicated in SourceConfig)</li> <li><code>TitleDetectionConfig</code> - Title detection</li> <li><code>ContentExtractionConfig</code> - Content extraction</li> </ul> <p>These are marked for refactoring as the extraction service transitions to strategy-driven extraction based on <code>SourceConfig</code>.</p>"},{"location":"source-files/workflow-models/#key-concepts","title":"Key Concepts","text":""},{"location":"source-files/workflow-models/#json-serialization","title":"JSON Serialization","text":"<p>All properties use <code>[JsonPropertyName(\"camelCase\")]</code> so PascalCase C# properties serialize to camelCase JSON keys.</p>"},{"location":"source-files/workflow-models/#cross-file-validation","title":"Cross-File Validation","text":"<p>The <code>WorkflowService</code> validates:</p> <ol> <li>Every <code>source</code> in map.json exists as a <code>key</code> in at least one source config (missing keys in a specific source type are warnings, not errors, since map.json is a superset across all source types)</li> <li>Every <code>target</code> in map.json resolves to a valid path in destination.json</li> </ol>"},{"location":"source-files/workflow-models/#namespace","title":"Namespace","text":"<p>All models are in:</p> <pre><code>namespace UpDoc.Models;\n</code></pre>"},{"location":"source-files/workflow-service-ts/","title":"workflow.service.ts","text":"<p>Frontend service for fetching config, active workflows, and extracting sections from the UpDoc backend API.</p>"},{"location":"source-files/workflow-service-ts/#what-it-does","title":"What it does","text":"<p>Provides exported async functions that communicate with the backend API:</p> <ol> <li><code>fetchActiveWorkflows</code> -- retrieves which workflows are complete (have destination + map + source)</li> <li><code>fetchConfig</code> -- retrieves the combined config (source, destination, map) for a blueprint</li> <li><code>extractSections</code> -- extracts structured sections from a media item using the config's extraction rules</li> <li><code>clearConfigCache</code> -- clears all in-memory caches</li> </ol> <p>All functions require a bearer token for Umbraco Management API authentication.</p>"},{"location":"source-files/workflow-service-ts/#functions","title":"Functions","text":""},{"location":"source-files/workflow-service-ts/#fetchactiveworkflows","title":"fetchActiveWorkflows","text":"<pre><code>export async function fetchActiveWorkflows(\n    token: string\n): Promise&lt;ActiveWorkflows&gt;\n</code></pre> <p>Fetches the list of document type aliases and blueprint IDs that have complete workflows from <code>GET /umbraco/management/api/v1/updoc/workflows/active</code>.</p> <ul> <li>Returns an <code>ActiveWorkflows</code> object containing:</li> <li><code>documentTypeAliases</code> -- string array of document type aliases with complete workflows</li> <li><code>blueprintIds</code> -- string array of blueprint IDs with complete workflows</li> <li>Uses a global singleton cache with deduplication (concurrent calls share one request)</li> <li>Returns <code>{ documentTypeAliases: [], blueprintIds: [] }</code> on error (fails silently)</li> <li>Cache persists for the browser session; cleared by <code>clearConfigCache()</code></li> </ul>"},{"location":"source-files/workflow-service-ts/#fetchconfig","title":"fetchConfig","text":"<pre><code>export async function fetchConfig(\n    blueprintId: string,\n    token: string\n): Promise&lt;DocumentTypeConfig | null&gt;\n</code></pre> <p>Fetches the combined config for a blueprint from <code>GET /umbraco/management/api/v1/updoc/config/{blueprintId}</code>.</p> <ul> <li>Uses an in-memory <code>Map&lt;string, DocumentTypeConfig&gt;</code> cache to avoid repeated network requests</li> <li>Returns <code>null</code> and logs a warning if no config exists for the blueprint (404 response)</li> <li>Returns the cached config on subsequent calls with the same <code>blueprintId</code></li> </ul>"},{"location":"source-files/workflow-service-ts/#extractsections","title":"extractSections","text":"<pre><code>export async function extractSections(\n    mediaKey: string,\n    blueprintId: string,\n    token: string,\n    sourceType: string = 'pdf'\n): Promise&lt;ExtractSectionsResponse | null&gt;\n</code></pre> <p>Calls <code>GET /umbraco/management/api/v1/updoc/extract-sections?mediaKey={mediaKey}&amp;blueprintId={blueprintId}&amp;sourceType={sourceType}</code> to extract content from a media item using the config's extraction rules. The <code>sourceType</code> parameter (default <code>'pdf'</code>) tells the backend which extraction service to use.</p> <ul> <li>Returns an <code>ExtractSectionsResponse</code> containing:</li> <li><code>sections</code> -- a <code>Record&lt;string, string&gt;</code> of extracted values keyed by section key</li> <li><code>config</code> -- the full <code>DocumentTypeConfig</code> for property mapping</li> <li>Returns <code>null</code> and logs the error if the request fails</li> <li>Does not cache results (each media item extraction is unique)</li> </ul>"},{"location":"source-files/workflow-service-ts/#clearconfigcache","title":"clearConfigCache","text":"<pre><code>export function clearConfigCache(): void\n</code></pre> <p>Clears the in-memory config cache. Useful when configs have been modified and need to be reloaded.</p>"},{"location":"source-files/workflow-service-ts/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/workflow-service-ts/#in-memory-caches","title":"In-memory caches","text":"<p>Two module-level caches persist for the browser session:</p> <pre><code>const configCache = new Map&lt;string, DocumentTypeConfig&gt;();\n\nlet activeWorkflowsCache: ActiveWorkflows | null = null;\nlet activeWorkflowsPromise: Promise&lt;ActiveWorkflows&gt; | null = null;\n</code></pre> <p>The config cache avoids re-fetching per-blueprint configs. The active workflows cache avoids re-fetching the global workflow list \u2014 this is shared between the condition (visibility check) and the action (blueprint filtering).</p> <p>The <code>activeWorkflowsPromise</code> ensures concurrent callers (e.g., condition evaluating on multiple nodes) share a single in-flight request rather than making duplicate calls.</p>"},{"location":"source-files/workflow-service-ts/#authentication","title":"Authentication","text":"<p>Both functions pass the bearer token in the <code>Authorization</code> header:</p> <pre><code>headers: {\n    'Content-Type': 'application/json',\n    Authorization: `Bearer ${token}`,\n}\n</code></pre> <p>The token is obtained from <code>UMB_AUTH_CONTEXT</code> by the calling code.</p>"},{"location":"source-files/workflow-service-ts/#error-handling","title":"Error handling","text":"<p>All functions handle non-OK responses gracefully: - <code>fetchActiveWorkflows</code> returns empty arrays (fails silently so the condition defaults to hidden) - <code>fetchConfig</code> returns <code>null</code> with a <code>console.warn</code> - <code>extractSections</code> parses the error body and logs it with <code>console.error</code>, then returns <code>null</code></p>"},{"location":"source-files/workflow-service-ts/#api-response-passthrough","title":"API response passthrough","text":"<p>The <code>extractSections</code> function passes through the API response directly:</p> <pre><code>// API returns { sections, config } - pass through directly\nreturn response.json();\n</code></pre> <p>This keeps the service simple -- all extraction and config loading happens on the backend.</p>"},{"location":"source-files/workflow-service-ts/#imports","title":"Imports","text":"<pre><code>import type { DocumentTypeConfig, ExtractSectionsResponse } from './workflow.types.js';\n</code></pre>"},{"location":"source-files/workflow-service-ts/#used-by","title":"Used by","text":"<ul> <li><code>up-doc-has-workflows.condition.ts</code> -- calls <code>fetchActiveWorkflows</code> to decide whether to show the entity action</li> <li><code>up-doc-action.ts</code> -- calls <code>fetchActiveWorkflows</code> to filter the blueprint picker; uses the config from the modal value to apply mappings</li> <li><code>up-doc-modal.element.ts</code> -- calls <code>extractSections</code> when a source document (PDF or Markdown) is selected</li> </ul>"},{"location":"source-files/workflow-service/","title":"WorkflowService.cs","text":"<p>Service that manages workflow config JSON files in the <code>updoc/workflows/</code> directory at the site root.</p>"},{"location":"source-files/workflow-service/#what-it-does","title":"What it does","text":"<p>Provides CRUD operations for workflow folders and their config files (source.json, destination.json, map.json, sample-extraction.json). Loads configs from disk, validates them, and supports both batch loading (all workflows) and direct single-workflow loading.</p>"},{"location":"source-files/workflow-service/#interface","title":"Interface","text":"<pre><code>public interface IWorkflowService\n{\n    IReadOnlyList&lt;WorkflowSummary&gt; GetAllWorkflowSummaries();\n    IReadOnlyList&lt;DocumentTypeConfig&gt; GetAllConfigs();\n    DocumentTypeConfig? GetConfigByName(string name);\n    void CreateWorkflow(string name, string documentTypeAlias, string sourceType, string? blueprintId, string? blueprintName);\n    void DeleteWorkflow(string name);\n    void SaveDestinationConfig(string name, DestinationConfig config);\n    void SaveMapConfig(string name, MapConfig config);\n    void SaveSampleExtraction(string name, RichExtractionResult extraction);\n    RichExtractionResult? GetSampleExtraction(string name);\n}\n</code></pre> Method Description <code>GetAllWorkflowSummaries</code> Returns lightweight summaries for the collection view <code>GetAllConfigs</code> Loads all workflows with full validation <code>GetConfigByName</code> Loads a single workflow directly from disk without validation \u2014 for workspace editing <code>CreateWorkflow</code> Creates a workflow folder with stub JSON files <code>DeleteWorkflow</code> Deletes a workflow folder <code>SaveDestinationConfig</code> Writes destination.json <code>SaveMapConfig</code> Writes map.json <code>SaveSampleExtraction</code> Writes sample-extraction.json <code>GetSampleExtraction</code> Reads sample-extraction.json"},{"location":"source-files/workflow-service/#key-concepts","title":"Key concepts","text":""},{"location":"source-files/workflow-service/#getconfigbyname-vs-getallconfigs","title":"GetConfigByName vs GetAllConfigs","text":"<p><code>GetAllConfigs()</code> runs <code>ValidateConfig()</code> which checks that all map.json targets exist in destination.json. Workflows that fail validation are skipped \u2014 this is correct for the collection view (only show complete workflows).</p> <p><code>GetConfigByName(name)</code> loads directly from disk without validation \u2014 the workflow workspace needs to edit partially-complete workflows where mappings may reference targets that haven't been fully validated yet.</p>"},{"location":"source-files/workflow-service/#validation-fix","title":"Validation fix","text":"<p><code>ValidateConfig</code> uses <code>field.Alias</code> (human-readable like \"pageTitle\") to build the set of valid destination keys, not <code>field.Key</code> (GUIDs). The frontend writes aliases to map.json targets, so validation must match against aliases.</p>"},{"location":"source-files/workflow-service/#registration","title":"Registration","text":"<p>Registered as a singleton via <code>UpDocComposer</code>:</p> <pre><code>builder.Services.AddSingleton&lt;IWorkflowService, WorkflowService&gt;();\n</code></pre>"},{"location":"source-files/workflow-service/#dependencies","title":"Dependencies","text":"<ul> <li><code>IWebHostEnvironment</code> \u2014 for <code>ContentRootPath</code> to locate the workflows directory</li> <li><code>ILogger&lt;WorkflowService&gt;</code> \u2014 for logging load status and errors</li> </ul>"},{"location":"source-files/workflow-service/#namespace","title":"Namespace","text":"<pre><code>namespace UpDoc.Services;\n</code></pre>"},{"location":"source-files/workflow-types/","title":"workflow.types.ts","text":"<p>TypeScript interfaces for the three-file configuration architecture. These types mirror the C# models for type-safe handling on the frontend.</p>"},{"location":"source-files/workflow-types/#what-it-does","title":"What it does","text":"<p>Defines the TypeScript shape of the three configuration files (<code>source.json</code>, <code>destination.json</code>, <code>map.json</code>) and the combined <code>DocumentTypeConfig</code> returned by the API. Used by the workflow service, modal, and entity action.</p>"},{"location":"source-files/workflow-types/#three-file-architecture","title":"Three-File Architecture","text":"<p>UpDoc uses a three-file configuration system:</p> File Purpose TypeScript Type <code>source.json</code> HOW to extract sections from source documents <code>SourceConfig</code> <code>destination.json</code> WHAT fields are available in the target document type <code>DestinationConfig</code> <code>map.json</code> WIRING between source sections and destination fields <code>MapConfig</code>"},{"location":"source-files/workflow-types/#source-config-types-sourcejson","title":"Source Config Types (source.json)","text":"<pre><code>export interface SourceConfig {\n    version: string;\n    sourceTypes: string[];           // e.g. [\"pdf\"]\n    globals?: SourceGlobals;\n    sections: SourceSection[];\n}\n\nexport interface SourceGlobals {\n    columnDetection?: ColumnDetectionConfig;\n    pageRange?: PageRangeConfig;\n}\n\nexport interface SourceSection {\n    key: string;                     // Unique identifier referenced in map.json\n    label: string;                   // Human-readable name for UI\n    description?: string;\n    strategy: ExtractionStrategy;    // Extraction algorithm\n    outputFormat: 'text' | 'markdown' | 'html';\n    required?: boolean;\n    pages?: number[] | 'all';\n    columnFilter?: boolean;\n    occurrence?: 'first' | 'last' | 'all';\n    strategyParams?: StrategyParams;\n}\n\nexport type ExtractionStrategy =\n    | 'largestFont'      // Text at/above font size threshold\n    | 'regex'            // Pattern matching\n    | 'betweenPatterns'  // Content between start/stop markers\n    | 'region'           // Bounding box extraction\n    | 'afterLabel'       // Text following a label\n    | 'firstHeading'     // First heading at specified level (markdown)\n    | 'firstParagraph'   // First paragraph after a heading (markdown)\n    | 'cssSelector'      // CSS selector (web)\n    | 'xpath';           // XPath expression (web/Word)\n</code></pre>"},{"location":"source-files/workflow-types/#strategy-parameters","title":"Strategy Parameters","text":"<pre><code>export interface StrategyParams {\n    // largestFont\n    fontSizeThreshold?: number;\n\n    // regex\n    pattern?: string;\n    flags?: string;\n    captureGroup?: number;\n\n    // betweenPatterns\n    startPattern?: string;\n    stopPatterns?: string[];\n    includeStartLine?: boolean;\n    headingLevel?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\n    // region\n    region?: RegionConfig;\n\n    // firstHeading (markdown)\n    level?: number;\n\n    // afterLabel\n    label?: string;\n    labelPattern?: string;\n    extractMode?: 'sameLine' | 'nextLine' | 'untilBlank';\n\n    // cssSelector (web)\n    selector?: string;\n    attribute?: string;\n\n    // xpath (web/Word)\n    xpath?: string;\n}\n</code></pre>"},{"location":"source-files/workflow-types/#destination-config-types-destinationjson","title":"Destination Config Types (destination.json)","text":"<pre><code>export interface DestinationConfig {\n    version: string;\n    documentTypeAlias: string;\n    documentTypeName?: string;\n    blueprintId?: string;\n    blueprintName?: string;\n    fields: DestinationField[];\n    blockGrids?: DestinationBlockGrid[];\n}\n\nexport interface DestinationField {\n    key: string;              // Key used in map.json target paths\n    alias: string;            // Umbraco property alias\n    label: string;\n    description?: string;\n    type: FieldType;\n    tab?: string;\n    mandatory?: boolean;\n    acceptsFormats?: ContentFormat[];\n}\n\nexport interface DestinationBlockGrid {\n    key: string;              // Key used in map.json (e.g. \"contentGrid\")\n    alias: string;            // Umbraco property alias\n    label: string;\n    blocks: DestinationBlock[];\n}\n\nexport interface DestinationBlock {\n    key: string;              // Key used in map.json (e.g. \"itineraryBlock\")\n    contentTypeAlias: string;\n    label: string;\n    identifyBy?: BlockIdentifier;    // How to find this block instance\n    properties?: BlockProperty[];\n}\n\nexport interface BlockIdentifier {\n    property: string;         // Property alias to search\n    value: string;            // Value to match (case-insensitive)\n}\n</code></pre>"},{"location":"source-files/workflow-types/#map-config-types-mapjson","title":"Map Config Types (map.json)","text":"<pre><code>export interface MapConfig {\n    version: string;\n    name?: string;\n    description?: string;\n    mappings: SectionMapping[];\n}\n\nexport interface SectionMapping {\n    source: string;                  // Key from source.json section\n    destinations: MappingDestination[];\n    enabled?: boolean;               // Set false to skip this mapping\n    comment?: string;\n}\n\nexport interface MappingDestination {\n    target: string;                  // Property alias (see below)\n    blockKey?: string;               // Block instance key for disambiguation\n    transforms?: MappingTransform[];\n}\n\nexport interface MappingTransform {\n    type: TransformType;\n    params?: TransformParams;\n}\n\nexport type TransformType =\n    | 'convertMarkdownToHtml'\n    | 'convertHtmlToMarkdown'\n    | 'truncate'\n    | 'template'\n    | 'regex'\n    | 'trim'\n    | 'uppercase'\n    | 'lowercase'\n    | 'stripHtml';\n</code></pre>"},{"location":"source-files/workflow-types/#target-syntax","title":"Target Syntax","text":"Pattern Example Meaning Simple field <code>{ target: \"pageTitle\" }</code> Direct property on document Block property <code>{ target: \"richTextContent\", blockKey: \"67f05ceb-...\" }</code> Property within a specific block instance Block property (legacy) <code>{ target: \"contentGrid.itineraryBlock.richTextContent\" }</code> Dot-path format (backwards compat) <p>When <code>blockKey</code> is present, the bridge code looks up the block instance in <code>destination.json</code> to find its <code>identifyBy</code> matcher, then uses that to locate the correct block in the scaffold at content creation time. See Mapping Directions for details on how disambiguation works.</p>"},{"location":"source-files/workflow-types/#combined-document-type-config","title":"Combined Document Type Config","text":"<p>The API returns all three configs bundled together:</p> <pre><code>export interface DocumentTypeConfig {\n    folderPath: string;              // Path to config folder\n    documentTypeAlias: string;\n    sources: Record&lt;string, SourceConfig&gt;;  // Keyed by source type (e.g. \"pdf\", \"markdown\")\n    destination: DestinationConfig;\n    map: MapConfig;\n}\n</code></pre>"},{"location":"source-files/workflow-types/#api-response-type","title":"API Response Type","text":"<pre><code>export interface ExtractSectionsResponse {\n    sections: Record&lt;string, string&gt;;  // Extracted sections keyed by source key\n    config: DocumentTypeConfig;        // Full config for property mapping\n}\n</code></pre> <p>The <code>ExtractSectionsResponse</code> is returned by the <code>/updoc/extract-sections</code> endpoint. It bundles extracted section values with the full config so the action can apply mappings client-side.</p>"},{"location":"source-files/workflow-types/#json-schema-validation","title":"JSON Schema Validation","text":"<p>Each configuration file type has a corresponding JSON Schema for editor validation and IntelliSense support:</p> Config File Schema Location <code>*-source-*.json</code> <code>App_Plugins/UpDoc/schemas/source.schema.json</code> <code>*-destination-*.json</code> <code>App_Plugins/UpDoc/schemas/destination.schema.json</code> <code>*-map.json</code> <code>App_Plugins/UpDoc/schemas/map.schema.json</code>"},{"location":"source-files/workflow-types/#using-schemas","title":"Using Schemas","text":"<p>Add a <code>$schema</code> property to your config files for validation:</p> <pre><code>{\n  \"$schema\": \"relative/path/to/schemas/source.schema.json\",\n  \"version\": \"1.0\",\n  ...\n}\n</code></pre> <p>The path should be relative from your config file to the schemas folder in <code>App_Plugins/UpDoc/schemas/</code>.</p> <p>Note</p> <p>The schema files contain <code>$id</code> properties with <code>https://updoc.dev/schemas/...</code> URLs. These are canonical identifiers for the schemas, but the actual schema files are local. Always use relative paths in your <code>$schema</code> references.</p>"},{"location":"source-files/workflow-types/#section-rule-types","title":"Section Rule Types","text":"<p>Types for the rules engine that powers the Shape layer (Extract \u2192 Shape \u2192 Map).</p>"},{"location":"source-files/workflow-types/#rule-condition-types","title":"Rule Condition Types","text":"<pre><code>export type RuleConditionType =\n    | 'textBeginsWith' | 'textEndsWith' | 'textContains' | 'textMatchesPattern'\n    | 'fontSizeEquals' | 'fontSizeRange' | 'fontSizeAbove' | 'fontSizeBelow'\n    | 'fontNameContains'\n    | 'colorEquals'\n    | 'positionFirst' | 'positionLast';\n</code></pre> Type Description Value <code>fontSizeEquals</code> Font size matches within 0.5pt tolerance number <code>fontSizeRange</code> Font size within min/max range (inclusive) <code>{ min: number, max: number }</code> <code>fontSizeAbove</code> Font size greater than value number <code>fontSizeBelow</code> Font size less than value number <code>fontNameContains</code> Font name contains value (case-sensitive) string <code>colorEquals</code> Color hex matches string <code>positionFirst</code> First element in section (none) <code>positionLast</code> Last element in section (none) <code>textBeginsWith</code> Element text starts with value string <code>textEndsWith</code> Element text ends with value string <code>textContains</code> Element text contains value string <code>textMatchesPattern</code> Element text matches regex regex string <p>The <code>fontSizeRange</code> condition is preferred over <code>fontSizeEquals</code> for cross-PDF compatibility, since font metrics can vary by 1-3 points across PDFs from the same template.</p>"},{"location":"source-files/workflow-types/#text-replacement","title":"Text Replacement","text":"<pre><code>export type FindType = 'textBeginsWith' | 'textEndsWith' | 'textContains';\nexport type ReplaceType = 'replaceWith' | 'replaceAll';\n\nexport interface TextReplacement {\n    findType: FindType;\n    find: string;\n    replaceType: ReplaceType;\n    replace: string;\n}\n</code></pre> <p>Text replacements are applied to matched element text before formatting. Each rule's <code>textReplacements</code> array is processed in order. The <code>findType</code> determines matching behavior:</p> <ul> <li><code>textBeginsWith</code> \u2014 replaces only at the start of the text</li> <li><code>textEndsWith</code> \u2014 replaces only at the end of the text</li> <li><code>textContains</code> \u2014 replaces all occurrences</li> </ul> <p>The <code>replaceType</code> adapts automatically based on <code>findType</code> in the UI.</p>"},{"location":"source-files/workflow-types/#key-concepts","title":"Key Concepts","text":""},{"location":"source-files/workflow-types/#separation-of-concerns","title":"Separation of Concerns","text":"<ul> <li>source.json: Defines extraction logic (strategies, patterns)</li> <li>destination.json: Documents available targets (fields, blocks)</li> <li>map.json: Pure relational mapping (no extraction logic, no field metadata)</li> </ul>"},{"location":"source-files/workflow-types/#used-by","title":"Used By","text":"<ul> <li><code>workflow.service.ts</code> -- Return types for <code>fetchConfig()</code> and <code>extractSections()</code></li> <li><code>up-doc-modal.token.ts</code> -- <code>DocumentTypeConfig</code> is part of <code>UmbUpDocModalValue</code></li> <li><code>up-doc-action.ts</code> -- Uses <code>config.map.mappings</code> and <code>config.destination.blockGrids</code></li> <li><code>up-doc-modal.element.ts</code> -- Stores <code>DocumentTypeConfig</code> as component state</li> </ul>"},{"location":"source-files/workflow-types/#imports","title":"Imports","text":"<p>This file has no imports -- it defines only interfaces and types.</p>"},{"location":"tooling/","title":"Tooling","text":"<p>Tools, workflows, and integrations used in the development of UpDoc. This section captures validated patterns and hard-won lessons \u2014 not aspirational ideas, but things that actually work in practice.</p> <p>The pace of change with AI-assisted development tooling is rapid. These pages document project-specific workflows that may evolve or transfer to other projects over time.</p> Tool What it does Figma UI design iteration via MCP integration and html.to.design captures Claude AI-assisted development with Claude Code, memory, and planning patterns Playwright End-to-end testing for Umbraco backoffice extensions Umbraco Claude Skills Claude Code plugin providing Umbraco backoffice extension guidance"},{"location":"tooling/claude/","title":"Claude","text":"<p>Claude Code is the primary development tool for UpDoc. It handles code generation, architecture planning, debugging, and documentation \u2014 essentially acting as a pair programmer with persistent memory across sessions.</p>"},{"location":"tooling/claude/#key-files","title":"Key Files","text":"File Purpose CLAUDE.md Project instructions that Claude reads at session start \u2014 build commands, naming conventions, mandatory workflows Memory &amp; Planning Persistent memory system and planning documents that carry context across sessions"},{"location":"tooling/claude/#how-claude-code-is-used-in-this-project","title":"How Claude Code Is Used in This Project","text":"<ul> <li>Code implementation \u2014 writing Lit web components, C# services, API controllers</li> <li>Architecture planning \u2014 designing the Extract \u2192 Shape \u2192 Map pipeline, workflow JSON schema, UI layouts</li> <li>Debugging \u2014 diagnosing cross-PDF rule matching failures, Shadow DOM rendering issues, composition property bugs</li> <li>Documentation \u2014 generating and maintaining these docs</li> <li>Git workflow \u2014 commits, branches, PRs following project conventions</li> </ul>"},{"location":"tooling/claude/#references","title":"References","text":"<ul> <li>Claude Code \u2014 official product page</li> <li>Claude Code GitHub \u2014 issue tracker and documentation</li> </ul>"},{"location":"tooling/claude/claude-md/","title":"CLAUDE.md","text":"<p><code>CLAUDE.md</code> is a project-level instructions file that Claude Code reads automatically at the start of every session. It defines how Claude should behave when working on this project.</p>"},{"location":"tooling/claude/claude-md/#location","title":"Location","text":"<pre><code>UpDoc/CLAUDE.md\n</code></pre> <p>Checked into the repository \u2014 shared across all contributors using Claude Code.</p>"},{"location":"tooling/claude/claude-md/#what-it-contains","title":"What It Contains","text":""},{"location":"tooling/claude/claude-md/#session-startup","title":"Session Startup","text":"<p>A list of planning documents that Claude must read fresh at the start of every session. This ensures architectural decisions are always in working context, not lost to context compression.</p>"},{"location":"tooling/claude/claude-md/#work-approval","title":"Work Approval","text":"<p>Claude must discuss its approach before implementing any non-trivial change. This prevents wasted effort on the wrong approach.</p>"},{"location":"tooling/claude/claude-md/#project-structure","title":"Project Structure","text":"<p>Defines the two-project solution layout (<code>src/UpDoc/</code> RCL and <code>src/UpDoc.TestSite/</code>).</p>"},{"location":"tooling/claude/claude-md/#naming-conventions","title":"Naming Conventions","text":"<p>A table of naming rules for every context \u2014 C# namespaces, npm packages, HTML elements, API routes, file names, Umbraco aliases.</p>"},{"location":"tooling/claude/claude-md/#build-commands","title":"Build Commands","text":"<p>How to build the frontend (TypeScript) and backend (.NET), and how to run the test site.</p>"},{"location":"tooling/claude/claude-md/#documentation-requirements","title":"Documentation Requirements","text":"<p>A mapping table from source files to their corresponding documentation files. When a source file is modified, its docs must be updated.</p>"},{"location":"tooling/claude/claude-md/#git-branching","title":"Git Branching","text":"<p>Rules for feature branches \u2014 always branch from main, never work directly on main, check current branch before creating a new one.</p>"},{"location":"tooling/claude/claude-md/#umbraco-cms-source-reference","title":"Umbraco CMS Source Reference","text":"<p>Points to the local clone of Umbraco CMS source code and mandates using it as the primary reference for all extension implementation.</p>"},{"location":"tooling/claude/claude-md/#why-this-matters","title":"Why This Matters","text":"<p>Without <code>CLAUDE.md</code>, every Claude Code session starts from zero \u2014 Claude would need to rediscover project conventions, build commands, and architectural decisions. With it, sessions are immediately productive because Claude already knows the rules.</p>"},{"location":"tooling/claude/claude-md/#lessons-learned","title":"Lessons Learned","text":"<ul> <li>Be specific about what to read at startup \u2014 vague instructions get skipped under context pressure</li> <li>Mandate reading planning documents \u2014 don't rely on memory or summaries for architectural decisions</li> <li>Include the \"don't\" rules \u2014 \"never work directly on main\", \"always use Composition* variants\" prevent recurring mistakes</li> <li>Keep it maintained \u2014 stale CLAUDE.md instructions cause confusion. Update it as the project evolves.</li> </ul>"},{"location":"tooling/claude/memory-and-planning/","title":"Memory &amp; Planning","text":"<p>Claude Code has two mechanisms for carrying context across sessions: auto memory (persistent notes) and planning documents (checked-in architectural decisions).</p>"},{"location":"tooling/claude/memory-and-planning/#auto-memory","title":"Auto Memory","text":"<p>Claude Code maintains a persistent memory directory that survives across conversations:</p> <pre><code>~/.claude/projects/&lt;project-hash&gt;/memory/\n</code></pre>"},{"location":"tooling/claude/memory-and-planning/#what-gets-stored","title":"What Gets Stored","text":"<ul> <li>MEMORY.md \u2014 loaded into every session's system prompt. Contains key architectural decisions, completed phases, critical rules, and session notes. Must stay under 200 lines.</li> <li>Topic files \u2014 detailed notes on specific subjects (e.g., <code>debugging-rule-matching.md</code>, <code>completed-phases.md</code>). Linked from MEMORY.md.</li> </ul>"},{"location":"tooling/claude/memory-and-planning/#what-should-be-saved","title":"What Should Be Saved","text":"<ul> <li>Stable patterns confirmed across multiple sessions</li> <li>Key architectural decisions and their rationale</li> <li>Solutions to recurring problems</li> <li>User preferences for workflow and communication</li> </ul>"},{"location":"tooling/claude/memory-and-planning/#what-should-not-be-saved","title":"What Should NOT Be Saved","text":"<ul> <li>Session-specific context (current task, in-progress work)</li> <li>Unverified conclusions from reading a single file</li> <li>Anything that duplicates CLAUDE.md instructions</li> </ul>"},{"location":"tooling/claude/memory-and-planning/#planning-documents","title":"Planning Documents","text":"<p>The <code>planning/</code> directory contains architectural planning documents:</p> <pre><code>UpDoc/planning/\n</code></pre> <p>These are checked into git and represent the project's design record.</p>"},{"location":"tooling/claude/memory-and-planning/#current-planning-documents","title":"Current Planning Documents","text":"Document Purpose <code>REFACTOR_TO_CONFIGURABLE.md</code> Config-driven extraction and mapping architecture <code>CREATE_FROM_SOURCE_SIDEBAR.md</code> Unified sidebar modal design <code>CREATE_FROM_SOURCE_UI.md</code> Single entry point UI design <code>DESTINATION_DRIVEN_MAPPING.md</code> Outlook-rules-inspired destination-driven mapping <code>TRANSFORMED_VIEW.md</code> Three-layer Extract \u2192 Shape \u2192 Map pipeline <code>RULES_EDITOR.md</code> Section rules editor design <code>PLAYWRIGHT_TESTING.md</code> E2E testing strategy"},{"location":"tooling/claude/memory-and-planning/#planning-vs-memory","title":"Planning vs Memory","text":"Planning documents Auto memory Location <code>planning/</code> (in repo) <code>~/.claude/memory/</code> (local) Versioned Yes (git) No Shared Yes (all contributors) No (per-machine) Purpose Architectural decisions, implementation plans Session continuity, lessons learned Lifespan Permanent until superseded Updated as understanding evolves"},{"location":"tooling/claude/memory-and-planning/#workflow","title":"Workflow","text":"<p>At the end of any significant planning phase, plans are saved to <code>planning/</code> with a meaningful filename. Claude Code's built-in <code>.claude/plans/</code> directory uses auto-generated names that are hard to find \u2014 the <code>planning/</code> directory is the human-readable permanent record.</p>"},{"location":"tooling/claude/memory-and-planning/#references","title":"References","text":"<ul> <li>Claude Code documentation \u2014 memory and configuration docs</li> </ul>"},{"location":"tooling/figma/","title":"Figma","text":"<p>Figma is used in UpDoc development for UI design iteration \u2014 capturing the current Umbraco backoffice state, making visual changes in Figma, and having Claude implement those changes in code.</p> <p>This workflow is necessary because Umbraco's backoffice uses Shadow DOM extensively, which makes traditional screenshot-based design tools unreliable. A specialised capture plugin (html.to.design) is required.</p>"},{"location":"tooling/figma/#tools","title":"Tools","text":"Tool Purpose Figma MCP Plugin Official Claude Code integration \u2014 reads designs, pushes web captures, manages component mappings html.to.design Figma plugin that captures web pages including Shadow DOM content HTML Mockups Static HTML mockups for fast component design iteration without the Umbraco site Design Workflow The end-to-end capture \u2192 edit \u2192 read \u2192 implement workflow and token management strategies"},{"location":"tooling/figma/#how-it-works","title":"How It Works","text":"<p>The integration is bidirectional but with different capabilities in each direction:</p> Direction Capability Limitation Figma \u2192 Code Claude reads any design element (screenshot, metadata, code context) Large frames consume many tokens Code \u2192 Figma Claude pushes running web pages as editable Figma layers Cannot see Shadow DOM (use html.to.design instead) Edit in Figma User only \u2014 Claude cannot modify individual Figma elements No element-level editing via MCP <p>The practical workflow for Umbraco projects:</p> <ol> <li>User captures the backoffice UI with html.to.design</li> <li>User edits the design in Figma (move, add, remove elements)</li> <li>User selects the modified area and copies the link (Ctrl+L)</li> <li>Claude reads the targeted node via <code>get_screenshot</code></li> <li>Claude implements the changes in Lit/UUI code</li> </ol> <p>For component-level design iteration without the Umbraco site running, see HTML Mockups.</p>"},{"location":"tooling/figma/#figma-file","title":"Figma File","text":"<p>The UpDoc design work uses a single Figma file:</p> <ul> <li>File: \"Back-office-work\"</li> <li>File key: <code>ZE8800trGvmQldnKeDq1Hy</code></li> <li>Key node: <code>12:2</code> (main captured frame \"1920w default\")</li> </ul>"},{"location":"tooling/figma/#references","title":"References","text":"<ul> <li>Figma MCP Plugin listing \u2014 official Claude Code plugin page</li> <li>Introducing Claude Code to Figma \u2014 Figma blog: \"Code to Canvas\" announcement</li> <li>Guide to the Figma MCP server \u2014 official Figma documentation</li> <li>html.to.design on Figma Community \u2014 the Shadow DOM capture plugin</li> <li>claude-talk-to-figma-mcp \u2014 third-party MCP for element-level editing (untested)</li> </ul>"},{"location":"tooling/figma/figma-mcp/","title":"Figma MCP Plugin","text":"<p>The Figma MCP Plugin is the official integration between Claude Code and Figma. It provides Claude with direct access to read designs and push web captures to Figma via MCP (Model Context Protocol) tools.</p>"},{"location":"tooling/figma/figma-mcp/#installation","title":"Installation","text":"<p>The plugin is installed via Claude Code's plugin system. Once connected, Claude has access to Figma MCP tools automatically.</p>"},{"location":"tooling/figma/figma-mcp/#bidirectional-but-not-element-level-editing","title":"Bidirectional \u2014 But Not Element-Level Editing","text":"<p>The Figma MCP integration is described as \"bidirectional\", but this does not mean Claude can edit individual Figma elements (move layers, swap icons, change text). The two directions are:</p> Direction What it means Tools Figma \u2192 Code Claude reads designs and implements them in code <code>get_screenshot</code>, <code>get_metadata</code>, <code>get_design_context</code> Code \u2192 Figma Claude captures a running web page and pushes it as editable Figma layers <code>generate_figma_design</code> <p>The round-trip workflow is: build UI in code \u2192 push to Figma \u2192 user edits in Figma \u2192 Claude reads back and updates code. But Claude cannot reach into an existing Figma design and modify individual elements.</p> <p>For element-level editing from Claude, see claude-talk-to-figma-mcp \u2014 a third-party MCP server that adds read/analyze/modify capabilities. Not tested with this project.</p>"},{"location":"tooling/figma/figma-mcp/#key-tools","title":"Key Tools","text":""},{"location":"tooling/figma/figma-mcp/#reading-designs-figma-claude","title":"Reading Designs (Figma \u2192 Claude)","text":"Tool What it returns Token cost <code>get_screenshot</code> Visual image of a node Low \u2014 uses vision tokens <code>get_metadata</code> XML tree of all nodes (IDs, types, names, positions, sizes) High \u2014 can be enormous for complex frames <code>get_design_context</code> Generated code + screenshot + contextual hints High \u2014 includes code and metadata <code>get_variable_defs</code> Design token values (colours, spacing, etc.) Low"},{"location":"tooling/figma/figma-mcp/#writing-designs-code-figma","title":"Writing Designs (Code \u2192 Figma)","text":"Tool Purpose <code>generate_figma_design</code> Capture a running web page and push it to Figma as editable layers <code>generate_diagram</code> Create flowcharts, sequence diagrams, etc. in FigJam <p><code>generate_figma_design</code> supports three modes:</p> <ul> <li>New file \u2014 creates a fresh Figma file with the captured design</li> <li>Existing file \u2014 adds the capture to an existing Figma file (e.g., \"Back-office-work\")</li> <li>Clipboard \u2014 copies the captured design for manual pasting</li> </ul> <p>The capture process works by running a JavaScript snippet in the browser, which serializes the page into Figma layers. Text becomes editable text, buttons become separate components, and layouts use auto-layout.</p>"},{"location":"tooling/figma/figma-mcp/#component-mapping-code-connect","title":"Component Mapping (Code Connect)","text":"Tool Purpose <code>get_code_connect_map</code> Get existing mappings between Figma components and codebase <code>add_code_connect_map</code> Create a new mapping <code>get_code_connect_suggestions</code> Get suggested mappings for a node"},{"location":"tooling/figma/figma-mcp/#getting-node-ids","title":"Getting Node IDs","text":"<p>To target a specific element, Claude needs its node ID. In Figma:</p> <ol> <li>Desktop app: Select the element, press Ctrl+L to copy the link</li> <li>Browser: The URL updates automatically with <code>?node-id=XX-YY</code> when you select an element</li> </ol> <p>Paste the copied link \u2014 Claude extracts the file key and node ID from the URL format: <pre><code>figma.com/design/:fileKey/:fileName?node-id=XX-YY\n</code></pre></p> <p>The <code>XX-YY</code> in the URL becomes <code>XX:YY</code> as the node ID.</p>"},{"location":"tooling/figma/figma-mcp/#token-management","title":"Token Management","text":"<p>All Figma MCP tool responses flow into Claude's context window \u2014 there are no separate \"Figma tokens\". This means large payloads directly reduce your available conversation context.</p>"},{"location":"tooling/figma/figma-mcp/#strategies","title":"Strategies","text":"<ol> <li>Use <code>get_screenshot</code> first \u2014 it gives Claude enough visual context to understand layout changes without the XML overhead</li> <li>Target specific nodes \u2014 instead of reading an entire frame, select just the component or section you've edited and use that node's ID</li> <li>Avoid <code>get_metadata</code> on large frames \u2014 a full Umbraco backoffice capture can have hundreds of nested elements. Only request metadata for focused areas</li> <li><code>get_design_context</code> is for implementation \u2014 use it when you're ready to write code, not for exploration</li> </ol>"},{"location":"tooling/figma/figma-mcp/#validated-targeted-screenshot-test-feb-2026","title":"Validated: Targeted Screenshot Test (Feb 2026)","text":"<p>Successfully tested targeted node reading on the \"Icons and Text\" frame (node <code>16:1141</code>):</p> <ul> <li>Selected a specific layer in Figma desktop \u2192 Ctrl+L \u2192 pasted URL</li> <li>Claude called <code>get_screenshot</code> on just that node</li> <li>Result: clear, complete image of the config toolbar + section tree</li> <li>Token cost: low (single image, no XML overhead)</li> </ul> <p>This confirmed the workflow: select a layer \u2192 copy link \u2192 paste \u2192 Claude screenshots just that area.</p>"},{"location":"tooling/figma/figma-mcp/#what-happened-on-our-second-attempt","title":"What Happened on Our Second Attempt","text":"<p>The first design iteration worked perfectly \u2014 a simple flat list of section boxes with badges. The second attempt captured a much more complex view (config toolbar, hierarchical tree, multiple button types, nested sections) and the metadata payload consumed too much of the context window.</p> <p>Lesson: Always scope your Figma reads to the specific area you're working on, not the entire captured frame.</p>"},{"location":"tooling/figma/figma-mcp/#limitations","title":"Limitations","text":"<ul> <li><code>generate_figma_design</code> does NOT work for Umbraco \u2014 the built-in web capture cannot see Shadow DOM content, resulting in blank pages. Use html.to.design instead.</li> <li>No element-level editing \u2014 Claude cannot modify individual Figma elements (move layers, replace icons, edit text). The user must make visual edits in Figma.</li> <li>Code output is React + Tailwind by default \u2014 the generated code is a reference, not final code. Always adapt to the target project's stack (Lit + UUI in UpDoc's case).</li> </ul>"},{"location":"tooling/figma/figma-mcp/#references","title":"References","text":"<ul> <li>Figma MCP Plugin \u2014 official plugin listing</li> <li>Introducing Claude Code to Figma \u2014 Figma blog: \"Code to Canvas\" announcement</li> <li>Claude Code to Figma Tutorial (Builder.io) \u2014 detailed tutorial and limitations</li> <li>Guide to the Figma MCP server (Figma Help) \u2014 official documentation</li> <li>claude-talk-to-figma-mcp \u2014 third-party MCP for element-level editing (untested)</li> </ul>"},{"location":"tooling/figma/html-to-design/","title":"html.to.design","text":"<p>html.to.design is a Figma plugin by div:RIOTS that captures live web pages and converts them into editable Figma designs. It is the only reliable way to capture Umbraco's backoffice UI into Figma.</p>"},{"location":"tooling/figma/html-to-design/#why-this-plugin","title":"Why This Plugin","text":"<p>Umbraco's backoffice is built entirely with Web Components and Shadow DOM. Standard capture tools (including Figma's built-in <code>generate_figma_design</code> MCP tool) cannot see inside Shadow DOM boundaries \u2014 they produce blank or incomplete captures.</p> <p>html.to.design traverses Shadow DOM trees and captures the rendered output faithfully, including:</p> <ul> <li>Custom elements (<code>uui-*</code>, <code>umb-*</code>, <code>up-doc-*</code>)</li> <li>Slotted content</li> <li>CSS custom properties (applied/computed values)</li> <li>Nested shadow roots</li> </ul>"},{"location":"tooling/figma/html-to-design/#usage","title":"Usage","text":"<ol> <li>Open the Umbraco backoffice in a browser and navigate to the view you want to capture</li> <li>In Figma, run the html.to.design plugin</li> <li>Enter the URL of the page to capture</li> <li>The plugin renders the full page (including Shadow DOM) as editable Figma layers</li> </ol> <p>The captured output preserves the visual structure \u2014 text, colours, spacing, layout \u2014 as real Figma elements that can be rearranged, resized, and annotated.</p>"},{"location":"tooling/figma/html-to-design/#limitations","title":"Limitations","text":"<ul> <li>Free tier: approximately 9 imports per month</li> <li>Capture scope: captures the visible viewport; scrolled content may need multiple captures</li> <li>Not pixel-perfect: some CSS properties (animations, complex gradients, backdrop filters) may not translate exactly</li> <li>MCP tab available: html.to.design has an MCP integration tab that could enable programmatic capture in future, but this has not been tested yet</li> </ul>"},{"location":"tooling/figma/html-to-design/#alternatives-considered","title":"Alternatives Considered","text":"Tool Result with Umbraco Figma MCP <code>generate_figma_design</code> Blank page \u2014 cannot see Shadow DOM Browser screenshot Static image \u2014 not editable in Figma Chrome DevTools capture Captures DOM but not Shadow DOM structure <p>html.to.design is currently the only viable option for Umbraco backoffice capture.</p>"},{"location":"tooling/figma/html-to-design/#references","title":"References","text":"<ul> <li>html.to.design on Figma Community \u2014 plugin listing and documentation</li> <li>div:RIOTS (plugin author) \u2014 the team behind html.to.design</li> </ul>"},{"location":"tooling/figma/mockups/","title":"HTML Mockups","text":"<p>Static HTML mockups provide a lightweight design workbench for iterating on UpDoc UI components without needing the Umbraco site running.</p>"},{"location":"tooling/figma/mockups/#why-mockups","title":"Why Mockups?","text":"Problem Mockup Solution Umbraco backoffice must be running to see components Mockups render standalone in any browser Shadow DOM blocks standard Figma capture Mockups are plain HTML \u2014 standard capture works Full site rebuild needed after TypeScript changes Edit HTML, refresh browser, done html.to.design plugin limited to ~9 captures/month (free tier) Figma MCP capture script has no limit <p>Mockups are not a replacement for the live backoffice. They are a fast iteration layer for designing individual components before translating approved designs into real Lit/UUI code.</p>"},{"location":"tooling/figma/mockups/#directory","title":"Directory","text":"<pre><code>mockups/\n  source-info-box.html      \u2190 Source info box component\n  ...future mockups\n</code></pre> <p>Each file is self-contained with inline CSS that approximates UUI variables (colors, spacing, fonts, border radius). No build step, no dependencies.</p>"},{"location":"tooling/figma/mockups/#how-it-works","title":"How It Works","text":""},{"location":"tooling/figma/mockups/#creating-a-mockup","title":"Creating a Mockup","text":"<ol> <li>Claude reads the real Lit component code from <code>src/UpDoc/wwwroot/App_Plugins/UpDoc/src/</code></li> <li>Claude creates a plain HTML file in <code>mockups/</code> that visually reproduces the component</li> <li>UUI CSS custom properties are approximated with static values in a <code>:root</code> block</li> </ol>"},{"location":"tooling/figma/mockups/#the-design-loop","title":"The Design Loop","text":"<pre><code>HTML mockup \u2190\u2192 Browser preview \u2190\u2192 Figma capture\n     \u2193                                    \u2193\nReal Lit/UUI code \u2190\u2500\u2500 Approved design \u2500\u2500\u2500\u2518\n</code></pre> <p>Direction 1 \u2014 Code to Figma:</p> <ol> <li>Claude creates or updates the HTML mockup</li> <li>Serve locally: <code>npx http-server mockups/ -p 3334 -c-1</code></li> <li>Open in browser to preview</li> <li>Capture to Figma via MCP (see below)</li> <li>User edits in Figma (move things, change colors, add elements)</li> </ol> <p>Direction 2 \u2014 Figma to Code:</p> <ol> <li>Claude reads the modified Figma design via <code>get_screenshot</code> / <code>get_metadata</code></li> <li>Claude updates the HTML mockup to match</li> <li>When design is approved, Claude translates to real Lit/UUI code</li> </ol>"},{"location":"tooling/figma/mockups/#capturing-to-figma","title":"Capturing to Figma","text":""},{"location":"tooling/figma/mockups/#setup","title":"Setup","text":"<p>The capture script tag should be present in the mockup HTML <code>&lt;head&gt;</code>:</p> <pre><code>&lt;script src=\"https://mcp.figma.com/mcp/html-to-design/capture.js\" async&gt;&lt;/script&gt;\n</code></pre>"},{"location":"tooling/figma/mockups/#capture-process","title":"Capture Process","text":"<ol> <li> <p>Start a local server (if not already running):    <pre><code>npx http-server mockups/ -p 3334 -c-1\n</code></pre></p> </li> <li> <p>Claude requests a capture ID from the Figma MCP <code>generate_figma_design</code> tool, targeting the \"Back-office-work\" file (<code>ZE8800trGvmQldnKeDq1Hy</code>)</p> </li> <li> <p>Claude opens the mockup in the user's browser with the capture hash:    <pre><code>start \"\" \"http://localhost:3334/source-info-box.html#figmacapture=&lt;ID&gt;&amp;figmaendpoint=&lt;URL&gt;&amp;figmadelay=2000\"\n</code></pre></p> </li> <li> <p>User clicks \"Send to Figma\" in the capture toolbar that appears in the browser</p> </li> <li> <p>Claude polls the capture ID until status is <code>completed</code></p> </li> </ol> <p>User action required</p> <p>The capture toolbar requires the user to click \"Send to Figma\". Claude cannot automate this step \u2014 it runs in the user's browser, not in the Playwright instance.</p>"},{"location":"tooling/figma/mockups/#uui-variable-reference","title":"UUI Variable Reference","text":"<p>Mockups approximate UUI design tokens with static CSS values:</p> <pre><code>:root {\n  --uui-font-family: \"Open Sans\", -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif;\n  --uui-color-surface: #fff;\n  --uui-color-border: #e0e0e0;\n  --uui-color-text: #1b264f;\n  --uui-color-text-alt: #666;\n  --uui-color-default: #1b264f;\n  --uui-color-default-emphasis: #2b3a6b;\n  --uui-size-space-2: 6px;\n  --uui-size-space-3: 9px;\n  --uui-size-space-4: 12px;\n  --uui-size-space-5: 15px;\n  --uui-border-radius: 3px;\n  --uui-type-small-size: 12px;\n  --uui-type-default-size: 14px;\n  --uui-type-h4-size: 18px;\n}\n</code></pre> <p>These are approximations \u2014 check the UUI Storybook for authoritative values.</p>"},{"location":"tooling/figma/mockups/#tips","title":"Tips","text":"<ul> <li>One component per file \u2014 keep mockups focused on a single component or small group</li> <li>Match real data \u2014 use realistic content (actual filenames, dates, counts) so the design reflects real usage</li> <li>SVG for icons \u2014 inline SVGs approximate Umbraco's icon set without needing the icon font</li> <li>Background color \u2014 use <code>#f3f3f5</code> for body to match Umbraco's backoffice background</li> <li>Leave the capture script in \u2014 it only activates when opened with the capture hash parameters</li> </ul>"},{"location":"tooling/figma/workflow/","title":"Design Workflow","text":"<p>The end-to-end workflow for using Figma to iterate on UpDoc's UI.</p>"},{"location":"tooling/figma/workflow/#the-process","title":"The Process","text":"<pre><code>Capture \u2192 Edit \u2192 Read \u2192 Implement\n</code></pre>"},{"location":"tooling/figma/workflow/#1-capture","title":"1. Capture","text":"<p>The user captures the current Umbraco backoffice UI using the html.to.design Figma plugin. This creates an editable Figma frame representing the live state of the UI.</p> <p>Best practice: Capture only the specific panel or component you want to iterate on, not the entire backoffice screen. Smaller captures = fewer Figma nodes = less token consumption when Claude reads it back.</p>"},{"location":"tooling/figma/workflow/#2-edit","title":"2. Edit","text":"<p>The user rearranges, adds, or removes elements directly in Figma:</p> <ul> <li>Move components to different positions</li> <li>Add placeholder text or labels for new elements</li> <li>Delete elements that should be removed</li> <li>Annotate with notes about intended behaviour</li> </ul> <p>No design skills required \u2014 the goal is communicating intent, not producing polished mockups.</p> <p>Claude cannot edit Figma designs</p> <p>The Figma MCP plugin cannot modify individual elements. All visual editing must be done by the user in Figma. See Figma MCP \u2014 Bidirectional for details.</p>"},{"location":"tooling/figma/workflow/#3-read","title":"3. Read","text":"<p>Claude reads the modified design using Figma MCP tools.</p> <p>Step 1: Select the modified area in Figma and copy the link:</p> <ul> <li>Desktop app: Select the layer \u2192 press Ctrl+L</li> <li>Browser: The URL updates automatically with <code>?node-id=XX-YY</code></li> </ul> <p>Step 2: Paste the link to Claude. Claude extracts the node ID and reads just that targeted area.</p> <p>Step 3: Claude uses the appropriate tool:</p> <ul> <li><code>get_screenshot</code> \u2014 always start here. Gives Claude visual understanding of the layout changes with low token cost</li> <li><code>get_metadata</code> \u2014 only if structural details are needed (exact node hierarchy, positions, sizes). High token cost.</li> <li><code>get_design_context</code> \u2014 only when ready to generate implementation code. High token cost.</li> </ul>"},{"location":"tooling/figma/workflow/#4-implement","title":"4. Implement","text":"<p>Claude translates the design changes into Lit/UUI code, following UpDoc's existing patterns and Umbraco's component library.</p> <p>The Figma MCP's code output is React + Tailwind \u2014 this is a reference only. Claude adapts it to the project's actual stack (Lit web components, UUI/Umbraco elements, CSS custom properties).</p>"},{"location":"tooling/figma/workflow/#validated-examples","title":"Validated Examples","text":""},{"location":"tooling/figma/workflow/#first-iteration-successful-feb-2026","title":"First iteration \u2014 successful (Feb 2026)","text":"<ul> <li>Captured the Extracted tab showing section boxes with badges</li> <li>User rearranged badge positions in Figma</li> <li>Claude read via <code>get_screenshot</code> + <code>get_metadata</code></li> <li>Claude implemented the layout changes in Lit</li> </ul>"},{"location":"tooling/figma/workflow/#second-iteration-token-issue-feb-2026","title":"Second iteration \u2014 token issue (Feb 2026)","text":"<ul> <li>Captured a much more complex view (config toolbar + hierarchical tree)</li> <li><code>get_metadata</code> on the full frame consumed too much context</li> <li>Root cause: The frame had 3-5x the node count of the first iteration</li> <li>Fix: Should have targeted individual sections (toolbar OR tree, not both)</li> </ul>"},{"location":"tooling/figma/workflow/#targeted-node-test-successful-feb-2026","title":"Targeted node test \u2014 successful (Feb 2026)","text":"<ul> <li>Selected the \"Icons and Text\" frame in Figma desktop (node <code>16:1141</code>)</li> <li>Copied link with Ctrl+L, pasted URL to Claude</li> <li>Claude called <code>get_screenshot</code> on just that node</li> <li>Result: clear image showing config toolbar + section tree, low token cost</li> <li>Validated: targeted reads solve the token problem</li> </ul>"},{"location":"tooling/figma/workflow/#tips","title":"Tips","text":"<ul> <li>One area at a time \u2014 capture and iterate on one component or section per cycle</li> <li>Screenshot first \u2014 <code>get_screenshot</code> is usually sufficient for Claude to understand changes</li> <li>Name your Figma nodes \u2014 if you rename elements in Figma, those names appear in metadata and help Claude understand intent</li> <li>Keep the Figma file organised \u2014 use separate frames for different areas of the UI rather than one giant frame</li> <li>Copy link, not node ID \u2014 in Figma desktop use Ctrl+L to copy the link. Claude extracts the node ID from the URL automatically</li> </ul>"},{"location":"tooling/playwright/","title":"Playwright","text":"<p>Playwright is used for two purposes in UpDoc:</p> <ol> <li>End-to-end testing \u2014 automating browser interactions for the Create from Source workflow</li> <li>Figma capture \u2014 logging into the Umbraco backoffice to capture authenticated pages for design iteration (via Playwright MCP)</li> </ol>"},{"location":"tooling/playwright/#setup","title":"Setup","text":"<p>Playwright tests live in the UpDoc project alongside the extension code. The test configuration targets the local UpDoc.TestSite.</p>"},{"location":"tooling/playwright/#environment","title":"Environment","text":"Variable Purpose <code>URL</code> The Umbraco site URL (e.g., <code>https://localhost:44391</code>) <p>Note: The environment variable is <code>URL</code>, not <code>UMBRACO_URL</code>.</p>"},{"location":"tooling/playwright/#test-pdfs","title":"Test PDFs","text":"<p>Test PDFs are stored in the Umbraco media library:</p> PDF Purpose <code>updoc-test-01</code> Primary test document <code>updoc-test-02</code> Secondary test document <code>updoc-test-03</code> Third test document"},{"location":"tooling/playwright/#shadow-dom-considerations","title":"Shadow DOM Considerations","text":"<p>Umbraco's backoffice uses Shadow DOM extensively. This affects how Playwright selects elements:</p> <ul> <li>Use page-level queries \u2014 <code>page.locator()</code> rather than scoped queries that can't cross shadow boundaries</li> <li>Avoid strict shadow DOM selectors \u2014 Playwright's <code>&gt;&gt;</code> shadow piercing syntax can be fragile with Umbraco's nested shadow roots</li> <li>Test UUI components \u2014 <code>uui-button</code>, <code>uui-input</code>, etc. are custom elements inside shadow roots</li> </ul>"},{"location":"tooling/playwright/#test-coverage","title":"Test Coverage","text":"<p>Four tests cover the Create from Source workflow:</p> <ol> <li>Visibility \u2014 the \"Create from Source\" button appears in the collection toolbar</li> <li>Blueprint picker \u2014 clicking the button opens the blueprint picker modal</li> <li>Full flow \u2014 complete flow from button click through blueprint selection, PDF upload, extraction, and document creation</li> <li>Preview \u2014 extraction preview renders correctly before document creation</li> </ol>"},{"location":"tooling/playwright/#backoffice-user-for-playwright","title":"Backoffice User for Playwright","text":"<p>A dedicated Umbraco user account exists for Playwright automation. This user is used both by E2E tests and by the Playwright MCP server for Figma captures of authenticated backoffice pages.</p> <p>Credentials</p> <p>The Playwright user credentials are stored in environment variables, not in source control. Ask the project maintainer for the values if you need to configure a new machine.</p>"},{"location":"tooling/playwright/#figma-capture-via-playwright-mcp","title":"Figma Capture via Playwright MCP","text":"<p>The Playwright MCP server can log into the Umbraco backoffice and capture authenticated pages directly \u2014 bypassing the html.to.design plugin and its Shadow DOM limitations. This is useful for capturing the live backoffice state (not just static mockups).</p> <p>When to use:</p> Approach Best for HTML Mockups Designing individual components without the site running html.to.design plugin Capturing complex backoffice pages with full Shadow DOM fidelity Playwright MCP capture Automated capture of authenticated pages \u2014 no manual plugin step <p>How it works:</p> <ol> <li>Playwright MCP navigates to the Umbraco login page</li> <li>Logs in with the dedicated Playwright user</li> <li>Navigates to the target backoffice page</li> <li>Injects the Figma capture script (stripping CSP headers)</li> <li>Submits the capture to the Figma file</li> </ol> <p>Status: Planned</p> <p>This workflow has been set up but not yet fully validated end-to-end with the Umbraco backoffice. The dedicated user exists and Playwright MCP is configured. Full validation is pending.</p>"},{"location":"tooling/playwright/#known-issues","title":"Known Issues","text":"<ul> <li>Cleanup: tests currently do not delete created test documents. A cleanup step is needed to prevent test data accumulation.</li> <li>Site must be running: Playwright tests require the UpDoc.TestSite to be running before execution.</li> </ul>"},{"location":"tooling/playwright/#running-tests","title":"Running Tests","text":"<pre><code>npx playwright test\n</code></pre>"},{"location":"tooling/playwright/#umbraco-testing-skills","title":"Umbraco Testing Skills","text":"<p>Before writing new Playwright tests, invoke the relevant Claude Code skills:</p> <ul> <li><code>umbraco-e2e-testing</code> \u2014 E2E patterns for Umbraco backoffice</li> <li><code>umbraco-playwright-testhelpers</code> \u2014 <code>@umbraco/playwright-testhelpers</code> fixtures and helpers</li> <li><code>umbraco-testing</code> \u2014 router skill for choosing the right testing approach</li> </ul>"},{"location":"tooling/playwright/#references","title":"References","text":"<ul> <li>Playwright documentation</li> <li><code>@umbraco/playwright-testhelpers</code> \u2014 Umbraco's official test helpers</li> <li>planning/PLAYWRIGHT_TESTING.md \u2014 original test planning document</li> </ul>"},{"location":"tooling/umbraco-skills/","title":"Umbraco Claude Skills","text":"<p>The Umbraco CMS Backoffice Skills are Claude Code plugins that provide guidance on building Umbraco backoffice extensions. They contain official documentation, patterns, and working examples for each extension type.</p>"},{"location":"tooling/umbraco-skills/#installation","title":"Installation","text":"<pre><code>/plugin marketplace add umbraco/Umbraco-CMS-Backoffice-Skills\n/plugin install umbraco-cms-backoffice-skills@umbraco-backoffice-marketplace\n/plugin install umbraco-cms-backoffice-testing-skills@umbraco-backoffice-marketplace\n</code></pre>"},{"location":"tooling/umbraco-skills/#available-plugins","title":"Available Plugins","text":""},{"location":"tooling/umbraco-skills/#umbraco-cms-backoffice-skills-57-skills","title":"umbraco-cms-backoffice-skills (57 skills)","text":"<p>Skills for every Umbraco backoffice extension type:</p> Category Key Skills Actions <code>umbraco-entity-actions</code>, <code>umbraco-collection-action</code>, <code>umbraco-entity-bulk-actions</code>, <code>umbraco-entity-create-option-action</code> UI <code>umbraco-dashboard</code>, <code>umbraco-workspace</code>, <code>umbraco-modals</code>, <code>umbraco-sections</code>, <code>umbraco-tree</code> Property Editors <code>umbraco-property-editor-ui</code>, <code>umbraco-property-editor-schema</code>, <code>umbraco-property-action</code> Foundation <code>umbraco-context-api</code>, <code>umbraco-extension-registry</code>, <code>umbraco-conditions</code>, <code>umbraco-state-management</code> Rich Text <code>umbraco-tiptap-extension</code>, <code>umbraco-tiptap-toolbar-extension</code>, <code>umbraco-tiptap-statusbar-extension</code>"},{"location":"tooling/umbraco-skills/#umbraco-cms-backoffice-testing-skills-8-skills","title":"umbraco-cms-backoffice-testing-skills (8 skills)","text":"Skill Purpose <code>umbraco-testing</code> Router \u2014 helps choose the right testing approach <code>umbraco-e2e-testing</code> Playwright E2E patterns for Umbraco <code>umbraco-playwright-testhelpers</code> <code>@umbraco/playwright-testhelpers</code> reference <code>umbraco-unit-testing</code> Unit/component testing with <code>@open-wc/testing</code> <code>umbraco-msw-testing</code> Mock Service Worker patterns <code>umbraco-mocked-backoffice</code> Run backoffice with mocked APIs <code>umbraco-test-builders</code> <code>JsonModels.Builders</code> for test data <code>umbraco-example-generator</code> Generate testable example extensions"},{"location":"tooling/umbraco-skills/#when-to-use-skills","title":"When to Use Skills","text":"<ul> <li>Before implementing any extension type \u2014 invoke the skill first to see official patterns</li> <li>Before writing tests \u2014 use <code>umbraco-testing</code> to choose the right approach</li> <li>When something doesn't work \u2014 skills may reveal configuration or registration steps you missed</li> </ul>"},{"location":"tooling/umbraco-skills/#critical-lesson-skills-are-supplementary","title":"Critical Lesson: Skills Are Supplementary","text":"<p>Always verify against the Umbraco CMS source code</p> <p>Skills provide excellent starting guidance, but the Umbraco CMS source code is the definitive reference. The local clone at <code>d:\\Users\\deanl\\source\\repos\\Umbraco Extensions\\Umbraco-CMS</code> must be consulted for:</p> <ul> <li>How Umbraco itself implements similar features</li> <li>The actual API signatures and expected behaviour</li> <li>Edge cases not covered in documentation</li> </ul> <p>Lesson learned (Feb 2026): Multiple attempts to implement a collection create option failed because only skills/docs were consulted. The CMS source code revealed the extension point didn't exist in v17. Significant time and tokens were wasted.</p>"},{"location":"tooling/umbraco-skills/#the-right-workflow","title":"The Right Workflow","text":"<ol> <li>Invoke the skill \u2014 get the official pattern and example code</li> <li>Search the CMS source \u2014 find how Umbraco implements the same extension type internally</li> <li>Compare and adapt \u2014 use the skill's pattern but verify details against the source</li> <li>Implement \u2014 with confidence that the approach actually works</li> </ol>"},{"location":"tooling/umbraco-skills/#key-source-paths","title":"Key Source Paths","text":"<pre><code>Umbraco-CMS/src/Umbraco.Web.UI.Client/src/packages/\n\u251c\u2500\u2500 core/          # Core extension types, registries, conditions\n\u251c\u2500\u2500 documents/     # Document-related features\n\u251c\u2500\u2500 media/         # Media handling\n\u251c\u2500\u2500 members/       # Member management\n\u2514\u2500\u2500 ...\n</code></pre>"},{"location":"tooling/umbraco-skills/#references","title":"References","text":"<ul> <li>Umbraco CMS Backoffice Skills \u2014 plugin repository</li> <li>Umbraco CMS source \u2014 definitive reference</li> <li>UUI Storybook \u2014 base UI primitives</li> <li>Umbraco API Docs Storybook \u2014 composed components and patterns</li> </ul>"},{"location":"ui/","title":"User Interface","text":"<p>This section documents the UI components and patterns used in UpDoc, categorised by their origin:</p> <ul> <li>UUI Components \u2014 Native Umbraco UI Library primitives (<code>uui-*</code> elements)</li> <li>Umbraco Components \u2014 Higher-level Umbraco backoffice components (<code>umb-*</code> elements)</li> <li>Custom Components \u2014 Components built specifically for UpDoc (<code>up-doc-*</code> elements)</li> </ul>"},{"location":"ui/#design-principles","title":"Design Principles","text":"<p>UpDoc follows the Umbraco backoffice design language wherever possible. When building UI:</p> <ol> <li>Use native UUI/Umbraco components first \u2014 only create custom components when no native equivalent exists</li> <li>Follow established patterns \u2014 look at how Umbraco core and popular packages (uSync, Merchello) solve similar problems</li> <li>Consistent visual language \u2014 stat boxes, tab groups, tables, and layouts should match what users see elsewhere in the backoffice</li> <li>UUI CSS custom properties \u2014 all colours, spacing, and typography use <code>--uui-*</code> tokens, never hardcoded values</li> </ol>"},{"location":"ui/#references","title":"References","text":"<ul> <li>UUI Storybook \u2014 base UI primitives (<code>uui-button</code>, <code>uui-box</code>, <code>uui-tab</code>, etc.)</li> <li>Umbraco API Docs Storybook \u2014 composed Umbraco components, layout patterns, property editors</li> <li>Umbraco CMS Source \u2014 definitive reference for how components are used in practice</li> </ul>"},{"location":"ui/#gaps-and-feedback","title":"Gaps and Feedback","text":"<p>Where UpDoc has needed to work around limitations or build custom solutions, these are noted on the relevant component pages. This information is intended as constructive feedback for the Umbraco core team.</p>"},{"location":"ui/custom-components/","title":"Custom Components","text":"<p>Components built specifically for UpDoc (<code>up-doc-*</code> elements). These exist because no native UUI or Umbraco component provides the required functionality.</p>"},{"location":"ui/custom-components/#modals-and-dialogs","title":"Modals and Dialogs","text":""},{"location":"ui/custom-components/#blueprint-picker-modal","title":"blueprint-picker-modal","text":"<p>Two-step blueprint selection dialog. Lists allowed document types, then shows blueprints for the selected type.</p> <p>Element: <code>&lt;blueprint-picker-modal&gt;</code> Token: <code>UMB_BLUEPRINT_PICKER_MODAL</code> Type: Centered dialog (<code>uui-dialog-layout</code>) Source: <code>blueprint-picker-modal.element.ts</code></p> <p>Why custom: Umbraco's native document creation dialog queries allowed child types and is not extensible for third-party use (see Content Collection \"Create\" Button research). UpDoc needs to filter by blueprints that have configured workflows, which is domain-specific logic.</p>"},{"location":"ui/custom-components/#up-doc-modal","title":"up-doc-modal","text":"<p>Main extraction and document creation modal. Three-tab interface for source selection, content preview, and destination display.</p> <p>Element: <code>&lt;up-doc-modal&gt;</code> Token: <code>UMB_UP_DOC_MODAL</code> (type: <code>sidebar</code>, size: <code>small</code>) Source: <code>up-doc-modal.element.ts</code></p> <p>Why custom: The entire extraction \u2192 preview \u2192 creation workflow is UpDoc-specific. No native equivalent exists.</p>"},{"location":"ui/custom-components/#create-workflow-sidebar","title":"create-workflow-sidebar","text":"<p>Workflow creation sidebar modal. Collects workflow name, source type, and optional sample file.</p> <p>Element: <code>&lt;create-workflow-sidebar&gt;</code> Token: <code>UMB_CREATE_WORKFLOW_SIDEBAR</code> Source: <code>create-workflow-sidebar.element.ts</code></p> <p>Why custom: Workflow creation is an UpDoc-specific concept with domain-specific validation (unique names, source type selection, auto-generated naming).</p>"},{"location":"ui/custom-components/#up-doc-destination-picker-modal","title":"up-doc-destination-picker-modal","text":"<p>Multi-select picker for mapping source content to destination fields and block properties.</p> <p>Element: <code>&lt;up-doc-destination-picker-modal&gt;</code> Token: <code>UMB_DESTINATION_PICKER_MODAL</code> Source: <code>destination-picker-modal.element.ts</code></p> <p>Why custom: Maps UpDoc's extraction hierarchy to Umbraco's document type structure. Presents fields and block properties in tabs matching the destination blueprint structure.</p>"},{"location":"ui/custom-components/#workspace-views","title":"Workspace Views","text":""},{"location":"ui/custom-components/#up-doc-workflow-destination-view","title":"up-doc-workflow-destination-view","text":"<p>Read-only display of the blueprint structure showing available mapping targets.</p> <p>Element: <code>&lt;up-doc-workflow-destination-view&gt;</code> Source: <code>up-doc-workflow-destination-view.element.ts</code></p> <p>Layout: <code>umb-body-layout header-fit-height</code> with inner <code>uui-tab-group</code> tabs (Page Properties, Page Content).</p> <p>Why custom: Displays the destination side of the mapping equation \u2014 fields and block grids from the blueprint. This is a domain-specific view over Umbraco content type data.</p>"},{"location":"ui/custom-components/#up-doc-workflow-source-view","title":"up-doc-workflow-source-view","text":"<p>The extraction and transformation view. Two modes: Extracted (area detection hierarchy) and Transformed (assembled sections with pattern detection).</p> <p>Element: <code>&lt;up-doc-workflow-source-view&gt;</code> Source: <code>up-doc-workflow-source-view.element.ts</code></p> <p>Layout: <code>umb-body-layout header-fit-height</code> with a single <code>slot=\"header\"</code> div containing <code>uui-tab-group</code> (left) and Re-extract button (right), following the Document Type editor pattern. Stat boxes (Pages, Areas, Sections, Source) are in the scrollable content area above the page hierarchy.</p> <p>Hierarchy: Four-level collapsible display: Page (<code>uui-box</code> with <code>header-actions</code> chevron) \u2192 Area (\"Area 1\", \"Area 2\", or \"Undefined\" for unclassified content) \u2192 Section (with include/exclude toggle) \u2192 Text (with type/metadata badges). All levels use a consistent <code>collapse-chevron</code> icon positioned rightmost in each row.</p> <p>Why custom: The entire extraction hierarchy display (Page \u2192 Area \u2192 Section \u2192 Text) is UpDoc-specific. No native Umbraco component displays this kind of nested content structure.</p>"},{"location":"ui/custom-components/#up-doc-workflow-map-view","title":"up-doc-workflow-map-view","text":"<p>Table display of all mappings defined in <code>map.json</code>.</p> <p>Element: <code>&lt;up-doc-workflow-map-view&gt;</code> Source: <code>up-doc-workflow-map-view.element.ts</code></p> <p>Layout: <code>uui-table</code> with source \u2192 destination mappings, status indicators, and delete buttons.</p> <p>Why custom: Mapping definitions are an UpDoc-specific data structure. The table displays source keys, destination targets (with block property disambiguation), and enabled/disabled status.</p>"},{"location":"ui/custom-components/#settings-views","title":"Settings Views","text":""},{"location":"ui/custom-components/#up-doc-workflows-view","title":"up-doc-workflows-view","text":"<p>Workflow management dashboard. Lists all configured workflows with their status.</p> <p>Element: <code>&lt;up-doc-workflows-view&gt;</code> Source: <code>up-doc-workflows-view.element.ts</code></p> <p>Layout: <code>uui-table</code> with columns for workflow name, document type, blueprint, source type, mapping count, and status. Includes Create and Delete actions.</p> <p>Why custom: The workflow collection is an UpDoc-specific concept backed by JSON files on disk rather than Umbraco database entities.</p>"},{"location":"ui/custom-components/#up-doc-configuration-view","title":"up-doc-configuration-view","text":"<p>Placeholder for future global configuration settings.</p> <p>Element: <code>&lt;up-doc-configuration-view&gt;</code> Source: <code>up-doc-configuration-view.element.ts</code></p>"},{"location":"ui/custom-components/#up-doc-about-view","title":"up-doc-about-view","text":"<p>Help and resources view with documentation links and project information.</p> <p>Element: <code>&lt;up-doc-about-view&gt;</code> Source: <code>up-doc-about-view.element.ts</code></p> <p>Layout: Uses <code>uui-ref-list</code> and <code>uui-ref-node</code> for external links.</p>"},{"location":"ui/custom-components/#collection-actions","title":"Collection Actions","text":""},{"location":"ui/custom-components/#up-doc-collection-action","title":"up-doc-collection-action","text":"<p>\"Create from Source\" button that appears in the content collection toolbar.</p> <p>Element: <code>&lt;up-doc-collection-action&gt;</code> Source: <code>up-doc-collection-action.element.ts</code></p> <p>Renders: A single <code>uui-button</code> (color: <code>default</code>, look: <code>outline</code>) that self-hides when no workflows are available.</p> <p>Why custom: Umbraco's content collection \"Create\" button is not extensible for third-party options (see Content Collection \"Create\" Button research). UpDoc registers a separate collection action that checks for available workflows before rendering.</p>"},{"location":"ui/custom-components/#entity-actions","title":"Entity Actions","text":""},{"location":"ui/custom-components/#updoc-entity-action","title":"UpDoc Entity Action","text":"<p>\"Create Document from Source\" action in the content tree context menu.</p> <p>Class: <code>UpDocEntityAction</code> (extends <code>UmbEntityActionBase</code>) Source: <code>up-doc-action.ts</code></p> <p>Why custom: This is the primary entry point for UpDoc from the content tree. Standard Umbraco extension pattern (entity action registration).</p>"},{"location":"ui/custom-components/#gaps-and-feedback-for-umbraco-hq","title":"Gaps and Feedback for Umbraco HQ","text":""},{"location":"ui/custom-components/#content-collection-create-button-not-extensible","title":"Content collection create button not extensible","text":"<p>The content collection \"Create [Type]\" button at <code>documents/documents/collection/action/</code> queries allowed child types from <code>UmbDocumentTypeStructureRepository.requestAllowedChildrenOf()</code> and has no extension point for adding custom options. The Settings section equivalent at <code>core/collection/action/create/</code> uses <code>entityCreateOptionAction</code> which IS extensible.</p> <p>Impact: UpDoc must register a completely separate collection action button (\"Create from Source\") rather than adding an option to the existing create dropdown.</p> <p>Suggestion: Make the content collection create button use the same <code>entityCreateOptionAction</code> extension registry as the Settings section, allowing third-party packages to add options alongside the standard document type options.</p>"},{"location":"ui/custom-components/#no-standard-stat-box-dashboard-summary-component","title":"No standard stat box / dashboard summary component","text":"<p>There is no UUI or Umbraco component specifically designed for dashboard-style stat boxes (e.g., \"4 Pages\", \"9 Areas\", \"15 Sections\"). Packages like Merchello and uSync build these from <code>uui-box</code> with custom CSS. A dedicated <code>uui-stat-box</code> or <code>umb-dashboard-stat</code> component would standardise this common pattern.</p>"},{"location":"ui/umbraco-components/","title":"Umbraco Components","text":"<p>Higher-level Umbraco backoffice components (<code>umb-*</code>) used in UpDoc. These are composed from UUI primitives and provide Umbraco-specific layout and behaviour patterns.</p>"},{"location":"ui/umbraco-components/#layout","title":"Layout","text":""},{"location":"ui/umbraco-components/#umb-body-layout","title":"umb-body-layout","text":"<p>The primary layout component for all workspace views and modal contents. Provides a structured layout with header, content area, and actions slots.</p> <p>Where used: Every workspace view and sidebar modal in UpDoc.</p> <p>Attributes used:</p> Attribute Purpose <code>headline</code> Page/modal title text <code>header-fit-height</code> Allows header to size to content (used when tabs are in the header) <p>Slots used:</p> Slot Purpose <code>header</code> Tab groups and summary content placed here stay fixed above scrolling content <code>actions</code> Action buttons (Close, Create, Save) appear bottom-right default Main content area <p>Files: <code>up-doc-modal.element.ts</code>, <code>create-workflow-sidebar.element.ts</code>, <code>up-doc-workflow-destination-view.element.ts</code>, <code>up-doc-workflow-source-view.element.ts</code>, <code>up-doc-workflow-map-view.element.ts</code>, <code>destination-picker-modal.element.ts</code></p> <p>Example: <pre><code>&lt;!-- Destination view pattern: tabs only --&gt;\n&lt;umb-body-layout header-fit-height&gt;\n    &lt;uui-tab-group slot=\"header\" dropdown-content-direction=\"vertical\"&gt;\n        &lt;uui-tab label=\"Page Properties\" ?active=${true}&gt;Page Properties&lt;/uui-tab&gt;\n        &lt;uui-tab label=\"Page Content\"&gt;Page Content&lt;/uui-tab&gt;\n    &lt;/uui-tab-group&gt;\n    &lt;uui-box&gt;...&lt;/uui-box&gt;\n&lt;/umb-body-layout&gt;\n\n&lt;!-- Source view pattern: tabs + action button in header, stat boxes in content --&gt;\n&lt;umb-body-layout header-fit-height&gt;\n    &lt;div slot=\"header\" class=\"source-header\"&gt;\n        &lt;uui-tab-group dropdown-content-direction=\"vertical\"&gt;\n            &lt;uui-tab label=\"Extracted\" ?active=${true}&gt;Extracted&lt;/uui-tab&gt;\n            &lt;uui-tab label=\"Transformed\"&gt;Transformed&lt;/uui-tab&gt;\n        &lt;/uui-tab-group&gt;\n        &lt;div class=\"header-actions\"&gt;\n            &lt;uui-button look=\"outline\" label=\"Re-extract\"&gt;Re-extract&lt;/uui-button&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    &lt;!-- stat boxes in scrollable content area --&gt;\n    &lt;div class=\"stat-boxes\"&gt;&lt;!-- Pages, Areas, Sections, Source --&gt;&lt;/div&gt;\n    &lt;!-- page hierarchy content --&gt;\n&lt;/umb-body-layout&gt;\n</code></pre></p>"},{"location":"ui/umbraco-components/#properties-and-forms","title":"Properties and Forms","text":""},{"location":"ui/umbraco-components/#umb-property-layout","title":"umb-property-layout","text":"<p>Form field wrapper that provides a consistent label + description + editor layout, matching how Umbraco property editors are displayed.</p> <p>Where used: Form fields in modals \u2014 source type selector, document name, URL input, file pickers, workflow name.</p> <p>Attributes used:</p> Attribute Purpose <code>label</code> Field label text <code>description</code> Helper text below the label <code>orientation</code> <code>\"vertical\"</code> for stacked label/editor layout <p>Slots used:</p> Slot Purpose <code>editor</code> The input/control for this property <p>Files: <code>up-doc-modal.element.ts</code>, <code>create-workflow-sidebar.element.ts</code></p> <p>Example: <pre><code>&lt;umb-property-layout label=\"Document Name\" description=\"Name for the new document\"&gt;\n    &lt;uui-input slot=\"editor\" id=\"documentName\"\n        .value=${this._documentName}\n        @input=${this.#onNameChange}&gt;\n    &lt;/uui-input&gt;\n&lt;/umb-property-layout&gt;\n</code></pre></p>"},{"location":"ui/umbraco-components/#media","title":"Media","text":""},{"location":"ui/umbraco-components/#umb-input-media","title":"umb-input-media","text":"<p>Media picker component for selecting files from the Umbraco media library.</p> <p>Where used: PDF and Markdown file selection in the source modal and workflow source view.</p> <p>Attributes used: <code>max=\"1\"</code> (single file selection)</p> <p>Events: <code>@change</code> \u2014 fires when media selection changes</p> <p>Files: <code>up-doc-modal.element.ts</code>, <code>create-workflow-sidebar.element.ts</code>, <code>up-doc-workflow-source-view.element.ts</code></p>"},{"location":"ui/umbraco-components/#icons","title":"Icons","text":""},{"location":"ui/umbraco-components/#umb-icon","title":"umb-icon","text":"<p>Umbraco's icon component, used where document type or blueprint icons need to be displayed.</p> <p>Where used: Document type and blueprint icons in selection lists, block icons in the destination view.</p> <p>Attributes used: <code>name</code>, <code>slot=\"icon\"</code></p> <p>Files: <code>blueprint-picker-modal.element.ts</code>, <code>up-doc-workflow-destination-view.element.ts</code>, <code>destination-picker-modal.element.ts</code></p>"},{"location":"ui/umbraco-components/#imports-and-base-classes","title":"Imports and Base Classes","text":"<p>All UpDoc components extend <code>UmbLitElement</code> (from <code>@umbraco-cms/backoffice/lit-element</code>) rather than plain <code>LitElement</code>. This provides:</p> <ul> <li>Umbraco context consumption (<code>this.consumeContext()</code>, <code>this.getContext()</code>)</li> <li>Observable pattern (<code>this.observe()</code>)</li> <li>Automatic cleanup on disconnect</li> </ul> <p>Common imports:</p> <pre><code>import { html, css, state, nothing } from '@umbraco-cms/backoffice/external/lit';\nimport { customElement } from '@umbraco-cms/backoffice/external/lit';\nimport { UmbLitElement } from '@umbraco-cms/backoffice/lit-element';\nimport { UmbTextStyles } from '@umbraco-cms/backoffice/style';\n</code></pre> <p>Context providers used:</p> Context Purpose <code>UMB_AUTH_CONTEXT</code> Authentication token for API calls <code>UMB_WORKSPACE_CONTEXT</code> Current workspace entity info (unique ID) <code>UMB_MODAL_MANAGER_CONTEXT</code> Opening modals from within components <code>UMB_NOTIFICATION_CONTEXT</code> Toast notifications <code>UMB_DOCUMENT_WORKSPACE_CONTEXT</code> Document workspace info (for collection actions) <p>Modal base class: Modals extend <code>UmbModalBaseElement</code> (from <code>@umbraco-cms/backoffice/modal</code>) and use <code>UMB_MODAL_MANAGER_CONTEXT</code> for nested modal opening.</p> <p>Repository classes used: - <code>UmbDocumentBlueprintItemRepository</code> \u2014 blueprint lookups - <code>UmbDocumentItemRepository</code> \u2014 document lookups - <code>UmbDocumentTypeStructureRepository</code> \u2014 allowed child type queries</p>"},{"location":"ui/uui-components/","title":"UUI Components","text":"<p>Native Umbraco UI Library (<code>uui-*</code>) components used in UpDoc.</p>"},{"location":"ui/uui-components/#buttons-and-actions","title":"Buttons and Actions","text":""},{"location":"ui/uui-components/#uui-button","title":"uui-button","text":"<p>The primary interactive element throughout UpDoc. Used for all action buttons.</p> <p>Where used: Every modal and workspace view \u2014 Create, Save, Delete, Close, Map, Re-extract buttons.</p> <p>Attributes used:</p> Attribute Values Context <code>look</code> <code>primary</code>, <code>secondary</code>, <code>outline</code>, <code>default</code> Visual prominence <code>color</code> <code>positive</code>, <code>danger</code> Semantic colour <code>compact</code> boolean Smaller buttons in tight layouts <code>disabled</code> boolean Prevents interaction during loading <code>label</code> string Accessible label <p>Files: All modal and view elements.</p> <p>Example: <pre><code>&lt;uui-button look=\"primary\" label=\"Create\" @click=${this.#onCreate}&gt;Create&lt;/uui-button&gt;\n&lt;uui-button look=\"secondary\" label=\"Re-extract\" @click=${this.#onPickMedia}&gt;\n    &lt;uui-icon name=\"icon-refresh\"&gt;&lt;/uui-icon&gt; Re-extract\n&lt;/uui-button&gt;\n</code></pre></p>"},{"location":"ui/uui-components/#uui-action-bar","title":"uui-action-bar","text":"<p>Toolbar container for grouping action buttons.</p> <p>Where used: Copy button on content preview cards in the source modal.</p> <p>Files: <code>up-doc-modal.element.ts</code></p>"},{"location":"ui/uui-components/#navigation-and-tabs","title":"Navigation and Tabs","text":""},{"location":"ui/uui-components/#uui-tab-group","title":"uui-tab-group","text":"<p>Container for tab navigation. Used at two levels in UpDoc:</p> <ol> <li>Workspace-level tabs \u2014 Destination, Source, Map (top-level navigation with icons)</li> <li>Content-area tabs \u2014 Page Properties / Page Content (Destination view), Extracted / Transformed (Source view). Both use <code>slot=\"header\"</code> on <code>umb-body-layout</code> for consistent positioning.</li> </ol> <p>Attributes used: <code>dropdown-content-direction=\"vertical\"</code></p> <p>Files: <code>up-doc-modal.element.ts</code>, <code>create-workflow-sidebar.element.ts</code>, <code>up-doc-workflow-destination-view.element.ts</code>, <code>up-doc-workflow-source-view.element.ts</code>, <code>destination-picker-modal.element.ts</code></p>"},{"location":"ui/uui-components/#uui-tab","title":"uui-tab","text":"<p>Individual tab within a <code>uui-tab-group</code>.</p> <p>Attributes used:</p> Attribute Purpose <code>label</code> Tab label text <code>active</code> Whether this tab is currently selected <code>disabled</code> Greyed out when content unavailable <p>Text rendering gotcha</p> <p><code>uui-tab</code> requires text content inside the element (<code>${tab.label}</code>) in addition to the <code>label</code> attribute. The <code>label</code> attribute alone does not render visible text when inside <code>umb-body-layout</code>. Always include both.</p> <p>Example: <pre><code>&lt;uui-tab-group&gt;\n    &lt;uui-tab label=\"Extracted\" ?active=${this._viewMode === 'elements'}\n        @click=${() =&gt; { this._viewMode = 'elements'; }}&gt;Extracted&lt;/uui-tab&gt;\n    &lt;uui-tab label=\"Transformed\" ?active=${this._viewMode === 'transformed'}\n        @click=${() =&gt; { this._viewMode = 'transformed'; }}\n        ?disabled=${!this._transformResult}&gt;Transformed&lt;/uui-tab&gt;\n&lt;/uui-tab-group&gt;\n</code></pre></p>"},{"location":"ui/uui-components/#input-and-selection","title":"Input and Selection","text":""},{"location":"ui/uui-components/#uui-input","title":"uui-input","text":"<p>Text input field.</p> <p>Where used: Document name input, URL input for web sources, workflow name input.</p> <p>Files: <code>up-doc-modal.element.ts</code>, <code>create-workflow-sidebar.element.ts</code>, <code>destination-picker-modal.element.ts</code></p> <p>Testing gotcha</p> <p><code>uui-input</code> is not a native input. In Playwright tests, use <code>locator('uui-input#id input')</code> to reach the inner <code>&lt;input&gt;</code> element for <code>inputValue()</code> or <code>toBeEmpty()</code>.</p>"},{"location":"ui/uui-components/#uui-select","title":"uui-select","text":"<p>Dropdown for single-value selection.</p> <p>Where used: Source type picker (PDF, Markdown, Web, Word).</p> <p>Files: <code>up-doc-modal.element.ts</code>, <code>create-workflow-sidebar.element.ts</code></p> <p>Re-render gotcha</p> <p><code>uui-select</code> requires explicit <code>this.requestUpdate()</code> after state changes to trigger Lit re-render of conditional UI below the dropdown.</p>"},{"location":"ui/uui-components/#uui-checkbox","title":"uui-checkbox","text":"<p>Multi-select checkbox.</p> <p>Where used: Field and block property selection in the destination picker modal.</p> <p>Files: <code>destination-picker-modal.element.ts</code></p>"},{"location":"ui/uui-components/#uui-toggle","title":"uui-toggle","text":"<p>On/off toggle switch.</p> <p>Where used: Section include/exclude toggle in the Source view (Extracted mode).</p> <p>Files: <code>up-doc-workflow-source-view.element.ts</code></p>"},{"location":"ui/uui-components/#layout-and-containers","title":"Layout and Containers","text":""},{"location":"ui/uui-components/#uui-box","title":"uui-box","text":"<p>Bordered content container with optional headline.</p> <p>Where used: Content sections throughout \u2014 workflow empty states, field/block groups, page containers, transformed sections.</p> <p>Attributes used: <code>headline</code></p> <p>Slots used: <code>header-actions</code> (for badges and buttons in the box header)</p> <p>Files: All view elements.</p> <p>Example: <pre><code>&lt;uui-box headline=\"Page 1\" class=\"page-box\"&gt;\n    &lt;!-- page content --&gt;\n&lt;/uui-box&gt;\n</code></pre></p>"},{"location":"ui/uui-components/#data-display","title":"Data Display","text":""},{"location":"ui/uui-components/#uui-table-uui-table-head-uui-table-head-cell-uui-table-row-uui-table-cell","title":"uui-table, uui-table-head, uui-table-head-cell, uui-table-row, uui-table-cell","text":"<p>Standard table components for data display.</p> <p>Where used: - Workflow list in the Settings dashboard (<code>up-doc-workflows-view.element.ts</code>) - Mapping definitions table (<code>up-doc-workflow-map-view.element.ts</code>)</p> <p>Notes: Table rows in the workflow list are clickable for navigation.</p>"},{"location":"ui/uui-components/#uui-tag","title":"uui-tag","text":"<p>Status badge / label component.</p> <p>Where used: - Workflow status indicators: \"Ready\" (positive), \"Incomplete\" (warning) - Required field markers on destination view - Disabled mapping indicators</p> <p>Attributes used:</p> Attribute Values <code>look</code> <code>primary</code>, <code>secondary</code> <code>color</code> <code>positive</code>, <code>warning</code>, <code>danger</code> <p>Files: <code>up-doc-workflows-view.element.ts</code>, <code>up-doc-workflow-destination-view.element.ts</code>, <code>up-doc-workflow-map-view.element.ts</code></p>"},{"location":"ui/uui-components/#icons","title":"Icons","text":""},{"location":"ui/uui-components/#uui-icon","title":"uui-icon","text":"<p>Inline icon component.</p> <p>Where used: Throughout the entire UI \u2014 tab icons, status indicators, action buttons, badges.</p> <p>Icon names used in UpDoc:</p> Icon Context <code>icon-document</code> PDF/document references <code>icon-document-dashed-line</code> Empty states <code>icon-blueprint</code> Blueprint references <code>icon-edit</code> Edit actions <code>icon-page-add</code> Create actions <code>icon-nodes</code> Mapping/connections <code>icon-settings</code> Configuration <code>icon-info</code> Information <code>icon-alert</code> Warnings <code>icon-check</code> Success/mapped status <code>icon-trash</code> Delete actions <code>icon-documents</code> Document lists <code>icon-box</code> Block references <code>icon-link</code> Mapping link <code>icon-refresh</code> Re-extract <code>icon-navigation-right</code> Collapsed state <code>icon-navigation-down</code> Expanded state <code>icon-arrow-right</code> Source \u2192 Destination arrow <code>icon-lab</code> Transform/experimental <code>icon-book-alt</code> Documentation <code>icon-code</code> Source code <code>icon-globe</code> Web source type"},{"location":"ui/uui-components/#dialogs","title":"Dialogs","text":""},{"location":"ui/uui-components/#uui-dialog-layout","title":"uui-dialog-layout","text":"<p>Container for centered dialog modals.</p> <p>Where used: Blueprint picker dialog.</p> <p>Attributes used: <code>headline</code></p> <p>Files: <code>blueprint-picker-modal.element.ts</code></p>"},{"location":"ui/uui-components/#menus","title":"Menus","text":""},{"location":"ui/uui-components/#uui-menu-item","title":"uui-menu-item","text":"<p>List item for selection lists.</p> <p>Where used: Document type and blueprint selectors in the blueprint picker.</p> <p>Attributes used: <code>label</code></p> <p>Files: <code>blueprint-picker-modal.element.ts</code></p>"},{"location":"ui/uui-components/#loading-and-status","title":"Loading and Status","text":""},{"location":"ui/uui-components/#uui-loader-bar","title":"uui-loader-bar","text":"<p>Progress indicator bar.</p> <p>Where used: Loading states during data fetch, extraction progress.</p> <p>Files: All modal and view elements that perform async operations.</p>"},{"location":"ui/uui-components/#reference-links","title":"Reference Links","text":""},{"location":"ui/uui-components/#uui-ref-list-uui-ref-node","title":"uui-ref-list, uui-ref-node","text":"<p>Reference link list and individual link items.</p> <p>Where used: About/help view with documentation and source code links.</p> <p>Attributes used: <code>name</code>, <code>detail</code>, <code>href</code>, <code>target</code></p> <p>Files: <code>up-doc-about-view.element.ts</code></p>"},{"location":"ui/uui-components/#css-custom-properties","title":"CSS Custom Properties","text":"<p>All styling uses UUI CSS custom properties. No hardcoded colour values.</p> <p>Colours: <code>--uui-color-surface</code>, <code>--uui-color-surface-alt</code>, <code>--uui-color-surface-emphasis</code>, <code>--uui-color-border</code>, <code>--uui-color-border-standalone</code>, <code>--uui-color-text</code>, <code>--uui-color-text-alt</code>, <code>--uui-color-danger</code>, <code>--uui-color-positive</code>, <code>--uui-color-positive-emphasis</code>, <code>--uui-color-positive-contrast</code>, <code>--uui-color-warning</code>, <code>--uui-color-warning-emphasis</code>, <code>--uui-color-warning-contrast</code>, <code>--uui-color-selected</code>, <code>--uui-color-default-emphasis</code>, <code>--uui-color-default-contrast</code></p> <p>Spacing: <code>--uui-size-space-1</code> through <code>--uui-size-space-6</code>, <code>--uui-size-layout-1</code>, <code>--uui-size-layout-2</code></p> <p>Typography: <code>--uui-type-small-size</code>, <code>--uui-type-default-size</code>, <code>--uui-type-h5-size</code></p> <p>Borders: <code>--uui-border-radius</code></p> <p>Base styles mixin: All components include <code>UmbTextStyles</code> as the first entry in <code>static override styles</code>.</p>"}]}